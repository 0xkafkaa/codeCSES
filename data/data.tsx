const problems = [
  {
    id: 1068,
    name: "Weird Algorithm",
    question:
      "Consider an algorithm that takes as input a positive integer n. If n is even, the algorithm divides it by two, and if n is odd, the algorithm multiplies it by three and adds one. The algorithm repeats this, until n is one. For example, the sequence for n = 3 is as follows:\n3 → 10 → 5 → 16 → 8 → 4 → 2 → 1\nYour task is to simulate the execution of the algorithm for a given value of n.",
    tags: "Introductory Problems",
  },
  {
    id: 1083,
    name: "Missing Number",
    question:
      "You are given all numbers between 1, 2, …, n except one. Your task is to find the missing number.",
    tags: "Introductory Problems",
  },
  {
    id: 1069,
    name: "Repetitions",
    question:
      "You are given a DNA sequence: a string consisting of characters A, C, G, and T. Your task is to find the longest repetition in the sequence. This is a maximum-length substring containing only one type of character.",
    tags: "Introductory Problems",
  },
  {
    id: 1094,
    name: "Increasing Array",
    question:
      "You are given an array of n integers. You want to modify the array so that it is increasing, i.e., every element is at least as large as the previous element. On each move, you may increase the value of any element by one. What is the minimum number of moves required?",
    tags: "Introductory Problems",
  },
  {
    id: 1070,
    name: "Permutations",
    question:
      "A permutation of integers 1, 2, …, n is called beautiful if there are no adjacent elements whose difference is 1. Given n, construct a beautiful permutation if such a permutation exists.",
    tags: "Introductory Problems",
  },
  {
    id: 1071,
    name: "Number Spiral",
    question:
      "A number spiral is an infinite grid whose upper-left square has number 1. Here are the first five layers of the spiral: Your task is to find out the number in row y and column x.",
    tags: "Introductory Problems",
  },
  {
    id: 1072,
    name: "Two Knights",
    question:
      "Your task is to count for k = 1, 2, …, n the number of ways two knights can be placed on a k × k chessboard so that they do not attack each other.",
    tags: "Introductory Problems",
  },
  {
    id: 1092,
    name: "Two Sets",
    question:
      "Your task is to divide the numbers 1, 2, …, n into two sets of equal sum.",
    tags: "Introductory Problems",
  },
  {
    id: 1617,
    name: "Bit Strings",
    question:
      "Your task is to calculate the number of bit strings of length n. For example, if n = 3, the correct answer is 8, because the possible bit strings are 000, 001, 010, 011, 100, 101, 110, and 111.",
    tags: "Introductory Problems",
  },
  {
    id: 1618,
    name: "Trailing Zeros",
    question:
      "Your task is to calculate the number of trailing zeros in the factorial n!. For example, 20! = 2432902008176640000 and it has 4 trailing zeros.",
    tags: "Introductory Problems",
  },
  {
    id: 1754,
    name: "Coin Piles",
    question:
      "You have two coin piles containing a and b coins. On each move, you can either remove one coin from the left pile and two coins from the right pile, or two coins from the left pile and one coin from the right pile. Your task is to efficiently find out if you can empty both the piles.",
    tags: "Introductory Problems",
  },
  {
    id: 1755,
    name: "Palindrome Reorder",
    question:
      "Given a string, your task is to reorder its letters in such a way that it becomes a palindrome (i.e., it reads the same forwards and backwards).",
    tags: "Introductory Problems",
  },
  {
    id: 2205,
    name: "Gray Code",
    question:
      "A Gray code is a list of all 2^(n) bit strings of length n, where any two successive strings differ in exactly one bit (i.e., their Hamming distance is one). Your task is to create a Gray code for a given length n.",
    tags: "Introductory Problems",
  },
  {
    id: 2165,
    name: "Tower of Hanoi",
    question:
      "The Tower of Hanoi game consists of three stacks (left, middle and right) and n round disks of different sizes. Initially, the left stack has all the disks, in increasing order of size from top to bottom. The goal is to move all the disks to the right stack using the middle stack. On each move you can move the uppermost disk from a stack to another stack. In addition, it is not allowed to place a larger disk on a smaller disk. Your task is to find a solution that minimizes the number of moves.",
    tags: "Introductory Problems",
  },
  {
    id: 1622,
    name: "Creating Strings",
    question:
      "Given a string, your task is to generate all different strings that can be created using its characters.",
    tags: "Introductory Problems",
  },
  {
    id: 1623,
    name: "Apple Division",
    question:
      "There are n apples with known weights. Your task is to divide the apples into two groups so that the difference between the weights of the groups is minimal.",
    tags: "Introductory Problems",
  },
  {
    id: 1624,
    name: "Chessboard and Queens",
    question:
      "Your task is to place eight queens on a chessboard so that no two queens are attacking each other. As an additional challenge, each square is either free or reserved, and you can only place queens on the free squares. However, the reserved squares do not prevent queens from attacking each other. How many possible ways are there to place the queens?",
    tags: "Introductory Problems",
  },
  {
    id: 2431,
    name: "Digit Queries",
    question:
      "Consider an infinite string that consists of all positive integers in increasing order:\n12345678910111213141516171819202122232425...\nYour task is to process q queries of the form: what is the digit at position k in the string?",
    tags: "Introductory Problems",
  },
  {
    id: 1625,
    name: "Grid Paths",
    question:
      "There are 88418 paths in a 7 × 7 grid from the upper-left square to the lower-left square. Each path corresponds to a 48-character description consisting of characters\nD\n(down),\nU\n(up),\nL\n(left) and\nR\n(right). For example, the path corresponds to the description\nDRURRRRRDDDLUULDDDLDRRURDDLLLLLURULURRUULDLLDDDD\n. You are given a description of a path which may also contain characters\n?\n(any direction). Your task is to calculate the number of paths that match the description.",
    tags: "Introductory Problems",
  },
  {
    id: 1621,
    name: "Distinct Numbers",
    question:
      "You are given a list of n integers, and your task is to calculate the number of distinct values in the list.",
    tags: "Sorting and Searching",
  },
  {
    id: 1084,
    name: "Apartments",
    question:
      "There are n applicants and m free apartments. Your task is to distribute the apartments so that as many applicants as possible will get an apartment. Each applicant has a desired apartment size, and they will accept any apartment whose size is close enough to the desired size.",
    tags: "Sorting and Searching",
  },
  {
    id: 1090,
    name: "Ferris Wheel",
    question:
      "There are n children who want to go to a Ferris wheel, and your task is to find a gondola for each child. Each gondola may have one or two children in it, and in addition, the total weight in a gondola may not exceed x. You know the weight of every child. What is the minimum number of gondolas needed for the children?",
    tags: "Sorting and Searching",
  },
  {
    id: 1091,
    name: "Concert Tickets",
    question:
      "There are n concert tickets available, each with a certain price. Then, m customers arrive, one after another. Each customer announces the maximum price they are willing to pay for a ticket, and after this, they will get a ticket with the nearest possible price such that it does not exceed the maximum price.",
    tags: "Sorting and Searching",
  },
  {
    id: 1619,
    name: "Restaurant Customers",
    question:
      "You are given the arrival and leaving times of n customers in a restaurant. What was the maximum number of customers in the restaurant at any time?",
    tags: "Sorting and Searching",
  },
  {
    id: 1629,
    name: "Movie Festival",
    question:
      "In a movie festival n movies will be shown. You know the starting and ending time of each movie. What is the maximum number of movies you can watch entirely?",
    tags: "Sorting and Searching",
  },
  {
    id: 1640,
    name: "Sum of Two Values",
    question:
      "You are given an array of n integers, and your task is to find two values (at distinct positions) whose sum is x.",
    tags: "Sorting and Searching",
  },
  {
    id: 1643,
    name: "Maximum Subarray Sum",
    question:
      "Given an array of n integers, your task is to find the maximum sum of values in a contiguous, nonempty subarray.",
    tags: "Sorting and Searching",
  },
  {
    id: 1074,
    name: "Stick Lengths",
    question:
      "There are n sticks with some lengths. Your task is to modify the sticks so that each stick has the same length. You can either lengthen and shorten each stick. Both operations cost x where x is the difference between the new and original length. What is the minimum total cost?",
    tags: "Sorting and Searching",
  },
  {
    id: 2183,
    name: "Missing Coin Sum",
    question:
      "You have n coins with positive integer values. What is the smallest sum you cannot create using a subset of the coins?",
    tags: "Sorting and Searching",
  },
  {
    id: 2216,
    name: "Collecting Numbers",
    question:
      "You are given an array that contains each number between 1…n exactly once. Your task is to collect the numbers from 1 to n in increasing order. On each round, you go through the array from left to right and collect as many numbers as possible. What will be the total number of rounds?",
    tags: "Sorting and Searching",
  },
  {
    id: 2217,
    name: "Collecting Numbers II",
    question:
      "You are given an array that contains each number between 1…n exactly once. Your task is to collect the numbers from 1 to n in increasing order. On each round, you go through the array from left to right and collect as many numbers as possible. Given m operations that swap two numbers in the array, your task is to report the number of rounds after each operation.",
    tags: "Sorting and Searching",
  },
  {
    id: 1141,
    name: "Playlist",
    question:
      "You are given a playlist of a radio station since its establishment. The playlist has a total of n songs. What is the longest sequence of successive songs where each song is unique?",
    tags: "Sorting and Searching",
  },
  {
    id: 1073,
    name: "Towers",
    question:
      "You are given n cubes in a certain order, and your task is to build towers using them. Whenever two cubes are one on top of the other, the upper cube must be smaller than the lower cube. You must process the cubes in the given order. You can always either place the cube on top of an existing tower, or begin a new tower. What is the minimum possible number of towers?",
    tags: "Sorting and Searching",
  },
  {
    id: 1163,
    name: "Traffic Lights",
    question:
      "There is a street of length x whose positions are numbered 0, 1, …, x. Initially there are no traffic lights, but n sets of traffic lights are added to the street one after another. Your task is to calculate the length of the longest passage without traffic lights after each addition.",
    tags: "Sorting and Searching",
  },
  {
    id: 2162,
    name: "Josephus Problem I",
    question:
      "Consider a game where there are n children (numbered 1, 2, …, n) in a circle. During the game, every second child is removed from the circle, until there are no children left. In which order will the children be removed?",
    tags: "Sorting and Searching",
  },
  {
    id: 2163,
    name: "Josephus Problem II",
    question:
      "Consider a game where there are n children (numbered 1, 2, …, n) in a circle. During the game, repeatedly k children are skipped and one child is removed from the circle. In which order will the children be removed?",
    tags: "Sorting and Searching",
  },
  {
    id: 2168,
    name: "Nested Ranges Check",
    question:
      "Given n ranges, your task is to determine for each range if it contains some other range and if some other range contains it. Range [a,b] contains range [c,d] if a ≤ c and d ≤ b.",
    tags: "Sorting and Searching",
  },
  {
    id: 2169,
    name: "Nested Ranges Count",
    question:
      "Given n ranges, your task is to count for each range how many other ranges it contains and how many other ranges contain it. Range [a,b] contains range [c,d] if a ≤ c and d ≤ b.",
    tags: "Sorting and Searching",
  },
  {
    id: 1164,
    name: "Room Allocation",
    question:
      "There is a large hotel, and n customers will arrive soon. Each customer wants to have a single room. You know each customer’s arrival and departure day. Two customers can stay in the same room if the departure day of the first customer is earlier than the arrival day of the second customer. What is the minimum number of rooms that are needed to accommodate all customers? And how can the rooms be allocated?",
    tags: "Sorting and Searching",
  },
  {
    id: 1620,
    name: "Factory Machines",
    question:
      "A factory has n machines which can be used to make products. Your goal is to make a total of t products. For each machine, you know the number of seconds it needs to make a single product. The machines can work simultaneously, and you can freely decide their schedule. What is the shortest time needed to make t products?",
    tags: "Sorting and Searching",
  },
  {
    id: 1630,
    name: "Tasks and Deadlines",
    question:
      "You have to process n tasks. Each task has a duration and a deadline, and you will process the tasks in some order one after another. Your reward for a task is d − f where d is its deadline and f is your finishing time. (The starting time is 0, and you have to process all tasks even if a task would yield negative reward.) What is your maximum reward if you act optimally?",
    tags: "Sorting and Searching",
  },
  {
    id: 1631,
    name: "Reading Books",
    question:
      "There are n books, and Kotivalo and Justiina are going to read them all. For each book, you know the time it takes to read it. They both read each book from beginning to end, and they cannot read a book at the same time. What is the minimum total time required?",
    tags: "Sorting and Searching",
  },
  {
    id: 1641,
    name: "Sum of Three Values",
    question:
      "You are given an array of n integers, and your task is to find three values (at distinct positions) whose sum is x.",
    tags: "Sorting and Searching",
  },
  {
    id: 1642,
    name: "Sum of Four Values",
    question:
      "You are given an array of n integers, and your task is to find four values (at distinct positions) whose sum is x.",
    tags: "Sorting and Searching",
  },
  {
    id: 1645,
    name: "Nearest Smaller Values",
    question:
      "Given an array of n integers, your task is to find for each array position the nearest position to its left having a smaller value.",
    tags: "Sorting and Searching",
  },
  {
    id: 1660,
    name: "Subarray Sums I",
    question:
      "Given an array of n positive integers, your task is to count the number of subarrays having sum x.",
    tags: "Sorting and Searching",
  },
  {
    id: 1661,
    name: "Subarray Sums II",
    question:
      "Given an array of n integers, your task is to count the number of subarrays having sum x.",
    tags: "Sorting and Searching",
  },
  {
    id: 1662,
    name: "Subarray Divisibility",
    question:
      "Given an array of n integers, your task is to count the number of subarrays where the sum of values is divisible by n.",
    tags: "Sorting and Searching",
  },
  {
    id: 2428,
    name: "Subarray Distinct Values",
    question:
      "Given an array of n integers, your task is to calculate the number of subarrays that have at most k distinct values.",
    tags: "Sorting and Searching",
  },
  {
    id: 1085,
    name: "Array Division",
    question:
      "You are given an array containing n positive integers. Your task is to divide the array into k subarrays so that the maximum sum in a subarray is as small as possible.",
    tags: "Sorting and Searching",
  },
  {
    id: 1076,
    name: "Sliding Median",
    question:
      "You are given an array of n integers. Your task is to calculate the median of each window of k elements, from left to right. The median is the middle element when the elements are sorted. If the number of elements is even, there are two possible medians and we assume that the median is the smaller of them.",
    tags: "Sorting and Searching",
  },
  {
    id: 1077,
    name: "Sliding Cost",
    question:
      "You are given an array of n integers. Your task is to calculate for each window of k elements, from left to right, the minimum total cost of making all elements equal. You can increase or decrease each element with cost x where x is the difference between the new and the original value. The total cost is the sum of such costs.",
    tags: "Sorting and Searching",
  },
  {
    id: 1632,
    name: "Movie Festival II",
    question:
      "In a movie festival, n movies will be shown. Syrjälä’s movie club consists of k members, who will be all attending the festival. You know the starting and ending time of each movie. What is the maximum total number of movies the club members can watch entirely if they act optimally?",
    tags: "Sorting and Searching",
  },
  {
    id: 1644,
    name: "Maximum Subarray Sum II",
    question:
      "Given an array of n integers, your task is to find the maximum sum of values in a contiguous subarray with length between a and b.",
    tags: "Sorting and Searching",
  },
  {
    id: 1633,
    name: "Dice Combinations",
    question:
      "Your task is to count the number of ways to construct sum n by throwing a dice one or more times. Each throw produces an outcome between 1 and 6. For example, if n = 3, there are 4 ways:\n\n- 1 + 1 + 1\n- 1 + 2\n- 2 + 1\n- 3",
    tags: "Dynamic Programming",
  },
  {
    id: 1634,
    name: "Minimizing Coins",
    question:
      "Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to produce a sum of money x using the available coins in such a way that the number of coins is minimal. For example, if the coins are {1, 5, 7} and the desired sum is 11, an optimal solution is 5 + 5 + 1 which requires 3 coins.",
    tags: "Dynamic Programming",
  },
  {
    id: 1635,
    name: "Coin Combinations I",
    question:
      "Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to calculate the number of distinct ways you can produce a money sum x using the available coins. For example, if the coins are {2, 3, 5} and the desired sum is 9, there are 8 ways:\n\n- 2 + 2 + 5\n- 2 + 5 + 2\n- 5 + 2 + 2\n- 3 + 3 + 3\n- 2 + 2 + 2 + 3\n- 2 + 2 + 3 + 2\n- 2 + 3 + 2 + 2\n- 3 + 2 + 2 + 2",
    tags: "Dynamic Programming",
  },
  {
    id: 1636,
    name: "Coin Combinations II",
    question:
      "Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to calculate the number of distinct ordered ways you can produce a money sum x using the available coins. For example, if the coins are {2, 3, 5} and the desired sum is 9, there are 3 ways:\n\n- 2 + 2 + 5\n- 3 + 3 + 3\n- 2 + 2 + 2 + 3",
    tags: "Dynamic Programming",
  },
  {
    id: 1637,
    name: "Removing Digits",
    question:
      "You are given an integer n. On each step, you may subtract one of the digits from the number. How many steps are required to make the number equal to 0?",
    tags: "Dynamic Programming",
  },
  {
    id: 1638,
    name: "Grid Paths",
    question:
      "Consider an n × n grid whose squares may have traps. It is not allowed to move to a square with a trap. Your task is to calculate the number of paths from the upper-left square to the lower-right square. You can only move right or down.",
    tags: "Dynamic Programming",
  },
  {
    id: 1158,
    name: "Book Shop",
    question:
      "You are in a book shop which sells n different books. You know the price and number of pages of each book. You have decided that the total price of your purchases will be at most x. What is the maximum number of pages you can buy? You can buy each book at most once.",
    tags: "Dynamic Programming",
  },
  {
    id: 1746,
    name: "Array Description",
    question:
      "You know that an array has n integers between 1 and m, and the absolute difference between two adjacent values is at most 1. Given a description of the array where some values may be unknown, your task is to count the number of arrays that match the description.",
    tags: "Dynamic Programming",
  },
  {
    id: 2413,
    name: "Counting Towers",
    question:
      "Your task is to build a tower whose width is 2 and height is n. You have an unlimited supply of blocks whose width and height are integers. For example, here are some possible solutions for n = 6: Given n, how many different towers can you build? Mirrored and rotated towers are counted separately if they look different.",
    tags: "Dynamic Programming",
  },
  {
    id: 1639,
    name: "Edit Distance",
    question:
      "The edit distance between two strings is the minimum number of operations required to transform one string into the other. The allowed operations are:\n\n- Add one character to the string.\n- Remove one character from the string.\n- Replace one character in the string.\n\nFor example, the edit distance between LOVE and MOVIE is 2, because you can first replace L with M, and then add I. Your task is to calculate the edit distance between two strings.",
    tags: "Dynamic Programming",
  },
  {
    id: 1744,
    name: "Rectangle Cutting",
    question:
      "Given an a × b rectangle, your task is to cut it into squares. On each move you can select a rectangle and cut it into two rectangles in such a way that all side lengths remain integers. What is the minimum possible number of moves?",
    tags: "Dynamic Programming",
  },
  {
    id: 1745,
    name: "Money Sums",
    question:
      "You have n coins with certain values. Your task is to find all money sums you can create using these coins.",
    tags: "Dynamic Programming",
  },
  {
    id: 1097,
    name: "Removal Game",
    question:
      "There is a list of n numbers and two players who move alternately. On each move, a player removes either the first or last number from the list, and their score increases by that number. Both players try to maximize their scores. What is the maximum possible score for the first player when both players play optimally?",
    tags: "Dynamic Programming",
  },
  {
    id: 1093,
    name: "Two Sets II",
    question:
      "Your task is to count the number of ways numbers 1, 2, …, n can be divided into two sets of equal sum. For example, if n = 7, there are four solutions:\n\n- {1, 3, 4, 6} and {2, 5, 7}\n- {1, 2, 5, 6} and {3, 4, 7}\n- {1, 2, 4, 7} and {3, 5, 6}\n- {1, 6, 7} and {2, 3, 4, 5}",
    tags: "Dynamic Programming",
  },
  {
    id: 1145,
    name: "Increasing Subsequence",
    question:
      "You are given an array containing n integers. Your task is to determine the longest increasing subsequence in the array, i.e., the longest subsequence where every element is larger than the previous one. A subsequence is a sequence that can be derived from the array by deleting some elements without changing the order of the remaining elements.",
    tags: "Dynamic Programming",
  },
  {
    id: 1140,
    name: "Projects",
    question:
      "There are n projects you can attend. For each project, you know its starting and ending days and the amount of money you would get as reward. You can only attend one project during a day. What is the maximum amount of money you can earn?",
    tags: "Dynamic Programming",
  },
  {
    id: 1653,
    name: "Elevator Rides",
    question:
      "There are n people who want to get to the top of a building which has only one elevator. You know the weight of each person and the maximum allowed weight in the elevator. What is the minimum number of elevator rides?",
    tags: "Dynamic Programming",
  },
  {
    id: 2181,
    name: "Counting Tilings",
    question:
      "Your task is to count the number of ways you can fill an n × m grid using 1 × 2 and 2 × 1 tiles.",
    tags: "Dynamic Programming",
  },
  {
    id: 2220,
    name: "Counting Numbers",
    question:
      "Your task is to count the number of integers between a and b where no two adjacent digits are the same.",
    tags: "Dynamic Programming",
  },
  {
    id: 1192,
    name: "Counting Rooms",
    question:
      "You are given a map of a building, and your task is to count the number of its rooms. The size of the map is n × m squares, and each square is either floor or wall. You can walk left, right, up, and down through the floor squares.",
    tags: "Graph Algorithms",
  },
  {
    id: 1193,
    name: "Labyrinth",
    question:
      "You are given a map of a labyrinth, and your task is to find a path from start to end. You can walk left, right, up and down.",
    tags: "Graph Algorithms",
  },
  {
    id: 1666,
    name: "Building Roads",
    question:
      "Byteland has n cities, and m roads between them. The goal is to construct new roads so that there is a route between any two cities. Your task is to find out the minimum number of roads required, and also determine which roads should be built.",
    tags: "Graph Algorithms",
  },
  {
    id: 1667,
    name: "Message Route",
    question:
      "Syrjälä’s network has n computers and m connections. Your task is to find out if Uolevi can send a message to Maija, and if it is possible, what is the minimum number of computers on such a route.",
    tags: "Graph Algorithms",
  },
  {
    id: 1668,
    name: "Building Teams",
    question:
      "There are n pupils in Uolevi’s class, and m friendships between them. Your task is to divide the pupils into two teams in such a way that no two pupils in a team are friends. You can freely choose the sizes of the teams.",
    tags: "Graph Algorithms",
  },
  {
    id: 1669,
    name: "Round Trip",
    question:
      "Byteland has n cities and m roads between them. Your task is to design a round trip that begins in a city, goes through two or more other cities, and finally returns to the starting city. Every intermediate city on the route has to be distinct.",
    tags: "Graph Algorithms",
  },
  {
    id: 1194,
    name: "Monsters",
    question:
      "You and some monsters are in a labyrinth. When taking a step to some direction in the labyrinth, each monster may simultaneously take one as well. Your goal is to reach one of the boundary squares without ever sharing a square with a monster. Your task is to find out if your goal is possible, and if it is, print a path that you can follow. Your plan has to work in any situation; even if the monsters know your path beforehand.",
    tags: "Graph Algorithms",
  },
  {
    id: 1671,
    name: "Shortest Routes I",
    question:
      "There are n cities and m flight connections between them. Your task is to determine the length of the shortest route from Syrjälä to every city.",
    tags: "Graph Algorithms",
  },
  {
    id: 1672,
    name: "Shortest Routes II",
    question:
      "There are n cities and m roads between them. Your task is to process q queries where you have to determine the length of the shortest route between two given cities.",
    tags: "Graph Algorithms",
  },
  {
    id: 1673,
    name: "High Score",
    question:
      "You play a game consisting of n rooms and m tunnels. Your initial score is 0, and each tunnel increases your score by x where x may be both positive or negative. You may go through a tunnel several times. Your task is to walk from room 1 to room n. What is the maximum score you can get?",
    tags: "Graph Algorithms",
  },
  {
    id: 1195,
    name: "Flight Discount",
    question:
      "Your task is to find a minimum-price flight route from Syrjälä to Metsälä. You have one discount coupon, using which you can halve the price of any single flight during the route. However, you can only use the coupon once.",
    tags: "Graph Algorithms",
  },
  {
    id: 1197,
    name: "Cycle Finding",
    question:
      "You are given a directed graph, and your task is to find out if it contains a negative cycle, and also give an example of such a cycle.",
    tags: "Graph Algorithms",
  },
  {
    id: 1196,
    name: "Flight Routes",
    question:
      "Your task is to find the k shortest flight routes from Syrjälä to Metsälä. A route can visit the same city several times. Note that there can be several routes with the same price and each of them should be considered (see the example).",
    tags: "Graph Algorithms",
  },
  {
    id: 1678,
    name: "Round Trip II",
    question:
      "Byteland has n cities and m flight connections. Your task is to design a round trip that begins in a city, goes through one or more other cities, and finally returns to the starting city. Every intermediate city on the route has to be distinct.",
    tags: "Graph Algorithms",
  },
  {
    id: 1679,
    name: "Course Schedule",
    question:
      'You have to complete n courses. There are m requirements of the form "course a has to be completed before course b". Your task is to find an order in which you can complete the courses.',
    tags: "Graph Algorithms",
  },
  {
    id: 1680,
    name: "Longest Flight Route",
    question:
      "Uolevi has won a contest, and the prize is a free flight trip that can consist of one or more flights through cities. Of course, Uolevi wants to choose a trip that has as many cities as possible. Uolevi wants to fly from Syrjälä to Lehmälä so that he visits the maximum number of cities. You are given the list of possible flights, and you know that there are no directed cycles in the flight network.",
    tags: "Graph Algorithms",
  },
  {
    id: 1681,
    name: "Game Routes",
    question:
      "A game has n levels, connected by m teleporters, and your task is to get from level 1 to level n. The game has been designed so that there are no directed cycles in the underlying graph. In how many ways can you complete the game?",
    tags: "Graph Algorithms",
  },
  {
    id: 1202,
    name: "Investigation",
    question:
      "You are going to travel from Syrjälä to Lehmälä by plane. You would like to find answers to the following questions:\n\n- what is the minimum price of such a route?\n- how many minimum-price routes are there? (modulo 10⁹ + 7)\n- what is the minimum number of flights in a minimum-price route?\n- what is the maximum number of flights in a minimum-price route?",
    tags: "Graph Algorithms",
  },
  {
    id: 1750,
    name: "Planets Queries I",
    question:
      "You are playing a game consisting of n planets. Each planet has a teleporter to another planet (or the planet itself). Your task is to process q queries of the form: when you begin on planet x and travel through k teleporters, which planet will you reach?",
    tags: "Graph Algorithms",
  },
  {
    id: 1160,
    name: "Planets Queries II",
    question:
      "You are playing a game consisting of n planets. Each planet has a teleporter to another planet (or the planet itself). You have to process q queries of the form: You are now on planet a and want to reach planet b. What is the minimum number of teleportations?",
    tags: "Graph Algorithms",
  },
  {
    id: 1751,
    name: "Planets Cycles",
    question:
      "You are playing a game consisting of n planets. Each planet has a teleporter to another planet (or the planet itself). You start on a planet and then travel through teleporters until you reach a planet that you have already visited before. Your task is to calculate for each planet the number of teleportations there would be if you started on that planet.",
    tags: "Graph Algorithms",
  },
  {
    id: 1675,
    name: "Road Reparation",
    question:
      "There are n cities and m roads between them. Unfortunately, the condition of the roads is so poor that they cannot be used. Your task is to repair some of the roads so that there will be a decent route between any two cities. For each road, you know its reparation cost, and you should find a solution where the total cost is as small as possible.",
    tags: "Graph Algorithms",
  },
  {
    id: 1676,
    name: "Road Construction",
    question:
      "There are n cities and initially no roads between them. However, every day a new road will be constructed, and there will be a total of m roads. A component is a group of cities where there is a route between any two cities using the roads. After each day, your task is to find the number of components and the size of the largest component.",
    tags: "Graph Algorithms",
  },
  {
    id: 1682,
    name: "Flight Routes Check",
    question:
      "There are n cities and m flight connections. Your task is to check if you can travel from any city to any other city using the available flights.",
    tags: "Graph Algorithms",
  },
  {
    id: 1683,
    name: "Planets and Kingdoms",
    question:
      "A game has n planets, connected by m teleporters. Two planets a and b belong to the same kingdom exactly when there is a route both from a to b and from b to a. Your task is to determine for each planet its kingdom.",
    tags: "Graph Algorithms",
  },
  {
    id: 1684,
    name: "Giant Pizza",
    question:
      'Uolevi’s family is going to order a large pizza and eat it together. A total of n family members will join the order, and there are m possible toppings. The pizza may have any number of toppings. Each family member gives two wishes concerning the toppings of the pizza. The wishes are of the form "topping x is good/bad". Your task is to choose the toppings so that at least one wish from everybody becomes true (a good topping is included in the pizza or a bad topping is not included).',
    tags: "Graph Algorithms",
  },
  {
    id: 1686,
    name: "Coin Collector",
    question:
      "A game has n rooms and m tunnels between them. Each room has a certain number of coins. What is the maximum number of coins you can collect while moving through the tunnels when you can freely choose your starting and ending room?",
    tags: "Graph Algorithms",
  },
  {
    id: 1691,
    name: "Mail Delivery",
    question:
      "Your task is to deliver mail to the inhabitants of a city. For this reason, you want to find a route whose starting and ending point are the post office, and that goes through every street exactly once.",
    tags: "Graph Algorithms",
  },
  {
    id: 1692,
    name: "De Bruijn Sequence",
    question:
      "Your task is to construct a minimum-length bit string that contains all possible substrings of length n. For example, when n = 2, the string 00110 is a valid solution, because its substrings of length 2 are 00, 01, 10 and 11.",
    tags: "Graph Algorithms",
  },
  {
    id: 1693,
    name: "Teleporters Path",
    question:
      "A game has n levels and m teleportes between them. You win the game if you move from level 1 to level n using every teleporter exactly once. Can you win the game, and what is a possible way to do it?",
    tags: "Graph Algorithms",
  },
  {
    id: 1690,
    name: "Hamiltonian Flights",
    question:
      "There are n cities and m flight connections between them. You want to travel from Syrjälä to Lehmälä so that you visit each city exactly once. How many possible routes are there?",
    tags: "Graph Algorithms",
  },
  {
    id: 1689,
    name: "Knight's Tour",
    question:
      "Given a starting position of a knight on an 8 × 8 chessboard, your task is to find a sequence of moves such that it visits every square exactly once. On each move, the knight may either move two steps horizontally and one step vertically, or one step horizontally and two steps vertically.",
    tags: "Graph Algorithms",
  },
  {
    id: 1694,
    name: "Download Speed",
    question:
      "Consider a network consisting of n computers and m connections. Each connection specifies how fast a computer can send data to another computer. Kotivalo wants to download some data from a server. What is the maximum speed he can do this, using the connections in the network?",
    tags: "Graph Algorithms",
  },
  {
    id: 1695,
    name: "Police Chase",
    question:
      "Kaaleppi has just robbed a bank and is now heading to the harbor. However, the police wants to stop him by closing some streets of the city. What is the minimum number of streets that should be closed so that there is no route between the bank and the harbor?",
    tags: "Graph Algorithms",
  },
  {
    id: 1696,
    name: "School Dance",
    question:
      "There are n boys and m girls in a school. Next week a school dance will be organized. A dance pair consists of a boy and a girl, and there are k potential pairs. Your task is to find out the maximum number of dance pairs and show how this number can be achieved.",
    tags: "Graph Algorithms",
  },
  {
    id: 1711,
    name: "Distinct Routes",
    question:
      "A game consists of n rooms and m teleporters. At the beginning of each day, you start in room 1 and you have to reach room n. You can use each teleporter at most once during the game. How many days can you play if you choose your routes optimally?",
    tags: "Graph Algorithms",
  },
  {
    id: 1646,
    name: "Static Range Sum Queries",
    question:
      "Given an array of n integers, your task is to process q queries of the form: what is the sum of values in range [a,b]?",
    tags: "Range Queries",
  },
  {
    id: 1647,
    name: "Static Range Minimum Queries",
    question:
      "Given an array of n integers, your task is to process q queries of the form: what is the minimum value in range [a,b]?",
    tags: "Range Queries",
  },
  {
    id: 1648,
    name: "Dynamic Range Sum Queries",
    question:
      "Given an array of n integers, your task is to process q queries of the following types:\n\n1. update the value at position k to u\n2. what is the sum of values in range [a,b]?",
    tags: "Range Queries",
  },
  {
    id: 1649,
    name: "Dynamic Range Minimum Queries",
    question:
      "Given an array of n integers, your task is to process q queries of the following types:\n\n1. update the value at position k to u\n2. what is the minimum value in range [a,b]?",
    tags: "Range Queries",
  },
  {
    id: 1650,
    name: "Range Xor Queries",
    question:
      "Given an array of n integers, your task is to process q queries of the form: what is the xor sum of values in range [a,b]?",
    tags: "Range Queries",
  },
  {
    id: 1651,
    name: "Range Update Queries",
    question:
      "Given an array of n integers, your task is to process q queries of the following types:\n\n1. increase each value in range [a,b] by u\n2. what is the value at position k?",
    tags: "Range Queries",
  },
  {
    id: 1652,
    name: "Forest Queries",
    question:
      "You are given an n × n grid representing the map of a forest. Each square is either empty or contains a tree. The upper-left square has coordinates (1,1), and the lower-right square has coordinates (n,n). Your task is to process q queries of the form: how many trees are inside a given rectangle in the forest?",
    tags: "Range Queries",
  },
  {
    id: 1143,
    name: "Hotel Queries",
    question:
      "There are n hotels on a street. For each hotel you know the number of free rooms. Your task is to assign hotel rooms for groups of tourists. All members of a group want to stay in the same hotel. The groups will come to you one after another, and you know for each group the number of rooms it requires. You always assign a group to the first hotel having enough rooms. After this, the number of free rooms in the hotel decreases.",
    tags: "Range Queries",
  },
  {
    id: 1749,
    name: "List Removals",
    question:
      "You are given a list consisting of n integers. Your task is to remove elements from the list at given positions, and report the removed elements.",
    tags: "Range Queries",
  },
  {
    id: 1144,
    name: "Salary Queries",
    question:
      "A company has n employees with certain salaries. Your task is to keep track of the salaries and process queries.",
    tags: "Range Queries",
  },
  {
    id: 2166,
    name: "Prefix Sum Queries",
    question:
      "Given an array of n integers, your task is to process q queries of the following types:\n\n1. update the value at position k to u\n2. what is the maximum prefix sum in range [a,b]?",
    tags: "Range Queries",
  },
  {
    id: 2206,
    name: "Pizzeria Queries",
    question:
      "There are n buildings on a street, numbered 1, 2, …, n. Each building has a pizzeria and an apartment. The pizza price in building k is p_(k). If you order a pizza from building a to building b, its price (with delivery) is p_(a) + |a−b|. Your task is to process two types of queries:\n\n1. The pizza price p_(k) in building k becomes x.\n2. You are in building k and want to order a pizza. What is the minimum price?",
    tags: "Range Queries",
  },
  {
    id: 1190,
    name: "Subarray Sum Queries",
    question:
      "There is an array consisting of n integers. Some values of the array will be updated, and after each update, your task is to report the maximum subarray sum in the array.",
    tags: "Range Queries",
  },
  {
    id: 1734,
    name: "Distinct Values Queries",
    question:
      "You are given an array of n integers and q queries of the form: how many distinct values are there in a range [a,b]?",
    tags: "Range Queries",
  },
  {
    id: 2416,
    name: "Increasing Array Queries",
    question:
      "You are given an array that consists of n integers. The array elements are indexed 1, 2, …, n. You can modify the array using the following operation: choose an array element and increase its value by one. Your task is to process q queries of the form: when we consider a subarray from position a to position b, what is the minimum number of operations after which the subarray is increasing? An array is increasing if each element is greater than or equal with the previous element.",
    tags: "Range Queries",
  },
  {
    id: 1739,
    name: "Forest Queries II",
    question:
      "You are given an n × n grid representing the map of a forest. Each square is either empty or has a tree. Your task is to process q queries of the following types:\n\n1. Change the state (empty/tree) of a square.\n2. How many trees are inside a rectangle in the forest?",
    tags: "Range Queries",
  },
  {
    id: 1735,
    name: "Range Updates and Sums",
    question:
      "Your task is to maintain an array of n values and efficiently process the following types of queries:\n\n1. Increase each value in range [a,b] by x.\n2. Set each value in range [a,b] to x.\n3. Calculate the sum of values in range [a,b].",
    tags: "Range Queries",
  },
  {
    id: 1736,
    name: "Polynomial Queries",
    question:
      "Your task is to maintain an array of n values and efficiently process the following types of queries:\n\n1. Increase the first value in range [a,b] by 1, the second value by 2, the third value by 3, and so on.\n2. Calculate the sum of values in range [a,b].",
    tags: "Range Queries",
  },
  {
    id: 1737,
    name: "Range Queries and Copies",
    question:
      "Your task is to maintain a list of arrays which initially has a single array. You have to process the following types of queries:\n\n1. Set the value a in array k to x.\n2. Calculate the sum of values in range [a,b] in array k.\n3. Create a copy of array k and add it to the end of the list.",
    tags: "Range Queries",
  },
  {
    id: 1674,
    name: "Subordinates",
    question:
      "Given the structure of a company, your task is to calculate for each employee the number of their subordinates.",
    tags: "Tree Algorithms",
  },
  {
    id: 1130,
    name: "Tree Matching",
    question:
      "You are given a tree consisting of n nodes. A matching is a set of edges where each node is an endpoint of at most one edge. What is the maximum number of edges in a matching?",
    tags: "Tree Algorithms",
  },
  {
    id: 1131,
    name: "Tree Diameter",
    question:
      "You are given a tree consisting of n nodes. The diameter of a tree is the maximum distance between two nodes. Your task is to determine the diameter of the tree.",
    tags: "Tree Algorithms",
  },
  {
    id: 1132,
    name: "Tree Distances I",
    question:
      "You are given a tree consisting of n nodes. Your task is to determine for each node the maximum distance to another node.",
    tags: "Tree Algorithms",
  },
  {
    id: 1133,
    name: "Tree Distances II",
    question:
      "You are given a tree consisting of n nodes. Your task is to determine for each node the sum of the distances from the node to all other nodes.",
    tags: "Tree Algorithms",
  },
  {
    id: 1687,
    name: "Company Queries I",
    question:
      "A company has n employees, who form a tree hierarchy where each employee has a boss, except for the general director. Your task is to process q queries of the form: who is employee x’s boss k levels higher up in the hierarchy?",
    tags: "Tree Algorithms",
  },
  {
    id: 1688,
    name: "Company Queries II",
    question:
      "A company has n employees, who form a tree hierarchy where each employee has a boss, except for the general director. Your task is to process q queries of the form: who is the lowest common boss of employees a and b in the hierarchy?",
    tags: "Tree Algorithms",
  },
  {
    id: 1135,
    name: "Distance Queries",
    question:
      "You are given a tree consisting of n nodes. Your task is to process q queries of the form: what is the distance between nodes a and b?",
    tags: "Tree Algorithms",
  },
  {
    id: 1136,
    name: "Counting Paths",
    question:
      "You are given a tree consisting of n nodes, and m paths in the tree. Your task is to calculate for each node the number of paths containing that node.",
    tags: "Tree Algorithms",
  },
  {
    id: 1137,
    name: "Subtree Queries",
    question:
      "You are given a rooted tree consisting of n nodes. The nodes are numbered 1, 2, …, n, and node 1 is the root. Each node has a value. Your task is to process following types of queries:\n\n1. change the value of node s to x\n2. calculate the sum of values in the subtree of node s",
    tags: "Tree Algorithms",
  },
  {
    id: 1138,
    name: "Path Queries",
    question:
      "You are given a rooted tree consisting of n nodes. The nodes are numbered 1, 2, …, n, and node 1 is the root. Each node has a value. Your task is to process following types of queries:\n\n1. change the value of node s to x\n2. calculate the sum of values on the path from the root to node s",
    tags: "Tree Algorithms",
  },
  {
    id: 2134,
    name: "Path Queries II",
    question:
      "You are given a tree consisting of n nodes. The nodes are numbered 1, 2, …, n. Each node has a value. Your task is to process following types of queries:\n\n1. change the value of node s to x\n2. find the maximum value on the path between nodes a and b.",
    tags: "Tree Algorithms",
  },
  {
    id: 1139,
    name: "Distinct Colors",
    question:
      "You are given a rooted tree consisting of n nodes. The nodes are numbered 1, 2, …, n, and node 1 is the root. Each node has a color. Your task is to determine for each node the number of distinct colors in the subtree of the node.",
    tags: "Tree Algorithms",
  },
  {
    id: 2079,
    name: "Finding a Centroid",
    question:
      "Given a tree of n nodes, your task is to find a centroid, i.e., a node such that when it is appointed the root of the tree, each subtree has at most ⌊n/2⌋ nodes.",
    tags: "Tree Algorithms",
  },
  {
    id: 2080,
    name: "Fixed-Length Paths I",
    question:
      "Given a tree of n nodes, your task is to count the number of distinct paths that consist of exactly k edges.",
    tags: "Tree Algorithms",
  },
  {
    id: 2081,
    name: "Fixed-Length Paths II",
    question:
      "Given a tree of n nodes, your task is to count the number of distinct paths that have at least k₁ and at most k₂ edges.",
    tags: "Tree Algorithms",
  },
  {
    id: 2164,
    name: "Josephus Queries",
    question:
      'Consider a game where there are n children (numbered 1, 2, …, n) in a circle. During the game, every second child is removed from the circle, until there are no children left. Your task is to process q queries of the form: "when there are n children, who is the kth child that will be removed?"',
    tags: "Mathematics",
  },
  {
    id: 1095,
    name: "Exponentiation",
    question:
      "Your task is to efficiently calculate values a^(b) modulo 10⁹ + 7.",
    tags: "Mathematics",
  },
  {
    id: 1712,
    name: "Exponentiation II",
    question:
      "Your task is to efficiently calculate values a^(b^(c)) modulo 10⁹ + 7.",
    tags: "Mathematics",
  },
  {
    id: 1713,
    name: "Counting Divisors",
    question:
      "Given n integers, your task is to report for each integer the number of its divisors. For example, if x = 18, the correct answer is 6 because its divisors are 1, 2, 3, 6, 9, 18.",
    tags: "Mathematics",
  },
  {
    id: 1081,
    name: "Common Divisors",
    question:
      "You are given an array of n positive integers. Your task is to find two integers such that their greatest common divisor is as large as possible.",
    tags: "Mathematics",
  },
  {
    id: 1082,
    name: "Sum of Divisors",
    question:
      "Let σ(n) denote the sum of divisors of an integer n. For example, σ(12) = 1 + 2 + 3 + 4 + 6 + 12 = 28. Your task is to calculate the sum $\\sum_{i=1}^n \\sigma(i)$ modulo 10⁹ + 7.",
    tags: "Mathematics",
  },
  {
    id: 2182,
    name: "Divisor Analysis",
    question:
      "Given an integer, your task is to find the number, sum and product of its divisors. As an example, let us consider the number 12:\n\n- the number of divisors is 6 (they are 1, 2, 3, 4, 6, 12)\n- the sum of divisors is 1 + 2 + 3 + 4 + 6 + 12 = 28\n- the product of divisors is 1 ⋅ 2 ⋅ 3 ⋅ 4 ⋅ 6 ⋅ 12 = 1728\n\nSince the input number may be large, it is given as a prime factorization.",
    tags: "Mathematics",
  },
  {
    id: 2185,
    name: "Prime Multiples",
    question:
      "You are given k distinct prime numbers a₁, a₂, …, a_(k) and an integer n. Your task is to calculate how many of the first n positive integers are divisible by at least one of the given prime numbers.",
    tags: "Mathematics",
  },
  {
    id: 2417,
    name: "Counting Coprime Pairs",
    question:
      "Given a list of n positive integers, your task is to count the number of pairs of integers that are coprime (i.e., their greatest common divisor is one).",
    tags: "Mathematics",
  },
  {
    id: 1079,
    name: "Binomial Coefficients",
    question:
      "Your task is to calculate n binomial coefficients modulo 10⁹ + 7. A binomial coefficient ${a \\choose b}$ can be calculated using the formula $\\frac{a!}{b!(a-b)!}$. We assume that a and b are integers and 0 ≤ b ≤ a.",
    tags: "Mathematics",
  },
  {
    id: 1715,
    name: "Creating Strings II",
    question:
      "Given a string, your task is to calculate the number of different strings that can be created using its characters.",
    tags: "Mathematics",
  },
  {
    id: 1716,
    name: "Distributing Apples",
    question:
      "There are n children and m apples that will be distributed to them. Your task is to count the number of ways this can be done. For example, if n = 3 and m = 2, there are 6 ways: [0,0,2], [0,1,1], [0,2,0], [1,0,1], [1,1,0] and [2,0,0].",
    tags: "Mathematics",
  },
  {
    id: 1717,
    name: "Christmas Party",
    question:
      "There are n children at a Christmas party, and each of them has brought a gift. The idea is that everybody will get a gift brought by someone else. In how many ways can the gifts be distributed?",
    tags: "Mathematics",
  },
  {
    id: 2064,
    name: "Bracket Sequences I",
    question:
      "Your task is to calculate the number of valid bracket sequences of length n. For example, when n = 6, there are 5 sequences:\n\n-\n()()()\n-\n()(())\n-\n(())()\n-\n((()))\n-\n(()())",
    tags: "Mathematics",
  },
  {
    id: 2187,
    name: "Bracket Sequences II",
    question:
      "Your task is to calculate the number of valid bracket sequences of length n when a prefix of the sequence is given.",
    tags: "Mathematics",
  },
  {
    id: 2209,
    name: "Counting Necklaces",
    question:
      "Your task is to count the number of different necklaces that consist of n pearls and each pearl has m possible colors. Two necklaces are considered to be different if it is not possible to rotate one of them so that they look the same.",
    tags: "Mathematics",
  },
  {
    id: 2210,
    name: "Counting Grids",
    question:
      "Your task is to count the number of different n × n grids whose each square is black or white. Two grids are considered to be different if it is not possible to rotate one of them so that they look the same.",
    tags: "Mathematics",
  },
  {
    id: 1722,
    name: "Fibonacci Numbers",
    question:
      "The Fibonacci numbers can be defined as follows:\n\n- F₀ = 0\n- F₁ = 1\n- F_(n) = F_(n − 2) + F_(n − 1)\n\nYour task is to calculate the value of F_(n) for a given n.",
    tags: "Mathematics",
  },
  {
    id: 1096,
    name: "Throwing Dice",
    question:
      "Your task is to calculate the number of ways to get a sum n by throwing dice. Each throw yields an integer between 1…6. For example, if n = 10, some possible ways are 3 + 3 + 4, 1 + 4 + 1 + 4 and 1 + 1 + 6 + 1 + 1.",
    tags: "Mathematics",
  },
  {
    id: 1723,
    name: "Graph Paths I",
    question:
      "Consider a directed graph that has n nodes and m edges. Your task is to count the number of paths from node 1 to node n with exactly k edges.",
    tags: "Mathematics",
  },
  {
    id: 1724,
    name: "Graph Paths II",
    question:
      "Consider a directed weighted graph having n nodes and m edges. Your task is to calculate the minimum path length from node 1 to node n with exactly k edges.",
    tags: "Mathematics",
  },
  {
    id: 1725,
    name: "Dice Probability",
    question:
      "You throw a dice n times, and every throw produces an outcome between 1 and 6. What is the probability that the sum of outcomes is between a and b?",
    tags: "Mathematics",
  },
  {
    id: 1726,
    name: "Moving Robots",
    question:
      "Each square of an 8 × 8 chessboard has a robot. Each robot independently moves k steps, and there can be many robots on the same square. On each turn, a robot moves one step left, right, up or down, but not outside the board. It randomly chooses a direction among those where it can move. Your task is to calculate the expected number of empty squares after k turns.",
    tags: "Mathematics",
  },
  {
    id: 1727,
    name: "Candy Lottery",
    question:
      "There are n children, and each of them independently gets a random integer number of candies between 1 and k. What is the expected maximum number of candies a child gets?",
    tags: "Mathematics",
  },
  {
    id: 1728,
    name: "Inversion Probability",
    question:
      "An array has n integers x₁, x₂, …, x_(n), and each of them has been randomly chosen between 1 and r_(i). An inversion is a pair (a,b) where a < b and x_(a) > x_(b). What is the expected number of inversions in the array?",
    tags: "Mathematics",
  },
  {
    id: 1729,
    name: "Stick Game",
    question:
      "Consider a game where two players remove sticks from a heap. The players move alternately, and the player who removes the last stick wins the game. A set P = {p₁, p₂, …, p_(k)} determines the allowed moves. For example, if P = {1, 3, 4}, a player may remove 1, 3 or 4 sticks. Your task is find out for each number of sticks 1, 2, …, n if the first player has a winning or losing position.",
    tags: "Mathematics",
  },
  {
    id: 1730,
    name: "Nim Game I",
    question:
      "There are n heaps of sticks and two players who move alternately. On each move, a player chooses a non-empty heap and removes any number of sticks. The player who removes the last stick wins the game. Your task is to find out who wins if both players play optimally.",
    tags: "Mathematics",
  },
  {
    id: 1098,
    name: "Nim Game II",
    question:
      "There are n heaps of sticks and two players who move alternately. On each move, a player chooses a non-empty heap and removes 1, 2, or 3 sticks. The player who removes the last stick wins the game. Your task is to find out who wins if both players play optimally.",
    tags: "Mathematics",
  },
  {
    id: 1099,
    name: "Stair Game",
    question:
      "There is a staircase consisting of n stairs, numbered 1, 2, …, n. Initially, each stair has some number of balls. There are two players who move alternately. On each move, a player chooses a stair k where k ≠ 1 and it has at least one ball. Then, the player moves any number of balls from stair k to stair k − 1. The player who moves last wins the game. Your task is to find out who wins the game when both players play optimally. Note that if there are no possible moves at all, the second player wins.",
    tags: "Mathematics",
  },
  {
    id: 2207,
    name: "Grundy's Game",
    question:
      "There is a heap of n coins and two players who move alternately. On each move, a player chooses a heap and divides into two nonempty heaps that have a different number of coins. The player who makes the last move wins the game. Your task is to find out who wins if both players play optimally.",
    tags: "Mathematics",
  },
  {
    id: 2208,
    name: "Another Game",
    question:
      "There are n heaps of coins and two players who move alternately. On each move, a player selects some of the nonempty heaps and removes one coin from each heap. The player who removes the last coin wins the game. Your task is to find out who wins if both players play optimally.",
    tags: "Mathematics",
  },
  {
    id: 1731,
    name: "Word Combinations",
    question:
      "You are given a string of length n and a dictionary containing k words. In how many ways can you create the string using the words?",
    tags: "String Algorithms",
  },
  {
    id: 1753,
    name: "String Matching",
    question:
      "Given a string and a pattern, your task is to count the number of positions where the pattern occurs in the string.",
    tags: "String Algorithms",
  },
  {
    id: 1732,
    name: "Finding Borders",
    question:
      "A border of a string is a prefix that is also a suffix of the string but not the whole string. For example, the borders of\nabcababcab\nare\nab\nand\nabcab\n. Your task is to find all border lengths of a given string.",
    tags: "String Algorithms",
  },
  {
    id: 1733,
    name: "Finding Periods",
    question:
      "A period of a string is a prefix that can be used to generate the whole string by repeating the prefix. The last repetition may be partial. For example, the periods of\nabcabca\nare\nabc\n,\nabcabc\nand\nabcabca\n. Your task is to find all period lengths of a string.",
    tags: "String Algorithms",
  },
  {
    id: 1110,
    name: "Minimal Rotation",
    question:
      "A rotation of a string can be generated by moving characters one after another from beginning to end. For example, the rotations of\nacab\nare\nacab\n,\ncaba\n,\nabac\n, and\nbaca\n. Your task is to determine the lexicographically minimal rotation of a string.",
    tags: "String Algorithms",
  },
  {
    id: 1111,
    name: "Longest Palindrome",
    question:
      "Given a string, your task is to determine the longest palindromic substring of the string. For example, the longest palindrome in\naybabtu\nis\nbab\n.",
    tags: "String Algorithms",
  },
  {
    id: 1112,
    name: "Required Substring",
    question:
      "Your task is to calculate the number of strings of length n having a given pattern of length m as their substring. All strings consist of characters A–Z.",
    tags: "String Algorithms",
  },
  {
    id: 2420,
    name: "Palindrome Queries",
    question:
      "You are given a string that consists of n characters between a–z. The positions of the string are indexed 1, 2, …, n. Your task is to process m operations of the following types:\n\n1. Change the character at position k to x\n2. Check if the substring from position a to position b is a palindrome",
    tags: "String Algorithms",
  },
  {
    id: 2102,
    name: "Finding Patterns",
    question:
      "Given a string and patterns, check for each pattern if it appears in the string.",
    tags: "String Algorithms",
  },
  {
    id: 2103,
    name: "Counting Patterns",
    question:
      "Given a string and patterns, count for each pattern the number of positions where it appears in the string.",
    tags: "String Algorithms",
  },
  {
    id: 2104,
    name: "Pattern Positions",
    question:
      "Given a string and patterns, find for each pattern the first position (1-indexed) where it appears in the string.",
    tags: "String Algorithms",
  },
  {
    id: 2105,
    name: "Distinct Substrings",
    question:
      "Count the number of distinct substrings that appear in a string.",
    tags: "String Algorithms",
  },
  {
    id: 2106,
    name: "Repeating Substring",
    question:
      "A repeating substring is a substring that occurs in two (or more) locations in the string. Your task is to find the longest repeating substring in a given string.",
    tags: "String Algorithms",
  },
  {
    id: 2107,
    name: "String Functions",
    question:
      "We consider a string of n characters, indexed 1, 2, …, n. Your task is to calculate all values of the following functions:\n\n- z(i) denotes the maximum length of a substring that begins at position i and is a prefix of the string. In addition, z(1) = 0.\n- π(i) denotes the maximum length of a substring that ends at position i, is a prefix of the string, and whose length is at most i − 1.\n\nNote that the function z is used in the Z-algorithm, and the function π is used in the KMP algorithm.",
    tags: "String Algorithms",
  },
  {
    id: 2108,
    name: "Substring Order I",
    question:
      "You are given a string of length n. If all of its distinct substrings are ordered lexicographically, what is the kth smallest of them?",
    tags: "String Algorithms",
  },
  {
    id: 2109,
    name: "Substring Order II",
    question:
      "You are given a string of length n. If all of its substrings (not necessarily distinct) are ordered lexicographically, what is the kth smallest of them?",
    tags: "String Algorithms",
  },
  {
    id: 2110,
    name: "Substring Distribution",
    question:
      "You are given a string of length n. For every integer between 1…n you need to print the number of distinct substrings of that length.",
    tags: "String Algorithms",
  },
  {
    id: 2189,
    name: "Point Location Test",
    question:
      "There is a line that goes through the points p₁ = (x₁,y₁) and p₂ = (x₂,y₂). There is also a point p₃ = (x₃,y₃). Your task is to determine whether p₃ is located on the left or right side of the line or if it touches the line when we are looking from p₁ to p₂.",
    tags: "Geometry",
  },
  {
    id: 2190,
    name: "Line Segment Intersection",
    question:
      "There are two line segments: the first goes through the points (x₁,y₁) and (x₂,y₂), and the second goes through the points (x₃,y₃) and (x₄,y₄). Your task is to determine if the line segments intersect, i.e., they have at least one common point.",
    tags: "Geometry",
  },
  {
    id: 2191,
    name: "Polygon Area",
    question:
      "Your task is to calculate the area of a given polygon. The polygon consists of n vertices (x₁,y₁), (x₂,y₂), …, (x_(n),y_(n)). The vertices (x_(i),y_(i)) and (x_(i + 1),y_(i + 1)) are adjacent for i = 1, 2, …, n − 1, and the vertices (x₁,y₁) and (x_(n),y_(n)) are also adjacent.",
    tags: "Geometry",
  },
  {
    id: 2192,
    name: "Point in Polygon",
    question:
      "You are given a polygon of n vertices and a list of m points. Your task is to determine for each point if it is inside, outside or on the boundary of the polygon. The polygon consists of n vertices (x₁,y₁), (x₂,y₂), …, (x_(n),y_(n)). The vertices (x_(i),y_(i)) and (x_(i + 1),y_(i + 1)) are adjacent for i = 1, 2, …, n − 1, and the vertices (x₁,y₁) and (x_(n),y_(n)) are also adjacent.",
    tags: "Geometry",
  },
  {
    id: 2193,
    name: "Polygon Lattice Points",
    question:
      "Given a polygon, your task is to calculate the number of lattice points inside the polygon and on its boundary. A lattice point is a point whose coordinates are integers. The polygon consists of n vertices (x₁,y₁), (x₂,y₂), …, (x_(n),y_(n)). The vertices (x_(i),y_(i)) and (x_(i + 1),y_(i + 1)) are adjacent for i = 1, 2, …, n − 1, and the vertices (x₁,y₁) and (x_(n),y_(n)) are also adjacent.",
    tags: "Geometry",
  },
  {
    id: 2194,
    name: "Minimum Euclidean Distance",
    question:
      "Given a set of points in the two-dimensional plane, your task is to find the minimum Euclidean distance between two distinct points. The Euclidean distance of points (x₁,y₁) and (x₂,y₂) is $\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$.",
    tags: "Geometry",
  },
  {
    id: 2195,
    name: "Convex Hull",
    question:
      "Given a set of n points in the two-dimensional plane, your task is to determine the convex hull of the points.",
    tags: "Geometry",
  },
  {
    id: 1628,
    name: "Meet in the Middle",
    question:
      "You are given an array of n numbers. In how many ways can you choose a subset of the numbers with sum x?",
    tags: "Advanced Techniques",
  },
  {
    id: 2136,
    name: "Hamming Distance",
    question:
      "The Hamming distance between two strings a and b of equal length is the number of positions where the strings differ. You are given n bit strings, each of length k and your task is to calculate the minimum Hamming distance between two strings.",
    tags: "Advanced Techniques",
  },
  {
    id: 2137,
    name: "Beautiful Subgrids",
    question:
      "You are given an n × n grid whose each square is either black or white. A subgrid is called beautiful if its height and width is at least two and all of its corners are black. How many beautiful subgrids are there within the given grid?",
    tags: "Advanced Techniques",
  },
  {
    id: 2138,
    name: "Reachable Nodes",
    question:
      "A directed acyclic graph consists of n nodes and m edges. The nodes are numbered 1, 2, …, n. Calculate for each node the number of nodes you can reach from that node (including the node itself).",
    tags: "Advanced Techniques",
  },
  {
    id: 2143,
    name: "Reachability Queries",
    question:
      'A directed graph consists of n nodes and m edges. The edges are numbered 1, 2, …, n. Your task is to answer q queries of the form "can you reach node b from node a?"',
    tags: "Advanced Techniques",
  },
  {
    id: 2072,
    name: "Cut and Paste",
    question:
      "Given a string, your task is to process operations where you cut a substring and paste it to the end of the string. What is the final string after all the operations?",
    tags: "Advanced Techniques",
  },
  {
    id: 2073,
    name: "Substring Reversals",
    question:
      "Given a string, your task is to process operations where you reverse a substring of the string. What is the final string after all the operations?",
    tags: "Advanced Techniques",
  },
  {
    id: 2074,
    name: "Reversals and Sums",
    question:
      "Given an array of n integers, you have to process following operations:\n\n1. reverse a subarray\n2. calculate the sum of values in a subarray",
    tags: "Advanced Techniques",
  },
  {
    id: 2076,
    name: "Necessary Roads",
    question:
      "There are n cities and m roads between them. There is a route between any two cities. A road is called necessary if there is no route between some two cities after removing that road. Your task is to find all necessary roads.",
    tags: "Advanced Techniques",
  },
  {
    id: 2077,
    name: "Necessary Cities",
    question:
      "There are n cities and m roads between them. There is a route between any two cities. A city is called necessary if there is no route between some other two cities after removing that city (and adjacent roads). Your task is to find all necessary cities.",
    tags: "Advanced Techniques",
  },
  {
    id: 2078,
    name: "Eulerian Subgraphs",
    question:
      "You are given an undirected graph that has n nodes and m edges. We consider subgraphs that have all nodes of the original graph and some of its edges. A subgraph is called Eulerian if each node has even degree. Your task is to count the number of Eulerian subgraphs modulo 10⁹ + 7.",
    tags: "Advanced Techniques",
  },
  {
    id: 2084,
    name: "Monster Game I",
    question:
      "You are playing a game that consists of n levels. Each level has a monster. On levels 1, 2, …, n − 1, you can either kill or escape the monster. However, on level n you must kill the final monster to win the game. Killing a monster takes sf time where s is the monster’s strength and f is your skill factor (lower skill factor is better). After killing a monster, you get a new skill factor. What is the minimum total time in which you can win the game?",
    tags: "Advanced Techniques",
  },
  {
    id: 2085,
    name: "Monster Game II",
    question:
      "You are playing a game that consists of n levels. Each level has a monster. On levels 1, 2, …, n − 1, you can either kill or escape the monster. However, on level n you must kill the final monster to win the game. Killing a monster takes sf time where s is the monster’s strength and f is your skill factor. After killing a monster, you get a new skill factor (lower skill factor is better). What is the minimum total time in which you can win the game?",
    tags: "Advanced Techniques",
  },
  {
    id: 2086,
    name: "Subarray Squares",
    question:
      "Given an array of n elements, your task is to divide into k subarrays. The cost of each subarray is the square of the sum of the values in the subarray. What is the minimum total cost if you act optimally?",
    tags: "Advanced Techniques",
  },
  {
    id: 2087,
    name: "Houses and Schools",
    question:
      "There are n houses on a street, numbered 1, 2, …, n. The distance of houses a and b is |a−b|. You know the number of children in each house. Your task is to establish k schools in such a way that each school is in some house. Then, each child goes to the nearest school. What is the minimum total walking distance of the children if you act optimally?",
    tags: "Advanced Techniques",
  },
  {
    id: 2088,
    name: "Knuth Division",
    question:
      "Given an array of n numbers, your task is to divide it into n subarrays, each of which has a single element. On each move, you may choose any subarray and split it into two subarrays. The cost of such a move is the sum of values in the chosen subarray. What is the minimum total cost if you act optimally?",
    tags: "Advanced Techniques",
  },
  {
    id: 2111,
    name: "Apples and Bananas",
    question:
      "There are apples and bananas and each of them has an integer weight between 1…k. Your task is to calculate for each weight w between 2...2k the number of ways we can choose an apple and a banana whose combined weight is w.",
    tags: "Advanced Techniques",
  },
  {
    id: 2112,
    name: "One Bit Positions",
    question:
      "You are given a binary string of length n and your task is to calculate for every k between 1…n − 1 the number of ways we can choose two positions i and j such that i − j = k and there is a one-bit at both positions.",
    tags: "Advanced Techniques",
  },
  {
    id: 2113,
    name: "Signal Processing",
    question:
      "You are given two integer sequences: a signal and a mask. Your task is to process the signal by moving the mask through the signal from left to right. At each mask position calculate the sum of products of aligned signal and mask values in the part where the signal and the mask overlap.",
    tags: "Advanced Techniques",
  },
  {
    id: 2101,
    name: "New Roads Queries",
    question:
      'There are n cities in Byteland but no roads between them. However, each day, a new road will be built. There will be a total of m roads. Your task is to process q queries of the form: "after how many days can we travel from city a to city b for the first time?"',
    tags: "Advanced Techniques",
  },
  {
    id: 2133,
    name: "Dynamic Connectivity",
    question:
      "Consider an undirected graph that consists of n nodes and m edges. There are two types of events that can happen:\n\n1. A new edge is created between nodes a and b.\n2. An existing edge between nodes a and b is removed.\n\nYour task is to report the number of components after every event.",
    tags: "Advanced Techniques",
  },
  {
    id: 2121,
    name: "Parcel Delivery",
    question:
      "There are n cities and m routes through which parcels can be carried from one city to another city. For each route, you know the maximum number of parcels and the cost of a single parcel. You want to send k parcels from Syrjälä to Lehmälä. What is the cheapest way to do that?",
    tags: "Advanced Techniques",
  },
  {
    id: 2129,
    name: "Task Assignment",
    question:
      "A company has n employees and there are n tasks that need to be done. We know for each employee the cost of carrying out each task. Every employee should be assigned to exactly one task. What is the minimum total cost if we assign the tasks optimally and how could they be assigned?",
    tags: "Advanced Techniques",
  },
  {
    id: 2130,
    name: "Distinct Routes II",
    question:
      "A game consists of n rooms and m teleporters. At the beginning of each day, you start in room 1 and you have to reach room n. You can use each teleporter at most once during the game. You want to play the game for exactly k days. Every time you use any teleporter you have to pay one coin. What is the minimum number of coins you have to pay during k days if you play optimally?",
    tags: "Advanced Techniques",
  },
  {
    id: 1087,
    name: "Shortest Subsequence",
    question:
      "You are given a DNA sequence consisting of characters A, C, G, and T. Your task is to find the shortest DNA sequence that is not a subsequence of the original sequence.",
    tags: "Additional Problems",
  },
  {
    id: 1146,
    name: "Counting Bits",
    question:
      "Your task is to count the number of one bits in the binary representations of integers between 1 and n.",
    tags: "Additional Problems",
  },
  {
    id: 1670,
    name: "Swap Game",
    question:
      "You are given a 3 × 3 grid containing the numbers 1, 2, …, 9. Your task is to perform a sequence of moves so that the grid will look like this:\n1 2 3\n4 5 6\n7 8 9\nOn each move, you can swap the numbers in any two adjacent squares (horizontally or vertically). What is the minimum number of moves required?",
    tags: "Additional Problems",
  },
  {
    id: 1134,
    name: "Prüfer Code",
    question:
      "A Prüfer code of a tree of n nodes is a sequence of n − 2 integers that uniquely specifies the structure of the tree. The code is constructed as follows: As long as there are at least three nodes left, find a leaf with the smallest label, add the label of its only neighbor to the code, and remove the leaf from the tree. Given a Prüfer code of a tree, your task is to construct the original tree.",
    tags: "Additional Problems",
  },
  {
    id: 1756,
    name: "Acyclic Graph Edges",
    question:
      "Given an undirected graph, your task is to choose a direction for each edge so that the resulting directed graph is acyclic.",
    tags: "Additional Problems",
  },
  {
    id: 2177,
    name: "Strongly Connected Edges",
    question:
      "Given an undirected graph, your task is to choose a direction for each edge so that the resulting directed graph is strongly connected.",
    tags: "Additional Problems",
  },
  {
    id: 2179,
    name: "Even Outdegree Edges",
    question:
      "Given an undirected graph, your task is to choose a direction for each edge so that in the resulting directed graph each node has an even outdegree. The outdegree of a node is the number of edges coming out of that node.",
    tags: "Additional Problems",
  },
  {
    id: 2422,
    name: "Multiplication Table",
    question:
      "Find the middle element when the numbers in an n × n multiplication table are sorted in increasing order. It is assumed that n is odd. For example, the 3 × 3 multiplication table is as follows:\n$$\\begin{matrix} 1 & 2 & 3 \\\\ 2 & 4 & 6 \\\\ 3 & 6 & 9 \\\\ \\end{matrix}$$\nThe numbers in increasing order are [1,2,2,3,3,4,6,6,9], so the answer is 3.",
    tags: "Additional Problems",
  },
  {
    id: 1142,
    name: "Advertisement",
    question:
      "A fence consists of n vertical boards. The width of each board is 1 and their heights may vary. You want to attach a rectangular advertisement to the fence. What is the maximum area of such an advertisement?",
    tags: "Additional Problems",
  },
  {
    id: 2186,
    name: "Special Substrings",
    question:
      "A substring is called special if every character that appears in the string appears the same number of times in the substring. Your task is to count the number of special substrings in a given string.",
    tags: "Additional Problems",
  },
  {
    id: 2229,
    name: "Permutation Inversions",
    question:
      "Your task is to count the number of permutations of 1, 2, …, n that have exactly k inversions (i.e., pairs of elements in the wrong order). For example, when n = 4 and k = 3, there are 6 such permutations:\n\n- [1,4,3,2]\n- [2,3,4,1]\n- [2,4,1,3]\n- [3,1,4,2]\n- [3,2,1,4]\n- [4,1,2,3]",
    tags: "Additional Problems",
  },
  {
    id: 1655,
    name: "Maximum Xor Subarray",
    question:
      "Given an array of n integers, your task is to find the maximum xor sum in a subarray.",
    tags: "Additional Problems",
  },
  {
    id: 1664,
    name: "Movie Festival Queries",
    question:
      "In a movie festival, n movies will be shown. You know the starting and ending time of each movie. Your task is to process q queries of the form: if you arrive and leave the festival at specific times, what is the maximum number of movies you can watch? You can watch two movies if the first movie ends before or exactly when the second movie starts. You can start the first movie exactly when you arrive and leave exactly when the last movie ends.",
    tags: "Additional Problems",
  },
  {
    id: 1697,
    name: "Chess Tournament",
    question:
      "There will be a chess tournament of n players. Each player has announced the number of games they want to play. Each pair of players can play at most one game. Your task is to determine which games will be played so that everybody will be happy.",
    tags: "Additional Problems",
  },
  {
    id: 1702,
    name: "Tree Traversals",
    question:
      "There are three common ways to traverse the nodes of a binary tree:\n\n- Preorder: First process the root, then the left subtree, and finally the right subtree.\n- Inorder: First process the left subtree, then the root, and finally the right subtree.\n- Postorder: First process the left subtree, then the right subtree, and finally the root.\n\nThere is a binary tree of n nodes with distinct labels. You are given the preorder and inorder traversals of the tree, and your task is to determine its postorder traversal.",
    tags: "Additional Problems",
  },
  {
    id: 1704,
    name: "Network Renovation",
    question:
      "Syrjälä’s network consists of n computers and n − 1 connections between them. It is possible to send data between any two computers. However, if any connection breaks down, it will no longer be possible to send data between some computers. Your task is to add the minimum number of new connections in such a way that you can still send data between any two computers even if any single connection breaks down.",
    tags: "Additional Problems",
  },
  {
    id: 1707,
    name: "Graph Girth",
    question:
      "Given an undirected graph, your task is to determine its girth, i.e., the length of its shortest cycle.",
    tags: "Additional Problems",
  },
  {
    id: 1740,
    name: "Intersection Points",
    question:
      "Given n horizontal and vertical line segments, your task is to calculate the number of their intersection points. You can assume that no parallel line segments intersect, and no endpoint of a line segment is an intersection point.",
    tags: "Additional Problems",
  },
  {
    id: 2214,
    name: "Inverse Inversions",
    question:
      "Your task is to create a permutation of numbers 1, 2, …, n that has exactly k inversions. An inversion is a pair (a,b) where a < b and p_(a) > p_(b) where p_(i) denotes the number at position i in the permutation.",
    tags: "Additional Problems",
  },
  {
    id: 2215,
    name: "Monotone Subsequences",
    question:
      "Your task is to create a permutation of numbers 1, 2, …, n whose longest monotone subsequence has exactly k elements. A monotone subsequence is either increasing or decreasing. For example, some monotone subsequences in [2,1,4,5,3] are [2,4,5] and [4,3].",
    tags: "Additional Problems",
  },
  {
    id: 1743,
    name: "String Reorder",
    question:
      "Given a string, you want to reorder its characters so that no two adjacent characters are the same. What is the lexicographically minimal such string?",
    tags: "Additional Problems",
  },
  {
    id: 2425,
    name: "Stack Weights",
    question:
      "You have n coins, each of which has a distinct weight. There are two stacks which are initially empty. On each step you move one coin to a stack. You never remove a coin from a stack. After each move, your task is to determine which stack is heavier (if we can be sure that either stack is heavier).",
    tags: "Additional Problems",
  },
  {
    id: 1747,
    name: "Pyramid Array",
    question:
      "You are given an array consisting of n distinct integers. On each move, you can swap any two adjacent values. You want to transform the array into a pyramid array. This means that the final array has to be first increasing and then decreasing. It is also allowed that the final array is only increasing or decreasing. What is the minimum number of moves needed?",
    tags: "Additional Problems",
  },
  {
    id: 1748,
    name: "Increasing Subsequence II",
    question:
      "Given an array of n integers, your task is to calculate the number of increasing subsequences it contains. If two subsequences have the same values but in different positions in the array, they are counted separately.",
    tags: "Additional Problems",
  },
  {
    id: 1149,
    name: "String Removals",
    question:
      "You are given a string. You can remove any number of characters from it, but you cannot change the order of the remaining characters. How many different strings can you generate?",
    tags: "Additional Problems",
  },
  {
    id: 1188,
    name: "Bit Inversions",
    question:
      "There is a bit string consisting of n bits. Then, there are some changes that invert one given bit. Your task is to report, after each change, the length of the longest substring whose each bit is the same.",
    tags: "Additional Problems",
  },
  {
    id: 2419,
    name: "Xor Pyramid",
    question:
      "Consider a xor pyramid where each number is the xor of lower-left and lower-right numbers. Here is an example pyramid: Given the bottom row of the pyramid, your task is to find the topmost number.",
    tags: "Additional Problems",
  },
  {
    id: 1086,
    name: "Writing Numbers",
    question:
      "You would like to write a list of positive integers 1, 2, 3, … using your computer. However, you can press each key 0–9 at most n times during the process. What is the last number you can write?",
    tags: "Additional Problems",
  },
  {
    id: 1113,
    name: "String Transform",
    question:
      "Consider the following string transformation:\n\n1. append the character # to the string (we assume that # is lexicographically smaller than all other characters of the string)\n2. generate all rotations of the string\n3. sort the rotations in increasing order\n4. based on this order, construct a new string that contains the last character of each rotation\n\nFor example, the string\nbabc\nbecomes\nbabc#\n. Then, the sorted list of rotations is\n#babc\n,\nabc#b\n,\nbabc#\n,\nbc#ba\n, and\nc#bab\n. This yields a string\ncb#ab\n.",
    tags: "Additional Problems",
  },
  {
    id: 2427,
    name: "Letter Pair Move Game",
    question:
      'There are 2n boxes in a line. Two adjacent boxes are empty, and all other boxes have a letter "A" or "B". Both letters appear in exactly n − 1 boxes. Your task is to move the letters so that all letters "A" appear before any letter "B". On each turn you can choose any two adjacent boxes that have a letter and move the letters to the two adjacent empty boxes, preserving their order. It can be proven that either there is a solution that consists of at most 10n turns or there are no solutions.',
    tags: "Additional Problems",
  },
  {
    id: 1147,
    name: "Maximum Building I",
    question:
      "You are given a map of a forest where some squares are empty and some squares have trees. What is the maximum area of a rectangular building that can be placed in the forest so that no trees must be cut down?",
    tags: "Additional Problems",
  },
  {
    id: 1162,
    name: "Sorting Methods",
    question:
      "Here are some possible methods using which we can sort the elements of an array in increasing order:\n\n1. At each step, choose two adjacent elements and swap them.\n2. At each step, choose any two elements and swap them.\n3. At each step, choose any element and move it to another position.\n4. At each step, choose any element and move it to the front of the array.\n\nGiven a permutation of numbers 1, 2, …, n, calculate the minimum number of steps to sort the array using the above methods.",
    tags: "Additional Problems",
  },
  {
    id: 1191,
    name: "Cyclic Array",
    question:
      "You are given a cyclic array consisting of n values. Each element has two neighbors; the elements at positions n and 1 are also considered neighbors. Your task is to divide the array into subarrays so that the sum of each subarray is at most k. What is the minimum number of subarrays?",
    tags: "Additional Problems",
  },
  {
    id: 2414,
    name: "List of Sums",
    question:
      "List A consists of n positive integers, and list B contains the sum of each element pair of list A. For example, if A = [1,2,3], then B = [3,4,5], and if A = [1,3,3,3], then B = [4,4,4,6,6,6]. Given list B, your task is to reconstruct list A.",
    tags: "Additional Problems",
  },
  {
    id: 2132,
    name: "Increasing Array II",
    question:
      "You are given an array of n integers. You want to modify the array so that it is increasing, i.e., every element is at least as large as the previous element. On each move, you can increase or decrease the value of any element by one. What is the minimum number of moves required?",
    tags: "Additional Problems",
  },
  {
    id: 1189,
    name: "Food Division",
    question:
      "There are n children around a round table. For each child, you know the amount of food they currently have and the amount of food they want. The total amount of food in the table is correct. At each step, a child can give one unit of food to his or her neighbour. What is the minimum number of steps needed?",
    tags: "Additional Problems",
  },
  {
    id: 1654,
    name: "Bit Problem",
    question:
      "Given a list of n integers, your task is to calculate for each element x:\n\n1. the number of elements y such that x ∣ y = x\n2. the number of elements y such that x & y = x\n3. the number of elements y such that x & y ≠ 0",
    tags: "Additional Problems",
  },
  {
    id: 1698,
    name: "Swap Round Sorting",
    question:
      "You are given an array containing a permutation of numbers 1, 2, …, n, and your task is to sort the array using swap rounds. On each swap round, you can choose any number of distinct pairs of elements and swap each pair. Your task is to find the minimum number of rounds and show how you can choose the pairs in each round.",
    tags: "Additional Problems",
  },
  {
    id: 2430,
    name: "Binary Subsequences",
    question:
      "Your task is to find a minimum length bit string that has exactly n distinct subsequences. For example, a correct solution for n = 6 is\n101\nwhose distinct subsequences are\n0\n,\n1\n,\n01\n,\n10\n,\n11\nand\n101\n.",
    tags: "Additional Problems",
  },
  {
    id: 1700,
    name: "Tree Isomorphism I",
    question:
      "Given two rooted trees, your task is to find out if they are isomorphic, i.e., it is possible to draw them so that they look the same.",
    tags: "Additional Problems",
  },
  {
    id: 2228,
    name: "Counting Sequences",
    question:
      "Your task is to count the number of sequences of length n where each element is an integer between 1…k and each integer between 1…k appears at least once in the sequence. For example, when n = 6 and k = 4, some valid sequences are [1,3,1,4,3,2] and [2,2,1,3,4,2].",
    tags: "Additional Problems",
  },
  {
    id: 1703,
    name: "Critical Cities",
    question:
      "There are n cities and m flight connections between them. A city is called a critical city if it appears on every route from a city to another city. Your task is to find all critical cities from Syrjälä to Lehmälä.",
    tags: "Additional Problems",
  },
  {
    id: 1706,
    name: "School Excursion",
    question:
      "A group of n children are coming to Helsinki. There are two possible attractions: a child can visit either Korkeasaari (zoo) or Linnanmäki (amusement park). There are m pairs of children who want to visit the same attraction. Your task is to find all possible alternatives for the number of children that will visit Korkeasaari. The children’s wishes have to be taken into account.",
    tags: "Additional Problems",
  },
  {
    id: 1709,
    name: "Coin Grid",
    question:
      "There is an n × n grid whose each square is empty or has a coin. On each move, you can remove all coins in a row or column. What is the minimum number of moves after which the grid is empty?",
    tags: "Additional Problems",
  },
  {
    id: 1742,
    name: "Robot Path",
    question:
      "You are given a description of a robot’s path. The robot begins at point (0,0) and performs n commands. Each command moves the robot some distance up, down, left or right. The robot will stop when it has performed all commands, or immediately when it returns to a point that it has already visited. Your task is to calculate the total distance the robot moves.",
    tags: "Additional Problems",
  },
  {
    id: 2426,
    name: "Programmers and Artists",
    question:
      "A company wants to hire a programmers and b artists. There are a total of n applicants, and each applicant can become either a programmer or an artist. You know each applicant’s programming and artistic skills. Your task is to select the new employees so that the sum of their skills is maximum.",
    tags: "Additional Problems",
  },
  {
    id: 1757,
    name: "Course Schedule II",
    question:
      'You want to complete n courses that have requirements of the form "course a has to be completed before course b". You want to complete course 1 as soon as possible. If there are several ways to do this, you want then to complete course 2 as soon as possible, and so on. Your task is to determine the order in which you complete the courses.',
    tags: "Additional Problems",
  },
  {
    id: 2174,
    name: "Removing Digits II",
    question:
      "You are given an integer n. On each step, you may substract from it any one-digit number that appears in it. How many steps are required to make the number equal to 0?",
    tags: "Additional Problems",
  },
  {
    id: 2180,
    name: "Coin Arrangement",
    question:
      "There is a 2 × n grid whose each cell contains some number of coins. The total number of coins is 2n. Your task is to arrange the coins so that each cell contains exactly one coin. On each move you can choose any coin and move it one step left, right, up or down. What is the minimum number of moves if you act optimally?",
    tags: "Additional Problems",
  },
  {
    id: 2176,
    name: "Counting Bishops",
    question:
      "Your task is to count the number of ways k bishops can be placed on an n × n chessboard so that no two bishops attack each other. Two bishops attack each other if they are on the same diagonal.",
    tags: "Additional Problems",
  },
  {
    id: 2432,
    name: "Grid Puzzle I",
    question:
      "There is an n × n grid, and your task is to choose from each row and column some number of squares. How can you do that?",
    tags: "Additional Problems",
  },
  {
    id: 2131,
    name: "Grid Puzzle II",
    question:
      "There is an n × n grid whose each square has some number of coins in it. You know for each row and column how many squares you must choose from that row or column. You get all coins from every square you choose. What is the maximum number of coins you can collect and how could you choose the squares so that the given conditions are satisfied?",
    tags: "Additional Problems",
  },
  {
    id: 1080,
    name: "Empty String",
    question:
      "You are given a string consisting of n characters between a and z. On each turn, you may remove any two adjacent characters that are equal. Your goal is to construct an empty string by removing all the characters. In how many ways can you do this?",
    tags: "Additional Problems",
  },
  {
    id: 1078,
    name: "Grid Paths",
    question:
      "Consider an n × n grid whose top-left square is (1,1) and bottom-right square is (n,n). Your task is to move from the top-left square to the bottom-right square. On each step you may move one square right or down. In addition, there are m traps in the grid. You cannot move to a square with a trap. What is the total number of possible paths?",
    tags: "Additional Problems",
  },
  {
    id: 2115,
    name: "Bit Substrings",
    question:
      "You are given a bit string of length n. Your task is to calculate for each k between 0…n the number of non-empty substrings that contain exactly k ones. For example, if the string is 101, there are:\n\n- 1 substring that contains 0 ones: 0\n- 4 substrings that contain 1 one: 01, 1, 1, 10\n- 1 substring that contains 2 ones: 101\n- 0 substrings that contain 3 ones",
    tags: "Additional Problems",
  },
  {
    id: 2075,
    name: "Reversal Sorting",
    question:
      "You have an array that contains a permutation of integers 1, 2, …, n. Your task is to sort the array in increasing order by reversing subarrays. You can construct any solution that has at most n reversals.",
    tags: "Additional Problems",
  },
  {
    id: 2421,
    name: "Counting Reorders",
    question:
      "Calculate the number of ways you can reorder the characters of a string so that no two adjacent characters are the same. For example, the answer for\naabc\nis 6, because the possible orders are\nabac\n,\nabca\n,\nacab\n,\nacba\n,\nbaca\n, and\ncaba\n.",
    tags: "Additional Problems",
  },
  {
    id: 1159,
    name: "Book Shop II",
    question:
      "You are in a book shop which sells n different books. You know the price, the number of pages and the number of copies of each book. You have decided that the total price of your purchases will be at most x. What is the maximum number of pages you can buy? You can buy several copies of the same book.",
    tags: "Additional Problems",
  },
  {
    id: 1677,
    name: "Network Breakdown",
    question:
      "Syrjälä’s network has n computers and m connections between them. The network consists of components of computers that can send messages to each other. Nobody in Syrjälä understands how the network works. For this reason, if a connection breaks down, nobody will repair it. In this situation a component may be divided into two components. Your task is to calculate the number of components after each connection breakdown.",
    tags: "Additional Problems",
  },
  {
    id: 1203,
    name: "Visiting Cities",
    question:
      "You want to travel from Syrjälä to Lehmälä by plane using a minimum-price route. Which cities will you certainly visit?",
    tags: "Additional Problems",
  },
  {
    id: 2184,
    name: "Missing Coin Sum Queries",
    question:
      'You have n coins with positive integer values. The coins are numbered 1, 2, …, n. Your task is to process q queries of the form: "if you can use coins a…b, what is the smallest sum you cannot produce?"',
    tags: "Additional Problems",
  },
  {
    id: 1157,
    name: "Number Grid",
    question:
      "Consider a two-dimensional grid whose rows and columns are 1-indexed. Each square contains the smallest nonnegative integer that does not appear to the left on the same row or above on the same column. Your task is to calculate the value at square (y,x).",
    tags: "Additional Problems",
  },
  {
    id: 1148,
    name: "Maximum Building II",
    question:
      "You are given a map of a forest where some squares are empty and some squares have trees. You want to place a rectangular building in the forest so that no trees need to be cut down. For each building size, your task is to calculate the number of ways you can do this.",
    tags: "Additional Problems",
  },
  {
    id: 2423,
    name: "Filling Trominos",
    question:
      "Your task is to fill an n × m grid using L-trominos (three squares that have an L-shape). For example, here is one way to fill a 4 × 6 grid:",
    tags: "Additional Problems",
  },
  {
    id: 1161,
    name: "Stick Divisions",
    question:
      "You have a stick of length x and you want to divide it into n sticks, with given lengths, whose total length is x. On each move you can take any stick and divide it into two sticks. The cost of such an operation is the length of the original stick. What is the minimum cost needed to create the sticks?",
    tags: "Additional Problems",
  },
  {
    id: 1665,
    name: "Coding Company",
    question:
      "Your company has n coders, and each of them has a skill level between 0 and 100. Your task is to divide the coders into teams that work together. Based on your experience, you know that teams work well when the skill levels of the coders are about the same. For this reason, the penalty for creating a team is the skill level difference between the best and the worst coder. In how many ways can you divide the coders into teams such that the sum of the penalties is at most x?",
    tags: "Additional Problems",
  },
  {
    id: 1699,
    name: "Flight Route Requests",
    question:
      "There are n cities with airports but no flight connections. You are given m requests which routes should be possible to travel. Your task is to determine the minimum number of one-way flight connections which makes it possible to fulfil all requests.",
    tags: "Additional Problems",
  },
  {
    id: 2402,
    name: "Two Stacks Sorting",
    question:
      "You are given an input list that consists of n numbers. Each integer between 1 and n appears exactly once in the list. Your task is to create a sorted output list using two stacks. On each move you can do one of the following:\n\n- Move the first number from the input list to a stack\n- Move a number from a stack to the end of the output list",
    tags: "Additional Problems",
  },
  {
    id: 1701,
    name: "Tree Isomorphism II",
    question:
      "Given two (not rooted) trees, your task is to find out if they are isomorphic, i.e., it is possible to draw them so that they look the same.",
    tags: "Additional Problems",
  },
  {
    id: 1705,
    name: "Forbidden Cities",
    question:
      "There are n cities and m roads between them. Kaaleppi is currently in city a and wants to travel to city b. However, there is a problem: Kaaleppi has recently robbed a bank in city c and can’t enter the city, because the local police would catch him. Your task is to find out if there is a route from city a to city b that does not visit city c. As an additional challenge, you have to process q queries where a, b and c vary.",
    tags: "Additional Problems",
  },
  {
    id: 1741,
    name: "Area of Rectangles",
    question:
      "Given n rectangles, your task is to determine the total area of their union.",
    tags: "Additional Problems",
  },
  {
    id: 2429,
    name: "Grid Completion",
    question:
      "Your task is to create an n × n grid whose each row and column has exactly one A and B. Some of the characters have already been placed. In how many ways can you complete the grid?",
    tags: "Additional Problems",
  },
  {
    id: 1752,
    name: "Creating Offices",
    question:
      "There are n cities and n − 1 roads between them. There is a unique route between any two cities, and their distance is the number of roads on that route. A company wants to have offices in some cities, but the distance between any two offices has to be at least d. What is the maximum number of offices they can have?",
    tags: "Additional Problems",
  },
  {
    id: 1075,
    name: "Permutations II",
    question:
      "A permutation of integers 1, 2, …, n is called beautiful if there are no adjacent elements whose difference is 1. Given n, your task is to count the number of beautiful permutations.",
    tags: "Additional Problems",
  },
  {
    id: 2415,
    name: "Functional Graph Distribution",
    question:
      "A functional graph is a directed graph where each node has outdegree 1. For example, here is a functional graph that has 9 nodes and 2 components: Given n, your task is to calculate for each k = 1…n the number of functional graphs that have n nodes and k components.",
    tags: "Additional Problems",
  },
  {
    id: 1685,
    name: "New Flight Routes",
    question:
      "There are n cities and m flight connections between them. Your task is to add new flights so that it will be possible to travel from any city to any other city. What is the minimum number of new flights required?",
    tags: "Additional Problems",
  },
  {
    id: 2418,
    name: "Grid Path Construction",
    question:
      "Given an n × m grid and two squares a = (y₁,x₁) and b = (y₂,x₂), create a path from a to b that visits each square exactly once. For example, here is a path from a = (1,3) to b = (3,6) in a 4 × 7 grid:",
    tags: "Additional Problems",
  },
];

// const solutions: Record<number, string> = {
//   1068: `#include <bits/stdc++.h>
// using namespace std;
// int main() {
//     long long n;
//     cin >> n;
//     while (n != 1) {
//         cout << n << " ";
//         if (n % 2 == 0) {
//             n /= 2;
//         } else {
//             n = 3 * n + 1;
//         }
//     }
//     cout << 1;
// }`,
//   1083: `#include <bits/stdc++.h>
// using namespace std;
// int main(){
// 	int n;cin>>n;
// 	vector <int> nums (n+1);
// 	int temp;
// 	for (int i=0;i<n-1;i++){cin>>temp;nums[temp]=1;}
// 	for (int i=1;i<=n;i++) if (!nums[i]){cout<<i;break;}
// 	return 0;
// }`,
//   1069: `#include <bits/stdc++.h>
// using namespace std;
// int main(){
// 	int n=0,m;
// 	string s;
// 	cin>>s;
// 	char a='\0';
// 	for (int i=0;i<s.size();i++){
// 		if(a!=s[i]){
// 			m=max(n,m);
// 			n=0;
// 			a=s[i];
// 		}
// 		n++;
// 	}
// 	m=max(n,m);
// 	cout<<m<<endl;
// 	return 0;
// }`,
// };

// const solutions: Record<string, string> = {
//   "1068": `#include <bits/stdc++.h>
// using namespace std;
// int main() {
//     long long n;
//     cin >> n;
//     while (n != 1) {
//         cout << n << " ";
//         if (n % 2 == 0) {
//             n /= 2;
//         } else {
//             n = 3 * n + 1;
//         }
//     }
//     cout << 1;
// }`,
//   "1069":
//     "# include <bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n\tint n=0,m;\r\n\tstring s;\r\n\tcin>>s;\r\n\tchar a='\\0';\r\n\tfor (int i=0;i<s.size();i++){\r\n\t\tif(a!=s[i]){\r\n\t\t\tm=max(n,m);\r\n\t\t\tn=0;\r\n\t\t\ta=s[i];\r\n\t\t}\r\n\t\tn++;\r\n\t}\r\n\tm=max(n,m);\r\n\tcout<<m<<endl;\r\n\treturn 0;\r\n}",
//   "1070":
//     '# include <bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n\tlong long n;\r\n\tcin>>n;\r\n\tif (n==1){\r\n\t\tcout<<1<<endl;\r\n\t\treturn 0;\r\n\t}\r\n\tif (n<4) {\r\n\t\tcout<<"NO SOLUTION"<<endl;\r\n\t\treturn 0;\r\n\t}\r\n\tcout<<2;\r\n\tfor (int i=2;2*i<=n;i++){\r\n\t\tcout<<" "<<2*i;\r\n\t}\r\n\tfor (int i=0;2*i+1<=n;i++){\r\n\t\tcout<<" "<<2*i+1;\r\n\t}\r\n\tcout<<endl;\r\n\treturn 0;\r\n}',
//   "1071":
//     "#include<bits/stdc++.h> \r\nusing namespace std; \r\nint main() \r\n{ \r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tint t;\r\n\tlong long x,y;\r\n\tcin>>t;\r\n\tfor (int i=0;i<t;i++){\r\n\t\tcin>>x>>y;\r\n\t\tlong long m=max(x,y);\r\n\t\tif (m%2) swap(x,y);\r\n\t\tcout<<m*m-(m-x+y-1)<<'\\n';\r\n\t}\r\n\treturn 0; \r\n} ",
//   "1072":
//     "#include<bits/stdc++.h> \r\nusing namespace std; \r\nlong long sol(int n){\r\n\tswitch(n){\r\n\t\tcase 1:\r\n\t\t\treturn 0;\r\n\t\tcase 2:\r\n\t\t\treturn 0;\r\n\t\tcase 3:\r\n\t\t\treturn 8;\r\n\t\tdefault:\r\n\t\t\treturn 16*(n-2)-8+sol(n-2);\r\n\t}\r\n}\r\nint main() \r\n{ \r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tint n;\r\n\tcin>>n;\r\n\tfor (long long i=1;i<=n;i++){\r\n\t\tcout<<i*i*(i*i-1)/2-sol(i)<<'\\n';\r\n\t}\r\n\treturn 0; \r\n} ",
//   "1073":
//     "#include <bits/stdc++.h>\nusing namespace std;\nmultiset <int> s;\nint n;\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n;\n\tfor (int i=0;i<n;++i){\n\t\tint t;cin>>t;\n\t\tset<int>::iterator it=s.upper_bound(t);\n\t\tif (it!=s.end()) s.erase(it);\n\t\ts.insert(t);\n\t}\n\tcout<<s.size()<<'\\n';\n\treturn 0;\n}",
//   "1074":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define REP(i,a,b) for (int i=a;i<b;i++)\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\r\nusing namespace std;\r\n\r\nint main(){\r\n\tfastio;\r\n\tint n;cin>>n;\r\n\tvector <int> a(n);\r\n\t\r\n\tfor (auto &x:a){\r\n\t\tcin>>x;\r\n\t}\r\n\tsort(all(a));\r\n\tint m=a[n/2];\r\n\tll re=0;\r\n\tfor (auto &x:a){\r\n\t\tre+=abs(x-m);\r\n\t}\r\n\tcout<<re<<endl;\r\n\treturn 0;\r\n}",
//   "1076":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\nconst int MOD = 1000000007;\n\nint main(){\n\tfastio;\n\tint n,k;\n\tcin>>n>>k;\n\tmultiset<ll> lessPt,greatPt;\n\tvector<ll> arr(n);\n\tfor (int i=0; i<n; ++i) {\n\t\tll tmp;\n\t\tcin>>tmp;\n\t\tarr[i]=tmp;\n\t\tlessPt.insert(tmp);\n\n\t\tif (lessPt.size()>(k-1)/2) {\n\t\t\tll tmp2 = *(prev(lessPt.end()));\n\t\t\tlessPt.erase(prev(lessPt.end()));\n\t\t\tgreatPt.insert(tmp2);\n\t\t}\n\t\tif (i>=k) {\n\t\t\tif (*greatPt.begin() <= arr[i-k]) {\n\t\t\t\tgreatPt.erase(greatPt.find(arr[i-k]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlessPt.erase(lessPt.find(arr[i-k]));\n\t\t\t\tll tmp2 = *(greatPt.begin());\n\t\t\t\tgreatPt.erase(greatPt.begin());\n\t\t\t\tlessPt.insert(tmp2);\n\t\t\t}\n\t\t}\n\n\t\tif (i>=k-1) {\n\t\t\tif (i!=k-1) cout<<' ';\n\t\t\tcout<<*greatPt.begin();\n\t\t}\n\t}\n\tcout<<'\\n';\n    return 0;\n}",
//   "1077":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\r\nusing namespace std;\r\n\r\nll re=0;\r\nvector <pair<int,int>> arr;\r\n\r\nint main()\r\n{\r\n    fastio;\r\n    int n,k;\r\n    cin>>n>>k;\r\n    priority_queue <pair<int,int>> l;\r\n    priority_queue <pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>r;\r\n    arr.assign(n,pair<int,int>());\r\n    for (int i=0;i<n;i++) {cin>>arr[i].first;arr[i].second=i;}\r\n    int lcnt=0;\r\n    int mid=(k+1)>>1;\r\n    for (int i=0;i<k;i++){\r\n        if (lcnt<mid) {\r\n            r.push(arr[i]);\r\n            l.push(r.top());\r\n            r.pop();\r\n            lcnt++;\r\n        }\r\n        else {\r\n            l.push(arr[i]);\r\n            r.push(l.top());\r\n            l.pop();\r\n        }\r\n    }\r\n    for (int i=0;i<k;i++)re+=abs(arr[i].first-l.top().first);\r\n    cout<<re;\r\n    for (int i=k;i<n;i++){\r\n        ll oldmean=l.top().first;\r\n        if (arr[i-k].first<=oldmean) lcnt--;\r\n        while(!l.empty() && l.top().second<=i-k)l.pop();\r\n        while(!r.empty() && r.top().second<=i-k)r.pop();\r\n        if (lcnt<mid) {\r\n            r.push(arr[i]);\r\n            l.push(r.top());\r\n            r.pop();\r\n            lcnt++;\r\n        }\r\n        else {\r\n            l.push(arr[i]);\r\n            r.push(l.top());\r\n            l.pop();\r\n        }\r\n        while(!l.empty() && l.top().second<=i-k)l.pop();\r\n        while(!r.empty() && r.top().second<=i-k)r.pop();\r\n        re+=abs(arr[i].first-l.top().first)-abs(arr[i-k].first-l.top().first);\r\n        ll tmp=abs(oldmean-l.top().first);\r\n        re+=tmp;\r\n        if (k%2==0){\r\n            if (oldmean>l.top().first) re+=tmp;\r\n            else re-=tmp;\r\n        }\r\n        cout<<' '<<re;  \r\n    }\r\n    cout<<'\\n';\r\n    return 0;    \r\n}",
//   "1078":
//     "#include <bits/stdc++.h>\n#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\n#define ll long long\n#define MOD 1000000007;\nusing namespace std;\n\n\n\nvoid solve(){\n    int n;\n    cin>>n;\n    vector<vector<ll>> dp(n+1,vector<ll>(n+1));\n    vector<string>s(n);\n    for (int i=0;i<n;++i) cin>>s[i];\n    dp[1][1]=1;\n    for (int i=1;i<=n;++i){\n        for (int j=1;j<=n;++j){\n            dp[i][j]=(dp[i][j]+dp[i-1][j]+dp[i][j-1])%MOD;\n            if (s[i-1][j-1]=='*') dp[i][j]=0;\n        }\n    }\n    cout<<dp[n][n]<<'\\n';\n}\n\nint main()\n{\n    fastio;\n    solve();\n\treturn 0;\n}\n\n",
//   "1079":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=1e6+1.5;\nconst ll MOD=1000000007;\nll fac[maxn];\nll invFac[maxn];\nll binpow(ll x, ll y){\n\tll re=1;\n\twhile (y){\n\t\tif (y&1){\n\t\t\tre=re*x%MOD;\n\t\t}\n\t\tx=(x*x)%MOD;\n\t\ty>>=1;\n\t}\n\treturn re;\n}\nvoid setArr(){\n\tfac[0]=invFac[0]=1;\n\tfor (ll i=1;i<maxn;++i){\n\t\tfac[i]=(fac[i-1]*i)%MOD;\n\t\tinvFac[i]=binpow(fac[i],MOD-2);\n\t}\n}\nint main(){\n\tsetArr();\n\tint n;\n\tcin>>n;\n\twhile (n--){\n\t\tll x,y;\n\t\tcin>>x>>y;\n\t\tcout<<fac[x]*invFac[x-y]%MOD*invFac[y]%MOD<<'\\n';\n\t}\n\treturn 0;\n}",
//   "1081":
//     '# include <bits/stdc++.h>\n# define ll long long\n# define all(x) x.begin(), x.end()\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\n# define MOD 1000000007\n# define ten6 1000002\nusing namespace std;\n\nvector<int> maxCommon(ten6,0);\n\nvector<int> lsPrime;\n\nint binpow(int x, int y){\n    assert(y>=0);\n    int re=1;\n    while (y){\n        if (y&1) re*=x;\n        y>>=1;\n        x*=x;\n    }\n    return re;\n}\n\nvoid setPrime(){\n    bool isPrime[ten6]{0};\n    for (int i=2;i<ten6;++i) isPrime[i]=true;\n    for (int i=2;i*i<ten6;++i) {\n        if (!isPrime[i]) continue;\n        lsPrime.push_back(i);\n        int k=i*i;\n        while(k<ten6){\n            isPrime[k]=false;\n            k+=i;\n        }\n    }\n}\n\nvoid setFac(vector<pair<int,int>> & lsFac,int curr,int idx) {\n    if (idx>=lsFac.size()) {\n        ++maxCommon[curr];\n        return;\n    }\n    for (int i=0;i<=lsFac[idx].second;++i){\n        setFac(lsFac,curr*binpow(lsFac[idx].first,i),idx+1);\n    }\n}\n\nvoid setFactor(int x) {\n    if (x==1) return;\n    vector<pair<int,int>> lsFac;\n    for (int p:lsPrime) {\n        if (p*p>x) break;\n        int reTmp=0;\n        while (x%p==0){\n            ++reTmp;\n            x/=p;\n        }\n        lsFac.push_back({p,reTmp});\n    }\n    if (x>1) {\n        lsFac.push_back({x,1});\n    }\n    setFac(lsFac,1,0);\n}\n\n\nint main()\n{\n    // freopen("test_input.txt","r",stdin);\n    fastio; \n    setPrime();\n    int n;\n    cin>>n;\n    for (int i=0;i<n;++i) {\n        int tmp;\n        cin>>tmp;\n        setFactor(tmp);\n    }\n    int re=1;\n    for (int i=1;i<ten6;++i){\n        if (maxCommon[i]>=2) re=i;\n    }\n    cout<<re<<\'\\n\';\n    return 0;\n}',
//   "1083":
//     "# include <bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n\tint n;\r\n\tcin>>n;\r\n\tvector <int> nums (n+1);\r\n\tint temp;\r\n\tfor (int i=0;i<n-1;i++){cin>>temp;nums[temp]=1;}\r\n\tfor (int i=1;i<=n;i++) if (!nums[i]){cout<<i;break;}\r\n\treturn 0;\r\n}",
//   "1084":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define REP(i,a,b) for (int i=a;i<=b;i++)\r\nusing namespace std;\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tint n,m,k;\r\n\tcin>>n>>m>>k;\r\n\tvector <int> narr(n);\r\n\tvector <int> marr(m);\r\n\tREP(i,0,n-1) cin>>narr[i];\r\n\tREP(i,0,m-1) cin>>marr[i];\r\n\tsort(narr.begin(),narr.end());\r\n\tsort(marr.begin(),marr.end());\r\n\tint cn=n-1,cm=m-1,c=0;\r\n\twhile (cn>=0&&cm>=0){\r\n\t\tif (abs(narr[cn]-marr[cm])<=k) {\r\n\t\t\tcm--;cn--;c++;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (narr[cn]>marr[cm]+k) cn--;\r\n\t\t\telse cm--;\t\r\n\t\t}\r\n\t}\r\n\tcout<<c<<endl;\r\n\treturn 0;\r\n}",
//   "1085":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\n# define MOD 1000000007\r\nusing namespace std;\r\nvector <ll> arr;\r\nint n,k;\r\nbool check(ll s){\r\n\tint cnt=1;\r\n\tll acc=0;\r\n\tfor(int i = 0;i<n;i++){\r\n\t\tll tmp=acc+arr[i];\r\n\t\tif (tmp>s) {\r\n\t\t\tcnt++;\r\n\t\t\tacc=arr[i];\r\n\t\t}\r\n\t\telse acc=tmp;\r\n\t\tif (acc>s||cnt>k) return false;\r\n\t}\r\n\treturn true;\r\n}\r\nint main(){\r\n\tfastio;\r\n\tcin>>n>>k; arr.assign(n,0);\r\n\tll r=0,l=1;\r\n\tfor (auto &v:arr){\r\n\t\tcin>>v;\r\n\t\tr+=v;\r\n\t}\r\n\twhile (l<r){\r\n\t\tll mid=(l+r)>>1;\r\n\t\tif (check(mid)) r=mid;\r\n\t\telse l=mid+1;\r\n\t}\r\n\tcout<<l<<'\\n';\r\n\treturn 0;\r\n}",
//   "1087":
//     "#include <bits/stdc++.h>\nusing namespace std;\n\nint g(char x){\n\tswitch(x){\n\t\tcase 'A':\n\t\t\treturn 0;\n\t\tcase 'C':\n\t\t\treturn 1;\n\t\tcase 'T':\n\t\t\treturn 2;\n\t\tcase 'G':\n\t\t\treturn 3;\n\t}\n\treturn -1;\n}\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tstring s;\n\tcin>>s;\n\tstring re;\n\tarray<int,4> check;\n\tcheck.fill(0);\n\tint cnt=0;\n\tfor (char &c:s){\n\t\tif (!check[g(c)]){\n\t\t\tcheck[g(c)]=1;\n\t\t\t++cnt;\n\t\t}\n\t\tif (cnt==4){\n\t\t\tcnt=0;\n\t\t\tcheck.fill(0);\n\t\t\tre.push_back(c);\n\t\t}\n\t}\n\tstring tmp=\"ACGT\";\n\tfor (char&c:tmp){\n\t\tif (!check[g(c)]){\n\t\t\tre.push_back(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout<<re<<'\\n';\n\treturn 0;\n}",
//   "1090":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define REP(i,a,b) for (int i=a;i<=b;i++)\r\nusing namespace std;\r\nconst ll MOD=1000000007;\r\n\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tint n,x;\r\n\tcin>>n>>x;\r\n\tvector<int> arr(n);\r\n\tREP(i,0,n-1)cin>>arr[i];\r\n\tsort(arr.begin(),arr.end());\r\n\tint l=0,r=n-1,c=0;\r\n\twhile(l<r){\r\n\t\tif(arr[l]+arr[r]<=x){\r\n\t\t\tl++;r--;\r\n\t\t}\r\n\t\telse r--;\r\n\t\tc++;\r\n\t}\r\n\tif (l==r) c++;\r\n\tcout<<c<<endl;\r\n\treturn 0;\r\n}",
//   "1091":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define REP(i,a,b) for (int i=a;i<b;i++)\r\nusing namespace std;\r\nvector<int>memo;\r\nint findMemo(int t){\r\n\tif (memo[t]==-2) return memo[t]=t;\r\n\tif (memo[t]<=0) return -1;\r\n\tmemo[t]--;\r\n\treturn memo[t]=findMemo(memo[t]);\r\n}\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tint n,m;\r\n\tcin>>n>>m;\r\n\tvector <int>  h(n);\r\n\tvector<pair<int,int>> t;\r\n\tvector<int> re(m,-1);\r\n\tmemo.assign(n,-2);\r\n\tint temp;\r\n\tREP(i,0,n)cin>>h[i];\r\n\tREP(i,0,m){cin>>temp;t.push_back({temp,i});}\r\n\tsort(all(h));\r\n\tsort(all(t));\r\n\ttemp=0;\r\n\tfor(int i=0;i<n&&temp<m;){\r\n\t\tif(t[temp].first<h[i]){\r\n\t\t\tre[t[temp].second]=i-1;\r\n\t\t\ttemp++;\r\n\t\t}\r\n\t\telse i++;\r\n\t}\r\n\tfor(;temp<m;temp++) re[t[temp].second]=n-1;\r\n\t\r\n\tREP(i,0,m){\r\n\t\tif (re[i]==-1) continue;\r\n\t\tre[i]=findMemo(re[i]);\r\n\t\t}\r\n\tREP(i,0,m) \r\n\t{\r\n\t\tif (re[i]!=-1)\r\n\t\tcout<<h[re[i]]<<'\\n';\r\n\t\telse cout<<-1<<'\\n';\r\n\t}\r\n\treturn 0;\r\n}",
//   "1092":
//     "#include<bits/stdc++.h> \r\nusing namespace std; \r\nvoid printArr(vector <int> & x){\r\n\tcout<<x.size()<<'\\n'<<x[0];\r\n\tfor (int i=1;i<x.size();i++){\r\n\t\tcout<<' '<<x[i];\r\n\t}\r\n\tcout<<'\\n';\r\n}\r\nint main() \r\n{ \r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tint n;\r\n\tcin>>n;\r\n\tvector <int> nums,nums2;\r\n\tif (n%4!=0&&n%4!=3) {\r\n\t\tcout<<\"NO\"<<'\\n';\r\n\t}\r\n\telse{\r\n\t\tcout<<\"YES\\n\";\r\n\t\tif (n%4==0){\r\n\t\t\tfor (int i=1;i<=n/4;i++)\t\r\n\t\t\t\t{nums.push_back(i);nums.push_back(n-i+1);} \r\n\t\t\tprintArr(nums);\r\n\t\t\tnums={};\r\n\t\t\tfor (int i=n/4+1;i<=n/2;i++)\t\r\n\t\t\t\t{nums.push_back(i);nums.push_back(n-i+1);}\r\n\t\t\tprintArr(nums);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint i;\r\n\t\t\tnums2.push_back(1);\r\n\t\t\tfor(i=0;i<(n+1)/4;i++){\r\n\t\t\t\tnums.push_back(2*(i+1)+1);\r\n\t\t\t\tnums2.push_back(2*(i+1));\r\n\t\t\t}\r\n\t\t\tfor (;i<n/2;i++){\r\n\t\t\t\tnums.push_back(2*(i+1));\r\n\t\t\t\tnums2.push_back(2*(i+1)+1);\r\n\t\t\t}\r\n\t\t\tprintArr(nums);printArr(nums2);\r\n\t\t}\r\n\t}\r\n\treturn 0; \r\n} ",
//   "1093":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll MOD = 1000000007;\n\nll binPow(ll x, ll y) {\n\tll re=1;\n\twhile(y){\n\t\tif (y&1){\n\t\t\tre=(re*x)%MOD;\n\t\t}\n\t\tx=(x*x)%MOD;\n\t\ty>>=1;\n\t}\n\treturn re;\n}\n\nint main(){\n\tll n;\n\tcin>>n;\n\tll tg = n*(n+1)/2;\n\tif (tg%2) {\n\t\tcout<<0<<'\\n';\n\t\treturn 0;\n\t}\n\ttg/=2;\n\tvector<ll> dp(tg+1,0);\n\tdp[0]=1;\n\tfor (ll i=1;i<=n;++i) {\n\t\tfor (ll j =tg;j>=i;--j) {\n\t\t\tdp[j]=(dp[j]+dp[j-i])%MOD;\n\t\t}\n\t}\n\tcout<<(dp[tg]*binPow(2LL,MOD-2))%MOD<<'\\n';\n    return 0;\n}",
//   "1094":
//     "# include <bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n\tlong long n,pre=0,curr,re=0;\r\n\tcin>>n;\r\n\tfor (int i=0;i<n;i++){\r\n\t\tcin>>curr;\r\n\t\tif (curr<pre) {\r\n\t\t\tre+=pre-curr;\r\n\t\t\tcurr=pre;\r\n\t\t}\r\n\t\tpre=curr;\r\n\t}\r\n\tcout<<re<<endl;\r\n\treturn 0;\r\n}",
//   "1095":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define REP(i,a,b) for (int i=a;i<=b;i++)\r\nusing namespace std;\r\n\r\nconst ll MOD=1000000007;\r\nll expo(ll p, ll q){\r\n\tll re=1;\r\n\twhile (q){\r\n\t\tif (q&1)re=re*p%MOD;\r\n\t\tq>>=1;\r\n\t\tp=p*p%MOD;\r\n\t}\r\n\treturn re%MOD;\t\r\n}\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tint t;\r\n\tcin>>t;\r\n\twhile(t--){\r\n\tll a,b;\r\n\tcin>>a>>b;\r\n\tcout<<expo(a,b)<<'\\n';\r\n\t}\r\n\treturn 0;\r\n}",
//   "1096":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll MOD=1000000007;\n\nvector<vector<ll>> mult(vector<vector<ll>>& x, vector<vector<ll>> &y){\n\tint n1=x.size(),m1=x[0].size(),n2=y.size(),m2=y[0].size();\n\tvector<vector<ll>> re (n1,vector<ll>(m2,0));\n\tfor (int i=0;i<n1;++i){\n\t\tfor (int j=0;j<m2;++j){\n\t\t\tfor (int k=0;k<m1;++k){\n\t\t\t\tre[i][j]=(re[i][j]+x[i][k]*y[k][j])%MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn re;\n}\n\nvector<vector<ll>> binpow(vector<vector<ll>> x , ll y){\n\tvector<vector<ll>> re(6,vector<ll>(6,0));\n\tfor (int i=0;i<6;++i) re[i][i]=1;\n\twhile (y){\n\t\tif (y&1) re=mult(re,x);\n\t\ty>>=1;\n\t\tx=mult(x,x);\n\t}\n\treturn re;\n}\n\nint main(){\n\tvector<vector<ll>> mat(6,vector<ll>(6,0));\n\tfor (int i=0;i<6;++i) mat[i][0]=1;\n\tfor (int i=0;i<5;++i) mat[i][i+1]=1;\n\tll n;cin>>n;\n\tmat=binpow(mat,n);\n\tvector<vector<ll>> init(1,vector<ll>(6,0));\n\tinit[0][4]=init[0][5]=1;\n\tfor (int i=3;i>=0;--i)init[0][i]=2*init[0][i+1];\n\tcout<<mult(init,mat)[0][5]<<'\\n';\n}",
//   "1097":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MOD = 1000000007;\n\nint main(){\n\tll n;\n\tcin>>n;\n\tvector<ll> arr(n);\n\tfor (int i=0;i<n;++i) cin>>arr[i];\n\tvector<vector<pair<ll,ll>>> dp(n+1,vector<pair<ll,ll>>(n+1,{-1,-1}));\n\tfor (int i=0;i<n;++i) dp[i][i]={arr[i],0};\n\tfor (int i=1;i<n;++i) {\n\t\tfor (int j=0;j<n;++j) {\n\t\t\tif (i+j>=n) break;\n\t\t\tauto p1=dp[j][i+j-1].second+arr[i+j];\n\t\t\tauto p2=dp[j+1][i+j].second+arr[j];\n\t\t\tif (p1>p2) dp[j][i+j]= {p1,dp[j][i+j-1].first};\n\t\t\telse dp[j][i+j]= {p2,dp[j+1][i+j].first};\n\t\t}\n\t}\n\tcout<<dp[0][n-1].first<<'\\n';\n    return 0;\n}",
//   "1099":
//     '#include <bits/stdc++.h>\nusing namespace std;\nvoid solve(){\n\tint n;cin>>n;\n\tint re=0;\n\tfor (int i=0;i<n;++i){\n\t\tint tmp;cin>>tmp;\n\t\tif (i%2) re^=tmp;\n\t}\n\tcout<<((re==0)?"second":"first")<<\'\\n\';\n}\nint main(){\n\tint t;cin>>t;\n\twhile(t--)solve();\n\treturn 0;\n}',
//   "1111":
//     "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tstring s;cin>>s;\n\tint n=s.size();\n\tstring ns=\"|\";\n\tfor (char&c:s){\n\t\tns.push_back(c);\n\t\tns.push_back('|');\n\t}\n\tint nn=ns.size();\n\tvector<int> mxrad(nn,0);\n\tint rad=0,cen=0;\n\twhile (cen<ns.size()){\n\t\twhile (cen-rad-1>=0&&cen+rad+1<ns.size()&&ns[cen-rad-1]==ns[cen+rad+1]) ++rad;\n\t\tmxrad[cen]=rad;\n\n\t\tint oldcen=cen,oldrad=rad;\n\t\tcen+=1;rad=0;\n\n\t\twhile (oldcen+oldrad>=cen){\n\t\t\tint mircen=oldcen-(cen-oldcen);\n\t\t\tint mxlen=oldcen+oldrad-cen;\n\t\t\tif (mxrad[mircen]<mxlen){\n\t\t\t\tmxrad[cen]=mxrad[mircen];\n\t\t\t\tcen+=1;\n\t\t\t}\n\t\t\telse if (mxrad[mircen]>mxlen){\n\t\t\t\tmxrad[cen]=mxlen;\n\t\t\t\tcen+=1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trad=mxlen;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint mxi=-1,mx=-1;\n\tfor (int i=0;i<nn;++i){\n\t\tif (mxrad[i]>mx){\n\t\t\tmxi=i;mx=mxrad[i];\n\t\t}\n\t}\n\ts.clear();\n\tfor (int i=mxi-mx;i<=mxi+mx;++i){\n\t\tif (ns[i]!='|')s.push_back(ns[i]);\n\t}\n\tcout<<s<<'\\n';\n\treturn 0;\n\n}",
//   "1130":
//     "#include <bits/stdc++.h>\n#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\n#define ll long long\nusing namespace std;\nvector <vector<int>> adjList;\nvector <int> visited;\nint re;\n\nbool cntEdges(int curr){\n    visited[curr]=1;\n    bool check=false;\n    for (int &v:adjList[curr]){\n        if (visited[v])continue;\n        check|=cntEdges(v);\n    }\n    re+=check;\n    return !check;\n}\n\nvoid solve() {\n    int n;\n    cin>>n;\n    adjList.assign(n,vector<int>());\n    visited.assign(n,0);\n    int x,y;\n    while (cin>>x>>y) {\n        --x;--y;\n        adjList[x].push_back(y);\n        adjList[y].push_back(x);\n    }\n    re=0;\n    cntEdges(0);\n    cout<<re<<'\\n';\n}\nint main()\n{\n    fastio;\n    solve();\n\treturn 0;\n}",
//   "1131":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\n# define MOD 1000000007\r\nusing namespace std;\r\n\r\nint n;\r\nint re=0;\r\nint maxnode=0;\r\nvector <vector<int>> mp;\r\nvector <bool> vst;\r\nvector<int> dep;\r\nqueue <int> q;\r\n\t\r\nvoid bfs(){\r\n\twhile (!q.empty()){\r\n\t\tint v=q.front();\r\n\t\tq.pop();\r\n\t\tfor (auto u:mp[v]){\r\n\t\t\tif (vst[u])continue;\r\n\t\t\tvst[u]=true;\r\n\t\t\tdep[u]=dep[v]+1;\r\n\t\t\tif(re<dep[u]) {re=dep[u];maxnode=u;}\r\n\t\t\tq.push(u);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main(){\r\n\tfastio;\r\n\tcin>>n;\r\n\tmp.assign(n,vector<int>());\r\n\tvst.assign(n,false);\r\n\tdep.assign(n,0);\r\n\tint x,y;\r\n\tfor (int i=0;i<n-1;i++){\r\n\t\tcin>>x>>y;x--;y--;\r\n\t\tmp[x].push_back(y);\r\n\t\tmp[y].push_back(x);\r\n\t}\r\n\tq.push(0);\r\n\tvst[0]=true;\r\n\tbfs();\r\n\tvst.assign(n,false);\r\n\tdep[maxnode]=0;vst[maxnode]=true;\r\n\tq.push(maxnode);\r\n\tbfs();\r\n\tcout<<re<<'\\n';\r\n\treturn 0;\r\n}",
//   "1132":
//     "# include <bits/stdc++.h>\n# define ll long long\n# define all(x) x.begin(), x.end()\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n# define MOD 1000000007\nusing namespace std;\n \nint n;\nint maxnode[3];\nvector <vector<int>> mp;\nvector <bool> vst;\nvector<int> dep;\nvector<int> depReal[2];\n\t\nint bfs(int k,int start,int mxnum){\n    vector<int>*depAddr;\n    if (k<0)depAddr=&dep;\n    else depAddr=&depReal[k];\n    vector<int>&dep=*depAddr;\n    dep.assign(n,0);\n    vst.assign(n,false);\n    queue <int> q;\n    q.push(start);\n    dep[start]=0;\n    vst[start]=true;\n\n    int re=0;\n\twhile (!q.empty()){\n\t\tint v=q.front();\n\t\tq.pop();\n\t\tfor (int & u:mp[v]){\n\t\t\tif (vst[u])continue;\n\t\t\tvst[u]=true;\n\t\t\tdep[u]=dep[v]+1;\n\t\t\tif(re<dep[u]) {\n                re=dep[u];\n                maxnode[mxnum]=u;\n            }\n\t\t\tq.push(u);\n\t\t}\n\t}\n    return re;\n}\n \nint main(){\n\tfastio;\n\tcin>>n;\n\tmp.assign(n,vector<int>());\n\tint x,y;\n\tfor (int i=0;i<n-1;i++){\n\t\tcin>>x>>y;x--;y--;\n\t\tmp[x].push_back(y);\n\t\tmp[y].push_back(x);\n\t}\n    bfs(-1,0,0);\n    bfs(0,maxnode[0],1);\n    bfs(1,maxnode[1],2);\n    for (int i=0;i<n;++i) {\n        if (i!=0) cout<<' ';\n        cout<<max(depReal[0][i],depReal[1][i]);\n    }\n    cout<<'\\n';\n\treturn 0;\n}\n\n",
//   "1133":
//     "# include <bits/stdc++.h>\n# define ll long long\n# define all(x) x.begin(), x.end()\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n# define MOD 1000000007\nusing namespace std;\n \nint n;\nvector <vector<int>> adList;\nvector <bool> visit;\nvector<pair<ll,ll>> d;\n\npair<ll,ll> dfs(int curr){\n    ll numnode=1,val=0;\n    for (int &v:adList[curr]){\n        if (visit[v]) continue;\n        visit[v]=true;\n        pair<ll,ll>tmp=dfs(v);\n        numnode+=tmp.first;\n        val+=tmp.first+tmp.second;\n    }\n    return d[curr]={numnode,val};\n}\n\nvoid dfs2(int curr) {\n    for (int &v:adList[curr]) {\n        if (visit[v]) continue;\n        visit[v]=true;\n        d[v].second=d[curr].second-2*d[v].first+n;\n        dfs2(v);\n    }\n} \n\nint main(){\n\tfastio;\n\tcin>>n;\n\tadList.assign(n,vector<int>());\n    d.assign(n,{0,0});\n    visit.assign(n,0);\n\tint x,y;\n\tfor (int i=0;i<n-1;i++){\n\t\tcin>>x>>y;x--;y--;\n\t\tadList[x].push_back(y);\n\t\tadList[y].push_back(x);\n\t}\n    visit[0]=true;\n    dfs(0);\n    visit.assign(n,false);\n    visit[0]=true;\n    dfs2(0);\n    for (int i=0;i<n;++i){\n        if (i!=0) cout<<' ';\n        cout<<d[i].second;\n    }\n    cout<<'\\n';\n\treturn 0;\n}\n\n",
//   "1135":
//     "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adjList;\nint up[(int)(2e5+1.5)][20] {};\nvector<int>tin,tout,d;\nint n,q,timer;\n\nvoid dfs(int curr,int pre){\n\ttin[curr]=timer++;\n\tup[curr][0]=pre;\n\tfor (int i=1;i<20;++i){\n\t\tup[curr][i]=up[up[curr][i-1]][i-1];\n\t}\n\tfor (int &v:adjList[curr]){\n\t\tif (v==pre) continue;\n\t\td[v]=d[curr]+1;\n\t\tdfs(v,curr);\n\t}\n\ttout[curr]=timer++;\n}\n\nbool is_ancestor(int par,int child){\n\treturn tin[par]<=tin[child]&&tout[par]>=tout[child];\n}\n\nint lca(int n1,int n2){\n\tif (is_ancestor(n1,n2)) return n1;\n\tif (is_ancestor(n2,n1)) return n2;\n\tfor (int i=19;i>=0;--i){\n\t\tif (!is_ancestor(up[n1][i],n2)) n1=up[n1][i];\n\t}\n\treturn up[n1][0];\n}\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n>>q;\n\tadjList.assign(n,vector<int>());\n\ttin.assign(n,-1);\n\ttout.assign(n,-1);\n\td.assign(n,-1);\n\td[0]=0;\n\ttimer=0;\n\tfor (int i=1;i<n;++i){\n\t\tint a,b;cin>>a>>b;--a;--b;\n\t\tadjList[a].push_back(b);\n\t\tadjList[b].push_back(a);\n\t}\n\tdfs(0,0);\n\tfor (int i=0;i<q;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;--a;--b;\n\t\tcout<<d[a]+d[b]-2*d[lca(a,b)]<<'\\n';\n\t}\n\treturn 0;\n}",
//   "1136":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<vector<int>> up;\nvector<int> tin,tout;\nint n,q,timer;\n\nvoid dfs(int curr, int p){\n\ttin[curr]=timer++;\n\tup[curr][0]=p;\n\n\tfor (int i=1;i<20;++i){\n\t\tup[curr][i]=up[up[curr][i-1]][i-1];\n\t}\n\n\tfor (int&v:adj[curr]){\n\t\tif (v==p) continue;\n\t\tdfs(v,curr);\n\t}\n\ttout[curr]=timer++;\n}\n\nbool is_ancestor(int x, int y) {\n\treturn tin[x]<=tin[y] && tout[x]>=tout[y];\n}\n\nint lca(int x,int y){\n\tif (is_ancestor(x,y)) return x;\n\tif (is_ancestor(y,x)) return y;\n\n\tfor (int i=19;i>=0;--i){\n\t\tint tmp=up[x][i];\n\t\tif (is_ancestor(tmp,y)) continue;\n\t\tx=tmp;\n\t}\n\n\treturn up[x][0];\n}\n\nvoid dfs1(vector<int>&treeVal,int curr, int p){\n\tfor (int&v:adj[curr]){\n\t\tif (v==p) continue;\n\t\tdfs1(treeVal,v,curr);\n\t\ttreeVal[curr]+=treeVal[v];\n\t}\n}\n\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n>>q;\n\tadj.assign(n,vector<int>());\n\tfor (int i=0;i<n-1;++i){\n\t\tint x,y;cin>>x>>y;--x;--y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\ttimer=0;\n\ttin.assign(n,0);\n\ttout.assign(n,0);\n\tup.assign(n,vector<int>(20,0));\n\tdfs(0,0);\n\tvector<int> treeVal(n);\n\tfor (int i=0;i<q;++i){\n\t\tint a,b;cin>>a>>b;--a;--b;\n\t\tint l=lca(a,b);\n\t\tif (l!=0) treeVal[up[l][0]]-=1;\n\t\ttreeVal[l]-=1;\n\t\ttreeVal[a]+=1;\n\t\ttreeVal[b]+=1;\n\t}\n\tdfs1(treeVal,0,0);\n\tfor (int i=0;i<n;++i){\n\t\tif (i!=0) cout<<' ';\n\t\tcout<<treeVal[i];\n\t}\n\tcout<<'\\n';\n\treturn 0;\n}",
//   "1137":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<array<int,2>> seg;\nvector<ll> st;\nvector<int> a;\nint timer,n,q;\nvoid dfs(int curr,int p){\n\tseg[curr][0]=timer++;\n\tfor (int &v:adj[curr]){\n\t\tif (v==p) continue;\n\t\tdfs(v,curr);\n\t}\n\tseg[curr][1]=timer++;\n}\n\nvoid buildTree(int v,int tl, int tr){\n\tif (tl==tr){\n\t\tst[v]=a[tl];\n\t}\n\telse {\n\t\tint mid=(tl+tr)>>1;\n\t\tbuildTree(v*2,tl,mid);\n\t\tbuildTree(v*2+1,mid+1,tr);\n\t\tst[v]=st[v*2]+st[v*2+1];\n\t}\n}\n\nll sum(int v, int l,int r, int tl, int tr){\n\tif (l==tl&&r==tr){\n\t\treturn st[v];\n\t}\n\tif (l>r) return 0;\n\tint mid=(tl+tr)>>1;\n\treturn sum(v*2,l,min(r,mid),tl,mid)+sum(v*2+1,max(l,mid+1),r,mid+1,tr);\n}\n\nvoid update(int v, int tl, int tr, int pos, int val){\n\tif (tl==tr){\n\t\tst[v]=val;\n\t\treturn;\n\t}\n\tint mid=(tl+tr)>>1;\n\tif (pos<=mid) update(v*2,tl,mid,pos,val);\n\telse update(v*2+1,mid+1,tr,pos,val);\n\tst[v]=st[v*2]+st[v*2+1];\n}\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n>>q;\n\tvector<int> a1(n);\n\tfor (int&v:a1) cin>>v;\n\tadj.assign(n,vector<int>());\n\tfor (int i=0;i<n-1;++i){\n\t\tint x,y;cin>>x>>y;--x;--y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\tseg.assign(n,array<int,2>());\n\ttimer=0;\n\tdfs(0,0);\n\ta.assign(timer,0);\n\tfor (int i=0;i<n;++i) a[seg[i][0]]=a1[i];\n\tst.assign(4*timer,0);\n\tbuildTree(1,0,timer-1);\n\tfor (int i=0;i<q;++i){\n\t\tint t;cin>>t;\n\t\tif (t==1){\n\t\t\tint s,x;\n\t\t\tcin>>s>>x;--s;\n\t\t\tupdate(1,0,timer-1,seg[s][0],x);\n\t\t}\n\t\telse{\n\t\t\tint s;\n\t\t\tcin>>s;--s;\n\t\t\tcout<<sum(1,seg[s][0],seg[s][1],0,timer-1)<<'\\n';\n\t\t}\n\t}\n\treturn 0;\n}",
//   "1138":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<array<int,2>> seg,seg1,seg2;\nint timer,n,q;\nvector<int> a;\nll sA=0;\n\nvoid dfs(int curr,int p){\n\tseg[curr][0]=timer++;\n\tfor (int &v:adj[curr]){\n\t\tif (v==p) continue;\n\t\tdfs(v,curr);\n\t}\n\n\tseg[curr][1]=timer-1;\n}\n\nvoid buildTree(int v,int tl, int tr, vector<int>&a,vector<ll>&st){\n\tif (tl==tr){\n\t\tst[v]=a[tl];\n\t}\n\telse {\n\t\tint mid=(tl+tr)>>1;\n\t\tbuildTree(v*2,tl,mid,a,st);\n\t\tbuildTree(v*2+1,mid+1,tr,a,st);\n\t\tst[v]=st[v*2]+st[v*2+1];\n\t}\n}\n\nll sum(int v, int l,int r, int tl, int tr,vector<ll>&st){\n\tif (l==tl&&r==tr){\n\t\treturn st[v];\n\t}\n\tif (l>r) return 0;\n\tint mid=(tl+tr)>>1;\n\treturn sum(v*2,l,min(r,mid),tl,mid,st)+sum(v*2+1,max(l,mid+1),r,mid+1,tr,st);\n}\n\nvoid update(int v, int tl, int tr, int pos, int val,vector<ll>&st){\n\tif (tl==tr){\n\t\tst[v]=val;\n\t\treturn;\n\t}\n\tint mid=(tl+tr)>>1;\n\tif (pos<=mid) update(v*2,tl,mid,pos,val,st);\n\telse update(v*2+1,mid+1,tr,pos,val,st);\n\tst[v]=st[v*2]+st[v*2+1];\n}\n\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n>>q;\n\tvector<int> a1(n);\n\tfor (int&v:a1) cin>>v;\n\tadj.assign(n,vector<int>());\n\tfor (int i=0;i<n-1;++i){\n\t\tint x,y;cin>>x>>y;--x;--y;\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\tseg.assign(n,array<int,2>());\n\tseg1.assign(n,array<int,2>());\n\tseg2.assign(n,array<int,2>());\n\ttimer=0;\n\tdfs(0,0);\n\ta.assign(n,0);\n\t\n\tfor (int i=0;i<n;++i){\n\t\ta[seg[i][0]]=a1[i];\n\t\tsA+=a1[i];\n\n\t\tseg1[i]=seg[i];\n\t\tseg2[i]={seg[i][1],seg[i][0]};\n\t}\n\n\tsort(seg1.begin(),seg1.end());sort(seg2.begin(),seg2.end());\n\tvector<int> pref(n);\n\tfor (int i=0;i<n;++i) pref[i]=a[seg2[i][1]];\n\n\tvector<ll> st1(4*n),st2(4*n);\n\tbuildTree(1,0,n-1,a,st1);\n\tbuildTree(1,0,n-1,pref,st2);\n\n\tfor (int i=0;i<q;++i){\n\t\tint t,s;cin>>t>>s;\n\t\t--s;\n\t\tint pos=seg[s][0];\n\t\tif (t==1){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tint prepos=lower_bound(seg2.begin(),seg2.end(),array<int,2>({seg[s][1],seg[s][0]}))-seg2.begin();\n\t\t\tupdate(1,0,n-1,pos,x,st1);\n\t\t\tupdate(1,0,n-1,prepos,x,st2);\n\t\t\tsA=sA-a[pos]+x;\n\t\t\ta[pos]=x;\n\t\t}\n\t\telse{\n\t\t\tint prepos=lower_bound(seg2.begin(),seg2.end(),array<int,2>({seg[s][0],0}))-seg2.begin();\n\t\t\tcout<<sA-sum(1,pos+1,n-1,0,n-1,st1)-sum(1,0,prepos-1,0,n-1,st2)\n\t\t\t<<'\\n';\n\t\t}\n\t}\n\treturn 0;\n}",
//   "1139":
//     "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> adj;\nvector<array<int,3>>seg;\nint n,timer;\nvector<int> col;\nvector<int> ncol;\nvector<int> ans;\nvector<int> F;\nmap<int,int> m;\n\nvoid dfs(int cur,int par){\n\tseg[cur][1]=timer++;\n\tncol[timer-1]=col[cur];\n\tfor(int &v:adj[cur]){\n\t\tif (v==par)continue;\n\t\tdfs(v,cur);\n\t}\n\tseg[cur][0]=timer-1;\n}\nvoid increase(int pos, int val){\n\tfor (int i=pos;i<n;i=i|(i+1)){\n\t\tF[i]+=val;\n\t}\n}\nint sum1(int pos){\n\tint re=0;\n\tfor (int i=pos;i>=0;i=(i&(i+1))-1){\n\t\tre+=F[i];\n\t}\n\treturn re;\n}\nint sum(int l,int r){\n\treturn sum1(r)-sum1(l-1);\n}\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n;\n\tcol.assign(n,0);\n\tans.assign(n,0);\n\tadj.assign(n,vector<int>());\n\tfor (int&v:col)cin>>v;\n\tfor (int i=0;i<n-1;++i){\n\t\tint a,b;cin>>a>>b;--a;--b;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\ttimer=0;\n\tseg.assign(n,array<int,3>());\n\tncol.assign(n,0);\n\tfor (int i=0;i<n;++i){\n\t\tseg[i][2]=i;\n\t}\n\tdfs(0,0);\n\tsort(seg.begin(), seg.end());\n\n\tF.assign(n,0);\n\tint currend=-1;\n\tfor (auto &ar:seg){\n\t\twhile (currend<ar[0]){\n\t\t\t++currend;\n\t\t\tincrease(currend,1);\n\t\t\tint x=m[ncol[currend]];\n\t\t\tif (x!=0) increase(x-1,-1);\n\t\t\tm[ncol[currend]]=currend+1;\n\t\t}\n\t\tans[ar[2]]=sum(ar[1],ar[0]);\n\t}\n\tfor (int &v:ans)cout<<v<<' ';\n\tcout<<'\\n';\n\treturn 0;\n}",
//   "1140":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\nconst ll MOD = 1000000007;\nconst int maxn = 200001;\nint n;\n\nint main(){\n\tfastio;\n\tcin>>n;\n\tvector<tuple<int, int ,ll>> arr(n);\n\tfor (int i=0; i<n; ++i) {\n\t\tcin>>get<1>(arr[i])>>get<0>(arr[i])>>get<2>(arr[i]);\n\t}\n\tsort(arr.begin(),arr.end());\n\n\tvector <pair<int, ll>> sav;\n\tsav.push_back({0,0LL});\n\tfor (int i=0; i<n; ++i) {\n\t\tauto it = lower_bound(sav.begin(),sav.end(),make_pair(get<1>(arr[i]),-1LL));\n\t\tpair<int,ll> nxt = {get<0>(arr[i]),get<2>(arr[i])};\n\t\tif (it!=sav.begin()) nxt.second+=prev(it)->second;\n\t\tnxt.second=max(nxt.second,sav.back().second);\n\t\tsav.push_back(nxt);\n\t}\n\tcout<<sav.back().second<<'\\n';\n\treturn 0;\n}",
//   "1141":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\r\nusing namespace std;\r\n\r\nint main(){\r\n\tfastio;\r\n\tint n;cin>>n;\r\n\tunordered_map <int,int> s;\r\n\ts.reserve(2e5);\r\n\tint re=0,temp,c=1,i=1;\r\n\tfor(;i<=n;i++){\r\n\t\tcin>>temp;\r\n\t\tif (s[temp] && s[temp]>=c){\r\n\t\t\tre=max(i-c,re);\r\n\t\t\tc=s[temp]+1;\r\n\t\t}\r\n\t\ts[temp]=i;\r\n\t}\r\n\tre=max(i-c,re);\r\n\tcout<<re<<endl;\r\n\treturn 0;\r\n}",
//   "1143":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint n,m;\nvector<int> a;\nvector<int> st;\nvoid buildTree(int v,int tl, int tr){\n\tif (tl==tr){\n\t\tst[v]=a[tl];\n\t}\n\telse{\n\t\tint mid = (tl+tr)>>1;\n\t\tbuildTree(v*2,tl,mid);\n\t\tbuildTree(v*2+1,mid+1,tr);\n\t\tst[v]=max(st[v*2],st[v*2+1]);\n\t}\n}\nint get(int v,int l, int r, int tl, int tr){\n\tif (l==tl&&r==tr){\n\t\treturn st[v];\n\t}\n\tif (l>r) return -1;\n\tint mid=(tl+tr)>>1;\n\treturn max(get(v*2,l,min(mid,r),tl,mid),get(v*2+1,max(l,mid+1),r,mid+1,tr));\n}\nvoid update(int v,int tl, int tr, int val,int pos){\n\tif (tl==tr){\n\t\tst[v]=val;\n\t\treturn;\n\t}\n\tint mid=(tl+tr)>>1;\n\tif (pos<=mid) update(v*2,tl,mid,val,pos);\n\telse update(v*2+1,mid+1,tr,val,pos);\n\tst[v]=max(st[v*2],st[v*2+1]);\n}\n\nint getPos(int tg){\n\tif (st[1]<tg) return 0;\n\tint l=0,r=n-1;\n\twhile (l<=r){\n\t\tint mid = (l+r)>>1;\n\t\tint mx=get(1,0,mid,0,n-1);\n\t\tif (mx>=tg) {\n\t\t\tr=mid-1;\n\t\t}\n\t\telse {\n\t\t\tl=mid+1;\n\t\t}\n\t}\n\tint nval=get(1,0,l,0,n-1)-tg;\n\tassert(nval>=0);\n\tupdate(1,0,n-1,nval,l);\n\treturn l+1;\n}\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n>>m;\n\ta.assign(n,0);\n\tst.assign(4*n,0);\n\tfor (int i=0;i<n;++i) {\n\t\tcin>>a[i];\n\t}\n\tbuildTree(1,0,n-1);\n\tfor (int i=0;i<m;++i){\n\t\tint r;cin>>r;\n\t\tcout<<getPos(r)<<' ';\n\t}\n\treturn 0;\n}\n//  2 3 4 2 1 8",
//   "1144":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \n#define ordered_set tree<array<int,2>, null_type,less<array<int,2>>, rb_tree_tag,tree_order_statistics_node_update> \n\nint n,q;\nvector<int> v;\nordered_set s;\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n>>q;\n\tv.assign(n,0);\n\tfor (int i=0;i<n;++i) {\n\t\tcin>>v[i];\n\t\ts.insert({v[i],i});\n\t}\n\tfor (int i=0;i<q;++i){\n\t\tchar t;cin>>t;\n\t\tif (t=='?'){\n\t\t\tint x,y;cin>>x>>y;\n\t\t\tauto e=s.upper_bound({y+1,-1});\n\t\t\tauto b=s.upper_bound({x,-1});\n\t\t\tint ePos=n;\n\t\t\tif (e!=s.end()) ePos=s.order_of_key((*e));\n\t\t\tcout<<ePos - (int)s.order_of_key(*b)<<'\\n';\n\t\t}\n\t\telse {\n\t\t\tassert(t=='!');\n\t\t\tint x,y;cin>>x>>y;--x;\n\t\t\tauto it=s.find({v[x],x});\n\t\t\tassert(it!=s.end());\n\t\t\ts.erase(it);\n\t\t\tv[x]=y;\n\t\t\ts.insert({v[x],x});\n\t\t}\n\t}\n\treturn 0;\n}\n",
//   "1145":
//     "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<int> arr(n);\n\tfor (int&v:arr)cin>>v;\n\n\tvector<int> lastNum;\n\tfor (int i=0;i<n;++i) {\n\t\tauto it = lower_bound(lastNum.begin(),lastNum.end(),arr[i]);\n\t\tif (it!=lastNum.end()){\n\t\t\t*it=arr[i];\n\t\t}\n\t\telse {\n\t\t\tlastNum.push_back(arr[i]);\n\t\t}\n\t}\n\tcout<<lastNum.size()<<'\\n';\n}",
//   "1146":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint main(){\n\tll n;\n\tcin>>n;\n\tll cur=1,re=0;\n\twhile (cur<=n){\n\t\tll x=n-(cur-1);\n\t\tre+=x/(cur<<1)*cur+min(x%(cur<<1),cur);\n\t\tcur<<=1;\n\t}\n\tcout<<re<<'\\n';\n\treturn 0;\n}\n\n// 000\n// 001\n// 010\n// 011\n// 100\n// 101\n// 110\n// 111\n",
//   "1158":
//     '# include <bits/stdc++.h>\n# define ll long long\n# define all(x) x.begin(), x.end()\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\n# define MOD 1000000007\n# define ten6 1000002\nusing namespace std;\nint n, X;\nvector<pair<int,int>> book,book2;\nvector<vector<int>> dp;\n\nint getMax(int money, int idx) {\n    if (idx>=n||money<=0) return 0;\n    if(dp[money][idx]>=0) return dp[money][idx];\n    if (money>=book2[idx].first) return dp[money][idx]=book2[idx].second;\n    if (book[idx].first>money) return dp[money][idx]=getMax(money,idx+1);\n    return dp[money][idx]=max(book[idx].second+getMax(money-book[idx].first,idx+1),getMax(money,idx+1));\n}\n\nbool comp(pair<int,int> x,pair<int,int> y) {\n    double f=1.0/x.first*x.second;\n    double s= 1.0/y.first*y.second;\n    return f==s&&x>y||f<s;\n}\n\nint main()\n{\n    // freopen("test_input.txt","r",stdin);\n    // auto start=chrono::high_resolution_clock::now();\n\n    fastio;\n    cin>>n>>X;\n    dp.assign(X+1,vector<int>(n,-1));\n    book.assign(n,pair<int,int>());\n    for (int i=0;i<n;++i) cin>>book[i].first;\n    for (int i=0;i<n;++i) cin>>book[i].second;\n    sort(book.begin(),book.end(),comp);\n    book2.assign(n+1,pair<int,int>());\n    int s=-1;\n    for (int i=n-1;i>=0;--i) {\n        book2[i].first=book2[i+1].first+book[i].first;\n        book2[i].second=book2[i+1].second+book[i].second;\n        if (s==-1&&book2[i].first>X){\n            s=max(i-30,0);\n        }\n    }\n    s=max(s,0);\n    cout<<getMax(X,s)<<\'\\n\';\n \n    // auto end=chrono::high_resolution_clock::now();\n    // cout<<"Time elapsed: "<<chrono::duration_cast<chrono::milliseconds>(end-start).count()<<endl;\n    return 0;\n}',
//   "1160":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint n,m,timer,timer1;\nvector<int> p,tin,tout;\nvector<array<int,3>> idx;\nvector<vector<int>> l,up,adjList;\n\nvoid genLine(int x){\n\tvector<int> v;\n\twhile (idx[x][0]>0){\n\t\tv.push_back(x);\n\t\tidx[x][0]=-2;\n\t\tx=p[x];\n\t}\n\tif (idx[x][0]!=0) x=-1;\n \treverse(v.begin(),v.end());\n \tfor (int& c:v){\n \t\tif (p[c]!=x) adjList[p[c]].push_back(c);\n \t\telse adjList[l[idx[x][1]][0]].push_back(c);\n \t}\n\n}\n\nvoid genCycle(int x){\n\tint pos=l.size();\n\tint turtle=p[x], rabbit=p[p[x]];\n\twhile (turtle!=rabbit){\n\t\tturtle=p[turtle];\n\t\trabbit=p[p[rabbit]];\n\t}\n\tint y=x;\n\t\n\twhile (y!=turtle){\n\t\ty=p[y];\n\t\tturtle=p[turtle];\n\t}\n\n\tl.push_back({y});\n\tvector<int> &cycle=l[pos];\n\tidx[y]={0,pos,0};\n\tint y1=p[y];\n\tint tmp=1;\n\twhile (y1!=y) {\n\t\tidx[y1]={0,pos,tmp++};\n\t\tcycle.push_back(y1);\n\t\ty1=p[y1];\n\t}\n\n \tgenLine(x);\n}\n\nvoid merge(int x){\n\tidx[x][0]=timer;\n\tint tmp=p[x];\n\twhile (idx[tmp][0]==-1){\n\t\tidx[tmp][0]=timer;\n\t\ttmp=p[tmp];\n\t}\n\tint a=idx[tmp][0];\n\tif (a==timer) genCycle(x);\n\telse genLine(x);\n\t++timer;\n}\n\nvoid dfs(int x,int pre){\n\ttin[x]=timer1++;\n\tup[x][0]=pre;\n\tfor (int i=1;i<20;++i)\n\t\tup[x][i]=up[up[x][i-1]][i-1];\n\n\tfor (int &c:adjList[x])\tdfs(c,x);\n\ttout[x]=timer1++;\n}\n\nbool is_ancestor(int x,int y){\n\treturn tin[x]<=tin[y]&&tout[x]>=tout[y];\n}\n\nint get(int x, int y){\n\tif (x==y) return 0;\n\tint re=0;\n\tint &a=idx[x][0],&b=idx[x][1],&c=idx[x][2];\n\tif (a==0){\n\t\tif (idx[y][0]==0&&b==idx[y][1]) {\n\t\t\tre=idx[y][2]-c;\n\t\t\tif (re<0) re+=l[b].size();\n\t\t\treturn re;\n\t\t}\n\t\treturn -1;\n\t}\n\tint y1=y;\n\tif (idx[y][0]==0) y=l[idx[y][1]][0];\n\tif (!is_ancestor(y,x)) return -1;\n\tfor (int i=19;i>=0;--i){\n\t\tif (is_ancestor(up[x][i],y))continue;\n\t\tx=up[x][i];\n\t\tre+=(1<<i);\n\t}\n\tx=p[x];\n\t++re;\n\tif (x!=y1)  return re+get(x,y1);\n\treturn re;\n}\n\nvoid solve(){\n\tidx.assign(n,{-1,-1,-1});\n\tup.assign(n,vector<int>(20,-1));\n\tadjList.assign(n,vector<int>());\n\ttin.assign(n,-1);\n\ttout.assign(n,-1);\n\ttimer=timer1=1;\n\tfor (int i=0;i<n;++i){\n\t\tif (idx[i][0]==-1) merge(i);\n\t}\n\tfor (int i=0;i<n;++i){\n\t\tif (idx[i][0]==0&&idx[i][2]==0) dfs(i,i);\n\t}\n\tfor (int i=0;i<m;++i){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tcout<<get(x-1,y-1)<<'\\n';\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(NULL);\n\tcin>>n>>m;\n\tp.assign(n,-1);\n\tfor (int i=0;i<n;++i){\n\t\tcin>>p[i];\n\t\t--p[i];\n\t}\n\tsolve();\n\treturn 0;\n}",
//   "1163":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL)\r\nusing namespace std;\r\nbool comp(int x,int y){\r\n\treturn x>y;\r\n}\r\nint main(){\r\n\tfastio;\r\n\tint x,n,tmp;cin>>x>>n;\r\n\tmap <int,int> s;\r\n\tcin>>tmp;\r\n\tset <int> m={0,tmp,x};\r\n\ts[x-tmp]++;s[tmp]++;\r\n\tcout<<(*s.rbegin()).first;\r\n\tfor (int i=1;i<n;i++){\r\n\t\tcin>>tmp;\r\n\t\tauto it2=m.upper_bound(tmp);\r\n\t\tauto it=it2--;\r\n\t\tint olddis=*it-*it2;\r\n\t\tauto sit=s.find(olddis);\r\n\t\t--(*sit).second;\r\n\t\tif ((*sit).second==0) s.erase(sit);\r\n\t\ts[*it-tmp]++;s[tmp-*it2]++;\r\n\t\tm.insert(tmp);\r\n\t\tcout<<' '<<(*s.rbegin()).first;\r\n\t}\r\n\tcout<<'\\n';\r\n\treturn 0;\r\n}",
//   "1164":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL)\r\nusing namespace std;\r\nbool comp(int x,int y){\r\n\treturn x>y;\r\n}\r\nint main(){\r\n\tfastio;\r\n\tint n,tmp;cin>>n;\r\n\tvector <pair<pair<int,int>,int>> a(2*n);\r\n\tvector <int> re(n);\r\n\tfor (int i=0;i<2*n;i+=2){\r\n\t\tcin>>a[i].first.first>>a[i+1].first.first;\r\n\t\ta[i].first.second=-1;a[i+1].first.second=1;\r\n\t\ta[i].second=a[i+1].second=i/2;\r\n\t}\r\n\tsort(all(a));\r\n\tint num=1,roomid;\r\n\tset <int> remainRooms;\r\n\tfor (auto v:a){\r\n\t\ttmp=v.first.second;\r\n\t\troomid=v.second;\r\n\t\tif (tmp==-1) {\r\n\t\t\tif (remainRooms.size()>0) {\r\n\t\t\t\tre[roomid]=*remainRooms.begin();\r\n\t\t\t\tremainRooms.erase(remainRooms.begin());\r\n\t\t\t}\r\n\t\t\telse re[roomid]=num++;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tremainRooms.insert(re[roomid]);\r\n\t\t}\r\n\t}\r\n\tcout<<num-1<<'\\n';\r\n\tcout<<re[0];\r\n\tfor (int i=1;i<n;i++)cout<<' '<<re[i];\r\n\tcout<<'\\n';\r\n\treturn 0;\r\n}",
//   "1190":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nstruct Node{\n\tll s;\n\tll pre;\n\tll suf;\n\tll re;\n};\n\nvector<Node> st;\nvector<ll> a;\nint n,q;\n\nvoid buildTree(int v,int tl, int tr){\n\tif (tl==tr){\n\t\tst[v].s=st[v].pre=st[v].suf=st[v].re=a[tl];\n\t\treturn;\n\t}\n\tint mid = (tl+tr)>>1;\n\tbuildTree(v*2,tl,mid);\n\tbuildTree(v*2+1,mid+1,tr);\n\tst[v].s=st[v*2].s+st[v*2+1].s;\n\tst[v].pre=max(st[v*2].pre,st[v*2].s+st[v*2+1].pre);\n\tst[v].suf=max(st[v*2+1].suf,st[v*2+1].s+st[v*2].suf);\n\tst[v].re=max(max(st[v*2].re,st[v*2+1].re),st[v*2].suf+st[v*2+1].pre);\n}\n\nvoid update(int v,int tl, int tr,int pos,ll val){\n\tif (tl==tr){\n\t\tst[v].s=st[v].pre=st[v].suf=st[v].re=val;\n\t}\n\telse {\n\t\tint mid =(tl+tr)>>1;\n\t\tif (pos<=mid) update(v*2,tl,mid,pos,val);\n\t\telse update(v*2+1,mid+1,tr,pos,val);\n\t\tst[v].s=st[v*2].s+st[v*2+1].s;\n\t\tst[v].pre=max(st[v*2].pre,st[v*2].s+st[v*2+1].pre);\n\t\tst[v].suf=max(st[v*2+1].suf,st[v*2+1].s+st[v*2].suf);\n\t\tst[v].re=max(max(st[v*2].re,st[v*2+1].re),st[v*2].suf+st[v*2+1].pre);\t\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n>>q;\n\ta.assign(n,0);\n\tfor (int i=0;i<n;++i){\n\t\tcin>>a[i];\n\t}\n\tst.assign(4*n,Node({0,0,0,0}));\n\tbuildTree(1,0,n-1);\n\tfor (int i=0;i<q;++i){\n\t\tll x,y;cin>>x>>y;--x;\n\t\tupdate(1,0,n-1,x,y);\n\t\tcout<<max(st[1].re,0LL)<<'\\n';\n\t}\n\treturn 0;\n}",
//   "1192":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\n# define MOD 1000000007\r\nusing namespace std;\r\nvector<string> mp;\r\nvector <vector<bool>> vst;\r\n\r\nint n,m;\r\nint dirx[]={-1,1,0,0};\r\nint diry[]={0,0,-1,1};\r\nvoid dfs(int u,int v){\r\n\tif (u<0||u>=n||v<0||v>=m) return;\r\n\tif (vst[u][v]||mp[u][v]=='#')return;\r\n\tvst[u][v]=true;\r\n\tfor (int i=0;i<4;i++){\r\n\t\tdfs(u+dirx[i],v+diry[i]);\r\n\t}\r\n}\r\nint main(){\r\n\tfastio;\r\n\tcin>>n>>m;\r\n\tmp.assign(n,\"\");\r\n\tvst.assign(n,vector<bool>(m,false));\r\n\tint re=0;\r\n\tfor (int i=0;i<n;i++)cin>>mp[i];\r\n\tfor (int i=0;i<n;i++){\r\n\t\tfor(int j=0;j<m;j++)\r\n\t\t\tif (mp[i][j]=='.'&&!vst[i][j]){\r\n\t\t\t\tdfs(i,j);\r\n\t\t\t\tre++;\r\n\t\t\t}\r\n\t}\r\n\tcout<<re<<endl;\r\n\treturn 0;\r\n}",
//   "1193":
//     "#include <bits/stdc++.h>\n#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\n#define ll long long\nusing namespace std;\n\nvector<string> s;\nint n,m;\nint dirx[]={-1,1,0,0};\nint diry[]={0,0,-1,1};\nchar dir[]={'U','D','L','R'};\n\nbool bfs(pair<int,int> curr,vector<pair<int,char>> & path){\n    queue<pair<int,int>> q;\n    q.push(curr);\n    s[curr.first][curr.second]='#';\n    while (!q.empty()){\n        curr=q.front();\n        q.pop();\n        for (int i=0;i<4;++i){\n            pair<int,int>nxt={curr.first+dirx[i],curr.second+diry[i]};\n            if (nxt.first>=n||nxt.first<0||nxt.second>=m||nxt.second<0) continue;\n            if (s[nxt.first][nxt.second]=='#') continue;\n            path[nxt.first*m+nxt.second]={curr.first*m+curr.second,dir[i]};\n            if (s[nxt.first][nxt.second]=='B') return true;\n            q.push(nxt);\n            s[nxt.first][nxt.second]='#';\n        }\n    }\n    return false;\n}\n\nvoid solve(){\n    cin>>n>>m;\n    s.assign(n,\"\");\n    pair<int,int>A,B;\n    for (int i=0;i<n;++i) {\n        cin>>s[i];\n        for (int j=0;j<m;++j){\n            if (s[i][j]=='A') A={i,j};\n            if (s[i][j]=='B') B={i,j};\n        }\n    }\n    vector<pair<int,char>> path(n*m);\n\n    if (bfs(A,path)) {\n        cout<<\"YES\\n\";\n        string pathTo;\n        while (B!=A) {\n            auto p = path[B.first*m+B.second];\n            pathTo.push_back(p.second);\n            B={p.first/m,p.first%m};\n        }\n        reverse(pathTo.begin(),pathTo.end());\n        cout<<pathTo.size()<<'\\n';\n        cout<<pathTo<<'\\n';\n    }\n    else{\n        cout<<\"NO\\n\";\n    }\n}\n\n\nint main()\n{\n    // fastio;\n    solve();\n\treturn 0;\n}\n\n",
//   "1194":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\nll MOD = 1000000007;\n\nvector <string> mat;\nqueue <pair<int,int>> mons;\nqueue <pair<int,int>> you;\nvector<vector<int>> dMons;\nvector<vector<int>> dYou;\nvector<vector<int>> path;\nint n,m;\n\nint dirx[] = {-1,1,0,0};\nint diry[] = {0,0,-1,1};\nchar dirName[] = {'U','D','L','R'};\nbool isExit(int x, int y) {\n\treturn x==0||y==0||x==n-1||y==m-1;\n}\n\nvoid printPath(int x,int y){\n\tstring p;\n\twhile (dYou[x][y]!=0){\n\t\tint i=path[x][y];\n\t\tp.push_back(dirName[i]);\n\t\tx-=dirx[i];y-=diry[i];\n\t}\n\treverse(p.begin(),p.end());\n\tcout<<p<<'\\n';\n}\n\nvoid solve(){\n\twhile (!mons.empty()) {\n\t\tauto v=mons.front();\n\t\tmons.pop();\n\t\t\n\t\tfor (int i=0;i<4;++i){\n\t\t\tint newx=v.first+dirx[i], newy=v.second+diry[i];\n\t\t\tif (newx>=n||newx<0||newy>=m||newy<0) continue;\n\t\t\tif (mat[newx][newy]=='#') continue;\n\t\t\tif (dMons[newx][newy]!=MOD) continue;\n\t\t\tdMons[newx][newy] = dMons[v.first][v.second]+1;\n\t\t\tmons.push(make_pair(newx,newy));\n\t\t}\n\t}\n\n\tpath=dYou;\n\twhile (!you.empty()){\n\t\tauto v = you.front();\n\t\tyou.pop();\n\t\t\n\t\tif (isExit(v.first,v.second)&&dYou[v.first][v.second] < dMons[v.first][v.second]) {\n\t\t\tcout<<\"YES\\n\";\n\t\t\tcout<<dYou[v.first][v.second]<<'\\n';\n\t\t\tprintPath(v.first,v.second);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i=0; i<4; ++i) {\n\t\t\tint newx=v.first+dirx[i], newy=v.second+diry[i];\n\t\t\tif (newx>=n||newx<0||newy>=m||newy<0) continue;\n\t\t\tif (mat[newx][newy]=='#') continue;\n\t\t\tif (dYou[newx][newy]!=MOD) continue;\n\t\t\tdYou[newx][newy] = dYou[v.first][v.second]+1;\n\t\t\tpath[newx][newy] = i;\n\t\t\tyou.push(make_pair(newx,newy));\n\t\t}\n\t}\n\tcout<<\"NO\\n\";\n}\n\nint main() {\n\tfastio;\n\tcin>>n>>m;\n\tmat.assign(n,\"\");\n\tdMons.assign(n,vector<int>(m,MOD));\n\tdYou.assign(n,vector<int>(m,MOD));\n\tfor (int i=0; i<n; ++i) {\n\t\tcin>>mat[i];\t\n\t\tfor (int j=0; j<m; ++j) {\n\t\t\tif (mat[i][j]=='M') {\n\t\t\t\tmons.push(make_pair(i,j));\n\t\t\t\tdMons[i][j]=0;\n\t\t\t}\n\t\t\telse if (mat[i][j]=='A') {\n\t\t\t\tyou.push(make_pair(i,j));\n\t\t\t\tdYou[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tsolve();\n\treturn 0;\n}",
//   "1195":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\n\nll INF = 1000000007;\nstruct edge{\n\tint to;\n\tll w;\n};\n\nvector <pair<ll,ll>> d;\nvector<vector<edge>>adjList;\nint n,m;\n\nll solve() {\n\tset <array<ll,3>> s;\n\ts.insert({0,0,0});\n\twhile (!s.empty()){\n\t\tint from=(*(s.begin()))[2];\n\t\ts.erase(s.begin());\n\t\tfor (edge &e:adjList[from]){\n\t\t\tbool flag=false;\n\t\t\tarray<ll,3> toDel={d[e.to].first,d[e.to].second,e.to};\n\t\t\tif (d[e.to].first>d[from].first+e.w){\n\t\t\t\tflag=true;\n\t\t\t\td[e.to].first=d[from].first+e.w;\n\t\t\t}\n\t\t\tif(d[e.to].second>min(d[from].first+e.w/2,d[from].second+e.w)){\n\t\t\t\tflag=true;\n\t\t\t\td[e.to].second=min(d[from].first+e.w/2,d[from].second+e.w);\n\t\t\t}\n\t\t\tif (flag){\n\t\t\t\ts.erase(toDel);\n\t\t\t\ts.insert({d[e.to].first,d[e.to].second,e.to});\n\t\t\t}\n\t\t}\n\t}\n\treturn d[n-1].second;\n}\n\nint main() {\n\tfastio;\n\tINF*=INF;\n\tcin>>n>>m;\n\td.assign(n,{INF,INF});\n\td[0]={0,0};\n\tadjList.assign(n,vector<edge>());\n\tfor (int i=0; i<m; ++i) {\n\t\tint a,b;\n\t\tll c;\n\t\tcin>>a>>b>>c;\n\t\t--a;--b;\n\t\tadjList[a].push_back(edge({b,c}));\n\t}\n\tcout<<solve()<<'\\n';\n\treturn 0;\n}",
//   "1196":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\n\nconst ll INF = 1e18;\nstruct edge{\n\tint to;\n\tll w;\n};\n\nvector<vector<edge>>adjList;\nint n,m,k;\n\nvoid solve() {\n\tmultiset <array<ll,2>> s;\n\tvector<multiset<ll>> D(n);\n\ts.insert({0,0});\n\tD[0].insert(0);\n\tfor (int i=0;i<n;++i) D[i].insert(INF);\n\twhile (!s.empty()){\n\t\tarray<ll,2> p=(*(s.begin()));\n\t\tint cur=p[1];\n\t\tll dfrom=p[0];\n\t\ts.erase(s.begin());\n\t\tfor (edge &e:adjList[cur]){\n\t\t\tif (*(prev(D[e.to].end()))>dfrom+e.w){\n\t\t\t\tif (D[e.to].size()==k) {\n\t\t\t\t\tll toDel=*prev(D[e.to].end());\n\t\t\t\t\tD[e.to].erase(prev(D[e.to].end()));\n\t\t\t\t\tif (toDel!=INF) s.erase(s.find({toDel,e.to}));\n\t\t\t\t}\n\t\t\t\tD[e.to].insert(dfrom+e.w);\n\t\t\t\ts.insert({dfrom+e.w,e.to});\n\t\t\t}\n\t\t}\n\t}\n\tfor(ll v:D[n-1]) cout<<v<<' ';\n}\n\nint main() {\n\tfastio;\n\tcin>>n>>m>>k;\n\tadjList.assign(n,vector<edge>());\n\tfor (int i=0; i<m; ++i) {\n\t\tint a,b;\n\t\tll c;\n\t\tcin>>a>>b>>c;\n\t\t--a;--b;\n\t\tadjList[a].push_back(edge({b,c}));\n\t}\n\tsolve();\n\treturn 0;\n}",
//   "1197":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\n\nconst ll INF = 1e18;\nstruct edge{\n\tint a,b;\n\tll w;\n};\n\nvector<edge> eL;\nvector<int> p;\nvector<ll> d;\nvector<bool> check;\nint n,m,x;\n\nbool solve(int root){\n\td.assign(n,INF);\n\td[root]=0;\n\tfor (int i=0;i<n;++i)\n\t{\t\n\t\tx=-1;\n\t\tfor (edge &e:eL){\n\t\t\tif (d[e.a]==INF) continue;\n\t\t\tif (d[e.b]>d[e.a]+e.w){\n\t\t\t\tx=e.b;\n\t\t\t\t::check[x]=true;\n\t\t\t\td[e.b]=d[e.a]+e.w;\n\t\t\t\tp[e.b]=e.a;\n\t\t\t}\n\t\t}\n\t\tif (x==-1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\t// fastio;\n\tcin>>n>>m;\n\tp.assign(n,-1);\n\t::check.assign(n,false);\n\tfor (int i=0;i<m;++i){\n\t\tll a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t--a;--b;\n\t\teL.push_back({a,b,c});\n\t}\n\tfor (int i=0;i<n;++i){\n\t\tif (::check[i]) continue;\n\t\tif (solve(i)){\n\t\t\tcout<<\"YES\\n\";\n\t\t\tvector<bool> check(n);\n\t\t\tvector<int> path;\n\t\t\twhile(true){\n\t\t\t\tif (check[x]) break;\n\t\t\t\tcheck[x]=true;\n\t\t\t\tx=p[x];\n\t\t\t}\n\t\t\tint y=p[x];\n\t\t\twhile(y!=x){\n\t\t\t\tpath.push_back(y);\n\t\t\t\ty=p[y];\n\t\t\t}\n\t\t\treverse(path.begin(),path.end());\n\t\t\tcout<<x+1;\n\t\t\tfor (int &v:path) cout<<' '<<v+1;\n\t\t\tcout<<' '<<x+1;\n\t\t\tcout<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"NO\\n\";\n\treturn 0;\n}\n",
//   "1202":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll INF=1e18;\nconst ll MOD=1000000007;\n\nstruct edge{\n\tint to;\n\tll w;\n};\nint n,m;\nvector<vector<edge>> adjList;\nvector<pair<ll,int>> d;\nint mn,mx;\n\nvoid solve(){\n\td[0]={0,1};\n\tset <pair<ll,int>> s;\n\tvector<pair<int,int>> dis(n,{-1,-1});\n\tdis[0]={0,0};\n\ts.insert({0,0});\n\twhile (!s.empty()) {\n\t\tauto p = *(s.begin());\n\t\ts.erase(s.begin());\n\t\tfor (edge &e:adjList[p.second]){\n\t\t\tll nw=p.first+e.w;\n\t\t\tif (d[e.to].first>nw) {\n\t\t\t\ts.erase({d[e.to].first,e.to});\n\t\t\t\td[e.to]={nw,d[p.second].second};\n\t\t\t\ts.insert({d[e.to].first,e.to});\n\t\t\t\t\n\t\t\t\tauto disFrom=dis[p.second];\t\t\t\t\n\t\t\t\tdis[e.to]={disFrom.first+1,disFrom.second+1};\n\t\t\t}\n\t\t\telse if (d[e.to].first==nw) {\n\t\t\t\td[e.to].second=(d[e.to].second+d[p.second].second)%MOD;\n\t\t\t\tauto disFrom=dis[p.second];\t\t\t\t\n\t\t\t\tdis[e.to]={min(disFrom.first+1,dis[e.to].first),max(disFrom.second+1,dis[e.to].second)};\n\t\t\t}\n\t\t}\n\t}\n\tmn=dis[n-1].first;mx=dis[n-1].second;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(NULL);\n\tcin>>n>>m;\n\tadjList.assign(n,vector<edge>());\n\td.assign(n,{INF,1});\n\tfor (int i=0;i<m;++i){\n\t\tint a,b;ll c;\n\t\tcin>>a>>b>>c;--a;--b;\n\t\tadjList[a].push_back(edge({b,c}));\n\t}\n\tsolve();\n\tcout<<d[n-1].first<<' '<<d[n-1].second<<' '<<mn<<' '<<mx<<'\\n';\n\treturn 0;\n}",
//   "1617":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\nusing namespace std;\r\nll md=1000000007;\r\nll expo (ll m, int e){\r\n\tif(!e) return 1;\r\n\tm%=md;\r\n\tif (e&1) return (m*expo(m*m,e>>1))%md;\r\n\treturn (expo(m*m,e>>1))%md;\t\r\n}\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tint e;\r\n\tcin>>e;\r\n\tcout<<expo(2,e)<<endl;\r\n\treturn 0;\r\n}",
//   "1618":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\nusing namespace std;\r\nll md=1000000007;\r\nll num5(int n){\r\n\tll re=0;\r\n\twhile (n){\r\n\t\tn/=5;\r\n\t\tre+=n;\r\n\t}\r\n\treturn re;\r\n}\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tint e;\r\n\tcin>>e;\r\n\tcout<<num5(e)<<endl;\r\n\treturn 0;\r\n}",
//   "1619":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define REP(i,a,b) for (int i=a;i<b;i++)\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\r\nusing namespace std;\r\nint main(){\r\n\tfastio;\r\n\tint n;\r\n\tcin>>n;\r\n\tvector<pair<int,int>>a;\r\n\tint temp;\r\n\tREP(i,0,n) {\r\n\t\tcin>>temp;a.push_back({temp,1});\r\n\t\tcin>>temp;a.push_back({temp,-1});\r\n\t}\r\n\tsort(all(a));\r\n\tint re=0, c=0;\r\n\tfor (auto p:a){\r\n\t\tc+=p.second;\r\n\t\tre=max(re,c);\r\n\t}\r\n\tcout<<re<<endl;\r\n\treturn 0;\r\n}",
//   "1620":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL)\r\nusing namespace std;\r\nint main(){\r\n\tfastio;\r\n\tint n,t;\r\n\tcin>>n>>t;\r\n\tdouble s=0;\r\n\tvector <int> arr(n);\r\n\tfor (int i=0;i<n;i++){\r\n\t\tcin>>arr[i];\r\n\t\ts+=1.0/arr[i];\r\n\t}\r\n\tlong long base=(double)t/s;\r\n\tlong long curr=0;\r\n\tmultiset <pair<int,int>> rem;\r\n\tfor (int i=0;i<n;i++){\r\n\t\tcurr+=base/arr[i];\r\n\t\trem.insert({arr[i]-base%arr[i],arr[i]});\r\n\t}\r\n\tlong long re=base;\r\n\tpair<int,int> tmp={0,0};\r\n\tfor(;curr<t;curr++){\r\n\t\ttmp=(*(rem.begin()));\r\n\t\trem.insert({tmp.first+tmp.second,tmp.second});\r\n\t\trem.erase(rem.begin());\r\n\t}\r\n\tre+=tmp.first;\r\n\tcout<<re<<'\\n';\r\n\treturn 0;\r\n}",
//   "1621":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define REP(i,a,b) for (int i=a;i<=b;i++)\r\nusing namespace std;\r\nvector <int> a(int(2e5)+10);\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tint t;\r\n\tcin>>t;\r\n\tREP(i,0,t-1) cin>>a[i];\r\n\tsort(a.begin(),a.begin()+t);\r\n\tvector<int>::iterator it=unique(a.begin(),a.begin()+t);\r\n\tcout<<it-a.begin()<<endl;\r\n\treturn 0;\r\n}",
//   "1622":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\nusing namespace std;\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tstring s;\r\n\tint k=1;\r\n\tunordered_map <char,int> m;\r\n\tcin>>s;\r\n\tfor (int i=1;i<=s.size();i++)k*=i;\r\n\tfor (auto c:s) m[c]++;\r\n\tfor (auto p:m){for(int i=2;i<=p.second;i++)k/=i;}\r\n\tsort(all(s));\r\n\tcout<<k<<endl;\r\n\tdo{\r\n\t\tcout<<s<<endl;\r\n\t}\r\n\twhile (next_permutation(all(s)));\r\n\treturn 0;\r\n}",
//   "1623":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\nusing namespace std;\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tint n;\r\n\tll re=INFINITY;\r\n\tll su=0;\r\n\tcin>>n;\r\n\tvector <ll> p (n);\r\n\tfor(int i=0;i<n;i++){cin>>p[i];su+=p[i];}\r\n\tfor (int i =1;i<1<<n;i++){\r\n\t\tll t=0;\r\n\t\tfor (int j=1;1<<j<=i;j++)if((1<<j)&i) t+=p[j];\r\n\t\tre=min(re,abs(2*t-su));\r\n\t}\r\n\tcout<<re<<endl;\r\n\treturn 0;\r\n}",
//   "1624":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define REP(i,a,b) for (int i=a;i<=b;i++)\r\nusing namespace std;\r\nbool board [8][8];\r\nint c=0;\r\n\r\nclass {\r\n\tbool col[8]{0};\r\n\tbool diagl[15]{0};\r\n\tbool diagr[15]{0};\r\n\tint toDiagL(int r, int c){\r\n\t\treturn r-c+7;\r\n\t}\r\n\tint toDiagR(int r, int c){\r\n\t\treturn r+c;\r\n\t}\r\npublic:\r\n\tbool checkAll(int r, int c){\r\n\t\treturn !(col[c] || diagl[toDiagL(r,c)]||diagr[toDiagR(r,c)]);\r\n\t}\r\n\tvoid setAll(int r, int c){\r\n\t\tcol[c]=diagl[toDiagL(r,c)]=diagr[toDiagR(r,c)]=1;\r\n\t}\r\n\tvoid resetAll(int r, int c){\r\n\t\tcol[c]=diagl[toDiagL(r,c)]=diagr[toDiagR(r,c)]=0;\r\n\t}\t\r\n} check;\r\nvoid recu(int r){\r\n\tif (r==8) c++;\r\n\telse{\r\n\t\tREP(i,0,7){\r\n\t\t\tif (board[r][i]) continue;\r\n\t\t\tif (!check.checkAll(r,i)) continue;\r\n\t\t\tcheck.setAll(r,i);\r\n\t\t\trecu(r+1);\r\n\t\t\tcheck.resetAll(r,i);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tstring s;\r\n\tREP (i,0,7){\r\n\t\tcin>>s;\r\n\t\tREP(j,0,7)\r\n\t\t{\r\n\t\t\tif (s[j]=='.') board[i][j]=0;\r\n\t\t\telse board[i][j]=1;\r\n\t\t}\r\n\t}\r\n\trecu(0);\r\n\tcout<<c<<endl;\r\n\treturn 0;\r\n}",
//   "1625":
//     "#include <bits/stdc++.h>\n#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\n#define ll long long\n#define MOD 1000000007;\nusing namespace std;\n\n\n\nvoid solve(){\n    int n;\n    cin>>n;\n    vector<vector<ll>> dp(n+1,vector<ll>(n+1));\n    vector<string>s(n);\n    for (int i=0;i<n;++i) cin>>s[i];\n    dp[1][1]=1;\n    for (int i=1;i<=n;++i){\n        for (int j=1;j<=n;++j){\n            dp[i][j]=(dp[i][j]+dp[i-1][j]+dp[i][j-1])%MOD;\n            if (s[i-1][j-1]=='*') dp[i][j]=0;\n        }\n    }\n    cout<<dp[n][n]<<'\\n';\n}\n\nint main()\n{\n    fastio;\n    solve();\n\treturn 0;\n}\n\n",
//   "1628":
//     '#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint main(){\n\tint n;\n\tll x;\n\tcin>>n>>x;\n\tvector<int>a(n);\n\tfor (int&v:a)cin>>v;\n\tvector<ll>s1,s2;\n\tint sz1=n/2,sz2=n-sz1;\n\tfor (int i=(1<<sz1)-1;i>=0;--i){\n\t\tll s=0;\n\t\tfor (int j=0;i>=(1<<j);++j){\n\t\t\tif (i&(1<<j)) s+=a[j];\n\t\t}\n\t\t// cout<<"s1: "<<s<<endl;\n\t\ts1.push_back(s);\n\t}\n\tfor (int i=(1<<sz2)-1;i>=0;--i){\n\t\tll s=0;\n\t\tfor (int j=0;i>=(1<<j);++j){\n\t\t\tif (i&(1<<j)) s+=a[sz1+j];\n\t\t}\n\t\t// cout<<"s2: "<<s<<endl;\n\t\ts2.push_back(s);\n\t}\n\tsort(s2.begin(),s2.end());\n\tll re=0;\n\tfor (ll &v:s1){\n\t\tll tg = x-v;\n\t\tre+=upper_bound(s2.begin(),s2.end(),tg)-lower_bound(s2.begin(),s2.end(),tg);\n\t}\n\tcout<<re<<\'\\n\';\n\treturn 0;\n}',
//   "1629":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define REP(i,a,b) for (int i=a;i<b;i++)\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\r\nusing namespace std;\r\nint main(){\r\n\tfastio;\r\n\tint n;\r\n\tcin>>n;\r\n\tvector<pair<int,int>>a(n);\r\n\tREP(i,0,n) cin>>a[i].second>>a[i].first;\r\n\tsort(all(a));\r\n\tint re=1, end=a[0].first;\r\n\tREP(i,1,n){\r\n\t\tif (a[i].second>=end){\r\n\t\t\tre++;end=a[i].first;\r\n\t\t}\r\n\t}\r\n\tcout<<re<<endl;\r\n\treturn 0;\r\n}",
//   "1630":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL)\r\nusing namespace std;\r\nint main(){\r\n\tfastio;\r\n\tll re=0;\r\n\tint n,tmp;\r\n\tcin>>n;\r\n\tvector <int> a(n);\r\n\tfor (int i=0;i<n;i++){\r\n\t\tcin>>a[i]>>tmp;\r\n\t\tre+=tmp;\r\n\t}\r\n\tsort(all(a));\r\n\tfor(ll i=0;i<n;i++)re-=(n-i)*a[i];\r\n\tcout<<re<<'\\n';\r\n\treturn 0;\r\n}",
//   "1631":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\nusing namespace std;\r\nint main(){\r\n\tfastio;\r\n\tll re=0;\r\n\tint n,tmp,m=0;\r\n\tcin>>n;\r\n\tfor (int i=0;i<n;i++){\r\n\t\tcin>>tmp;\r\n\t\tm=max(m,tmp);\r\n\t\tre+=tmp;\r\n\t}\r\n\tm<<=1;\r\n\tif (n==1 || re<m) re=m;\r\n\tcout<<re<<'\\n';\r\n\treturn 0;\r\n}",
//   "1632":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n    fastio;\r\n    int n,k;\r\n    cin>>n>>k;\r\n    vector <pair<int,int>> a(n);\r\n    for (int i=0;i<n;i++) cin>>a[i].second>>a[i].first;\r\n    sort(all(a));\r\n    vector <pair<int,pair<bool,int>>>b(2*n);\r\n    for (int i=0;i<n;i++){\r\n        b[i*2]={a[i].second,{true,i}};\r\n        b[i*2+1]={a[i].first,{false,i}};\r\n    }\r\n    sort(all(b));\r\n    int ans=0;\r\n    set <int> s;\r\n    for (auto v: b){\r\n        int x,isBeg,pos;\r\n        x=v.first;isBeg=v.second.first;pos=v.second.second;\r\n        if(isBeg) s.insert(pos);\r\n        else {\r\n            set<int>::iterator it;\r\n            it=s.find(pos);\r\n            if (it!=s.end()) {\r\n              ans++;\r\n              s.erase(it);  \r\n            }\r\n        }\r\n        if (s.size()>k) s.erase(prev(s.end()));\r\n    }\r\n    cout<<ans<<'\\n';\r\n    return 0;\r\n}",
//   "1633":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\n# define MOD 1000000007\r\nusing namespace std;\r\nint n;\r\nll dp [(int)(1e6+1.5)]{0};\r\nint main(){\r\n\tfastio;\r\n\tcin>>n;\r\n\tfor (int i=0;i<=6;i++)dp[i]=1;\r\n\tfor (int i=2;i<=n;i++){\r\n\t\tfor (int j=min(6,i-1);j>=1;--j){\r\n\t\t\t\tdp[i]=(dp[i]+dp[i-j])%MOD;\r\n\t\t}\r\n\t}\r\n\tcout<<dp[n]<<'\\n';\r\n\treturn 0;\r\n}",
//   "1634":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\r\n# define ten6 (1e6+1.5)\r\nusing namespace std;\r\n\r\nll dp [(int)ten6]{0};\r\nvector <int> c;\r\nll solve (int x){\r\n    if (x==0) return 0;\r\n    if (dp[x]) return dp[x];\r\n    ll re=ten6;\r\n    for (auto v:c) {\r\n        if (v>x) continue;\r\n        re=min(re,1+solve(x-v));\r\n    }\r\n    return dp[x]=re;\r\n}\r\n\r\nint main()\r\n{\r\n    fastio;\r\n    int n,x;\r\n    cin>>n>>x;\r\n    c.assign(n,0);\r\n    for (auto &v:c){\r\n        cin>>v;\r\n        dp[v]=1;\r\n    }\r\n    ll re=solve(x);\r\n    if (re<(ll)(ten6))\r\n    cout<<solve(x)<<'\\n';\r\n    else cout<<-1<<'\\n';\r\n    return 0;    \r\n}",
//   "1635":
//     "# include <bits/stdc++.h>\n# define ll long long\n# define all(x) x.begin(), x.end()\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\n# define MOD 1000000007\n# define ten6 1000002\nusing namespace std;\n \nll dp[ten6]={0};\nint main()\n{\n    fastio;\n    int n, k;\n    cin>>n>>k;\n    vector<int>lsCoins(n);\n    for (int i=0;i<n;i++) cin>>lsCoins[i];\n    dp[0]=1;\n    for (int target=1;target<=k;target++){\n        for (int v:lsCoins){\n            if (target>=v)\n            dp[target]=(dp[target]+dp[target-v])%MOD;\n        }\n    }\n    cout<<dp[k]<<'\\n';\n      return 0;\n}",
//   "1636":
//     '# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\r\n# define MOD 1000000007\r\n# define ten6 1000002\r\n\r\nusing namespace std;\r\nvector <int> dp;\r\nint n;\r\nint lsCoins[101];\r\nint main()\r\n{\r\n    // auto start=chrono::high_resolution_clock::now();\r\n    fastio;\r\n    int x;\r\n    cin>>n>>x;\r\n    dp.assign(x+1,0);\r\n    for (int i=0;i<n;i++)  cin>>lsCoins[i];\r\n    dp[0]=1;\r\n    sort(lsCoins,lsCoins+n);\r\n    for (int pos =0;pos<n;pos++)\r\n    for (int target=lsCoins[pos];target<=x;target++){\r\n        dp[target]=(dp[target]+dp[target-lsCoins[pos]])%MOD;\r\n    }\r\n    cout<<dp[x]<<\'\\n\';\r\n    // auto stop=chrono::high_resolution_clock::now();\r\n    // cout<<"Took: "<<chrono::duration_cast<chrono::milliseconds>(stop-start).count()<<" ms\\n";\r\n    return 0;\r\n}',
//   "1637":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\r\n# define MOD 1000000007\r\n# define ten6 1000002\r\n\r\nusing namespace std;\r\nint main()\r\n{\r\n    fastio;\r\n    int x;\r\n    cin>>x;\r\n    vector <int> ten (7);\r\n    ten[0]=1;\r\n    int mxDig=x%10;\r\n    for (int i = 1;i<7;i++) {\r\n        ten[i]=10*ten[i-1];\r\n        mxDig=max(mxDig,x/ten[i-1]%10);\r\n    }\r\n    int cnt=0;\r\n    while (x){\r\n        x-=mxDig;\r\n        mxDig=x%10;\r\n        for (int i = 1;i<7;i++) {\r\n        mxDig=max(mxDig,x/ten[i-1]%10);\r\n        }\r\n        cnt++;\r\n    }\r\n    cout<<cnt<<'\\n';\r\n    return 0;\r\n}",
//   "1638":
//     "#include <bits/stdc++.h>\n#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\n#define ll long long\n#define MOD 1000000007;\nusing namespace std;\n\n\n\nvoid solve(){\n    int n;\n    cin>>n;\n    vector<vector<ll>> dp(n+1,vector<ll>(n+1));\n    vector<string>s(n);\n    for (int i=0;i<n;++i) cin>>s[i];\n    dp[1][1]=1;\n    for (int i=1;i<=n;++i){\n        for (int j=1;j<=n;++j){\n            dp[i][j]=(dp[i][j]+dp[i-1][j]+dp[i][j-1])%MOD;\n            if (s[i-1][j-1]=='*') dp[i][j]=0;\n        }\n    }\n    cout<<dp[n][n]<<'\\n';\n}\n\nint main()\n{\n    fastio;\n    solve();\n\treturn 0;\n}\n\n",
//   "1639":
//     '# include <bits/stdc++.h>\n# define ll long long\n# define all(x) x.begin(), x.end()\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\n# define MOD 1000000007\n# define ten6 1000002\nusing namespace std;\nvector<vector<int>> dp;\nint l1,l2;\nstring s1,s2;\n\nint main()\n{\n    // freopen("test_input.txt","r",stdin);\n    fastio; \n    cin>>s1>>s2;\n    if (s1.size()>s2.size()) swap(s1,s2);\n    l1=s1.size();l2=s2.size();\n    dp.assign(l1,vector<int>(l2,0));\n    for (int i=0;i<l1;++i)\n        for (int k=0;k<l2;++k)\n            dp[i][k]=max(i+1,k+1);\n    for (int i=0; i<l1; ++i) {\n        for (int k=0; k<l2; ++k) {\n            if (i>0&&k>0) dp[i][k]=min(dp[i][k],dp[i-1][k-1]+1);\n            if (s1[i]==s2[k]) --dp[i][k];\n            if (k>0)dp[i][k]=min(dp[i][k],dp[i][k-1]+1);\n            if (i>0)dp[i][k]=min(dp[i][k],dp[i-1][k]+1);\n        }\n    }\n    cout<<dp[l1-1][l2-1]<<\'\\n\';\n    return 0;\n}',
//   "1640":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define REP(i,a,b) for (int i=a;i<b;i++)\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\r\nusing namespace std;\r\nint main(){\r\n\tfastio;\r\n\tint n,x;\r\n\tcin>>n>>x;\r\n\tvector <pair<int,int>> a(n);\r\n\tREP(i,0,n) {\r\n\t\tcin>>a[i].first;\r\n\t\ta[i].second=i+1;\r\n\t}\r\n\tsort(all(a));\r\n\tfor (int l=0,r=n-1;l<r;){\r\n\t\tint s=a[l].first+a[r].first;\r\n\t\tif(s==x){\r\n\t\t\tcout<<a[l].second<<' '<<a[r].second<<'\\n';\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (s<x) l++;\r\n\t\telse r--;\r\n\t}\r\n\tcout<<\"IMPOSSIBLE\\n\";\r\n\treturn 0;\r\n}",
//   "1641":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\nusing namespace std;\r\nint main(){\r\n\tfastio;\r\n\tint n,x;\r\n\tcin>>n>>x;\r\n\tvector <pair<int,int>> a(n),b;\r\n\tfor (int i=1;i<=n;i++){\r\n\t\tcin>>a[i-1].first;\r\n\t\ta[i-1].second=i;\r\n\t}\r\n\tsort(all(a));\r\n\tfor (int i=0;i<n;i++){\r\n\t\tauto a1=a[i];\r\n\t\tint tg=x-a1.first,l=i+1,r=n-1;\r\n\t\twhile(l<r){\r\n\t\t\tint tmp=a[l].first+a[r].first;\r\n\t\t\tif (tmp>tg)r--;\r\n\t\t\telse if (tmp<tg) l++;\r\n\t\t\telse{\r\n\t\t\t\tcout<<a1.second<<' '<<a[l].second<<' '<<a[r].second<<'\\n';\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout<<\"IMPOSSIBLE\\n\";\r\n\treturn 0;\r\n}",
//   "1642":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\nconst int MOD = 1000000007;\n\nint main(){\n\tfastio;\n\tint n,x;\n\tcin>>n>>x;\n\tvector<pair<int,int>> arr(n);\n\tfor (int i=0;i<n;++i) {\n\t\tcin>>arr[i].first;\n\t\tarr[i].second=i+1;\n\t}\n\tsort(arr.begin(),arr.end());\n\tfor (int l1=0;l1<n;++l1){\n\tfor (int r1=l1+3;r1<n;++r1){\n\t\tint l2=l1+1,r2=r1-1;\n\t\tint tmp=arr[l1].first+arr[r1].first;\n\t\twhile (l2<r2){\n\t\t\tint curr=arr[l2].first+arr[r2].first+tmp;\n\t\t\tif (curr==x) {\n\t\t\t\tcout<<arr[l1].second<<' '<<arr[l2].second<<' '<<arr[r2].second<<' '<<arr[r1].second<<'\\n';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if (curr<x) ++l2;\n\t\t\telse --r2;\n\t\t}\n\t}\n\t}\n\tcout<<\"IMPOSSIBLE\\n\";\n    return 0;\n}",
//   "1643":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define REP(i,a,b) for (int i=a;i<b;i++)\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\r\nusing namespace std;\r\n\r\nint main(){\r\n\tfastio;\r\n\tint n;cin>>n;\r\n\tll Min=0;\r\n\tll re=-1e18;\r\n\tint temp;\r\n\tll sum=0;\r\n\tfor (int i=0;i<n;i++){\r\n\t\tcin>>temp;\r\n\t\tsum+=temp;\r\n\t\tre=max(re,sum-Min);\r\n\t\tMin=min(sum,Min);\r\n\t}\r\n\tcout<<re<<endl;\r\n\treturn 0;\r\n}",
//   "1644":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n    fastio;\r\n    int n,a,b;\r\n    cin>>n>>a>>b;\r\n    vector<int> arr(n);\r\n    vector <ll> acuSum(n+1);\r\n    for(int i=0;i<n;i++) {\r\n        cin>>arr[i];\r\n        acuSum[i+1]=acuSum[i]+arr[i];\r\n    }\r\n    multiset<ll> ms;\r\n    ll currMax=-1e18;\r\n    ll re=-1e18;\r\n    for (int i=0;i<=n;i++){\r\n        if (i>=a){\r\n            if (i>b) {\r\n                multiset<ll>::iterator it=ms.find(acuSum[i-b-1]);\r\n               ms.erase(it);\r\n            } \r\n            ms.insert(acuSum[i-a]);\r\n            \r\n            re=max(re,acuSum[i]-*ms.begin());\r\n            \r\n        }\r\n    }\r\n    cout<<re<<'\\n';\r\n    return 0;\r\n}",
//   "1645":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\nusing namespace std;\r\nint main(){\r\n\tfastio;\r\n\tint n,tmp,pre;\r\n\tcin>>n;\r\n\tvector <int> dsu (n+1);\r\n\tiota(all(dsu),-1);\r\n\tvector <int> s(n);\r\n\tcin>>s[0];cout<<0;\r\n\tfor (int i=1;i<n;i++){\r\n\t\tcin>>s[i];\r\n\t\twhile (dsu[i]!=-1&&s[dsu[i]]>=s[i]){\r\n\t\t\tdsu[i]=dsu[dsu[i]];\r\n\t\t}\r\n\t\tcout<<' '<<dsu[i]+1;\r\n\t}\r\n\tcout<<'\\n';\r\n\treturn 0;\r\n}",
//   "1646":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\n# define MOD 1000000007\r\nusing namespace std;\r\nint main(){\r\n\tfastio;\r\n\tint n,q;\r\n\tcin>>n>>q;\r\n\tvector <ll> a(n+1);\r\n\tfor (int i=1;i<=n;i++){\r\n\t\tcin>>a[i];\r\n\t\ta[i]+=a[i-1];\r\n\t}\r\n\tint x,y;\r\n\tfor (int i=0;i<q;i++){\r\n\t\tcin>>x>>y;\r\n\t\tcout<<a[y]-a[x-1]<<'\\n';\r\n\t}\r\n\treturn 0;\r\n}",
//   "1647":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\n# define MOD 1000000007\r\nusing namespace std;\r\nvector<int> st;\r\nvector<int> arr;\r\nvoid build(int v,int tl,int tr){\r\n\tif (tl==tr){\r\n\t\tst[v]=arr[tl];\r\n\t}\r\n\telse{\r\n\t\tint mid=tl+tr>>1;\r\n\t\tbuild(v*2,tl,mid);\r\n\t\tbuild(v*2+1,mid+1,tr);\r\n\t\tst[v]=min(st[v*2],st[v*2+1]);\r\n\t}\r\n}\r\nint get(int v,int tl,int tr,int l , int r){\r\n\tif (tl==l&&tr==r) return st[v];\r\n\tif (tl>r||tr<l) return -1;\r\n\tint mid=tl+tr>>1;\r\n\tint x=get(v*2,tl,mid,l,min(mid,r)),y=get(v*2+1,mid+1,tr,max(l,mid+1),r);\r\n\tif (x==-1)return y;\r\n\tif (y==-1) return x;\r\n\treturn min(x,y);\r\n\r\n}\r\nint main(){\r\n\tfastio;\r\n\tint n,q;\r\n\tcin>>n>>q;\r\n\tst.assign(4*n,0);\r\n\tarr.assign(n,0);\r\n\tfor (auto & v:arr)cin>>v;\r\n\tbuild(1,0,n-1);\r\n\tint x,y;\r\n\tfor (int i=0;i<q;i++){\r\n\t\tcin>>x>>y;\r\n\t\tcout<<get(1,0,n-1,x-1,y-1)<<'\\n';\r\n\t}\r\n\treturn 0;\r\n}",
//   "1648":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\n# define MOD 1000000007\r\nusing namespace std;\r\nvector<ll> st;\r\nvector<int> arr;\r\nvoid build(int v,int tl,int tr){\r\n\tif (tl==tr){\r\n\t\tst[v]=arr[tl];\r\n\t}\r\n\telse{\r\n\t\tint mid=(tl+tr)>>1;\r\n\t\tbuild(v*2,tl,mid);\r\n\t\tbuild(v*2+1,mid+1,tr);\r\n\t\tst[v]=st[v*2]+st[v*2+1];\r\n\t}\r\n}\r\nll get(int v,int tl,int tr,int l , int r){\r\n\tif (tl==l&&tr==r) return st[v];\r\n\tif (tl>r||tr<l) return -1;\r\n\tint mid=(tl+tr)>>1;\r\n\tll x=get(v*2,tl,mid,l,min(mid,r)),y=get(v*2+1,mid+1,tr,max(l,mid+1),r);\r\n\tif (x==-1)return y;\r\n\tif (y==-1) return x;\r\n\treturn x+y;\r\n\r\n}\r\nvoid update(int v,int tl,int tr,int & pos,int & val){\r\n\tif(tl==tr){\r\n\t\tst[v]=val;\r\n\t}\r\n\telse {\r\n\t\tint mid = (tl+tr)>>1;\r\n\t\tif (pos<=mid) update(v*2,tl,mid,pos,val);\r\n\t\telse update(v*2+1,mid+1,tr,pos,val);\r\n\t\tst[v]=st[v*2]+st[v*2+1];\r\n\t}\r\n}\r\nint main(){\r\n\tfastio;\r\n\tint n,q;\r\n\tcin>>n>>q;\r\n\tst.assign(4*n,0);\r\n\tarr.assign(n,0);\r\n\tfor (auto & v:arr)cin>>v;\r\n\tbuild(1,0,n-1);\r\n\tint k,x,y;\r\n\tfor (int i=0;i<q;i++){\r\n\t\tcin>>k>>x>>y;\r\n\t\tif (k==2)\r\n\t\tcout<<get(1,0,n-1,x-1,y-1)<<'\\n';\r\n\t\telse {\r\n\t\t\tx--;\r\n\t\t\tupdate(1,0,n-1,x,y);\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}",
//   "1649":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\n# define MOD 1000000007\r\nusing namespace std;\r\nvector<ll> st;\r\nvector<int> arr;\r\nvoid build(int v,int tl,int tr){\r\n\tif (tl==tr){\r\n\t\tst[v]=arr[tl];\r\n\t}\r\n\telse{\r\n\t\tint mid=(tl+tr)>>1;\r\n\t\tbuild(v*2,tl,mid);\r\n\t\tbuild(v*2+1,mid+1,tr);\r\n\t\tst[v]=min(st[v*2],st[v*2+1]);\r\n\t}\r\n}\r\nll get(int v,int tl,int tr,int l , int r){\r\n\tif (tl==l&&tr==r) return st[v];\r\n\tif (tl>r||tr<l) return -1;\r\n\tint mid=(tl+tr)>>1;\r\n\tll x=get(v*2,tl,mid,l,min(mid,r)),y=get(v*2+1,mid+1,tr,max(l,mid+1),r);\r\n\tif (x==-1)return y;\r\n\tif (y==-1) return x;\r\n\treturn min(x,y);\r\n\r\n}\r\nvoid update(int v,int tl,int tr,int & pos,int & val){\r\n\tif(tl==tr){\r\n\t\tst[v]=val;\r\n\t}\r\n\telse {\r\n\t\tint mid = (tl+tr)>>1;\r\n\t\tif (pos<=mid) update(v*2,tl,mid,pos,val);\r\n\t\telse update(v*2+1,mid+1,tr,pos,val);\r\n\t\tst[v]=min(st[v*2],st[v*2+1]);\r\n\t}\r\n}\r\nint main(){\r\n\tfastio;\r\n\tint n,q;\r\n\tcin>>n>>q;\r\n\tst.assign(4*n,0);\r\n\tarr.assign(n,0);\r\n\tfor (auto & v:arr)cin>>v;\r\n\tbuild(1,0,n-1);\r\n\tint k,x,y;\r\n\tfor (int i=0;i<q;i++){\r\n\t\tcin>>k>>x>>y;\r\n\t\tif (k==2)\r\n\t\tcout<<get(1,0,n-1,x-1,y-1)<<'\\n';\r\n\t\telse {\r\n\t\t\tx--;\r\n\t\t\tupdate(1,0,n-1,x,y);\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}",
//   "1650":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\n# define MOD 1000000007\r\nusing namespace std;\r\nvector <int> st;\r\nvector <int> arr;\r\nint n;\r\n\r\nvoid build(int v,  int tl,int tr){\r\n\tif (tl==tr){\r\n\t\tst[v]=arr[tl];\r\n\t}\r\n\telse{\r\n\t\tint mid = (tl+tr)>>1;\r\n\t\tbuild(v*2,tl,mid);\r\n\t\tbuild(v*2+1,mid+1,tr);\r\n\t\tst[v]=st[v*2]^st[v*2+1];\r\n\t}\r\n}\r\n\r\nint get(int v, int tl ,int tr, int l , int r){\r\n\tif(tl==l&&tr==r) return st[v];\r\n\tif (tl>r||tr<l) return 0;\r\n\tint mid=(tl+tr)>>1;\r\n\treturn get(v*2,tl,mid,l,min(mid,r))^get(v*2+1,mid+1,tr,max(mid+1,l),r);\t\r\n}\r\n\r\nint main(){\r\n\tfastio;\r\n\tint q;\r\n\tcin>>n>>q;\r\n\tarr.assign(n,0);\r\n\tst.assign(4*n,0);\r\n\tfor (auto&v:arr)cin>>v;\r\n\tbuild(1,0,n-1);\r\n\tint a,b;\r\n\tfor (int i=0;i<q;i++){\r\n\t\tcin>>a>>b;\r\n\t\tcout<<get(1,0,n-1,a-1,b-1)<<'\\n';\r\n\t}\r\n\treturn 0;\r\n}",
//   "1651":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\n# define MOD 1000000007\r\nusing namespace std;\r\nvector <ll> st;\r\nvector <int> arr;\r\nint n;\r\n\r\n\r\nvoid update(int v, int tl ,int tr, int l , int r, int val){\r\n\tif(tl==l&&tr==r) {\r\n\t\tst[v]+=val;\r\n\t\treturn;\r\n\t}\r\n\tif (tl>r||tr<l) return;\r\n\tint mid=(tl+tr)>>1;\r\n\tupdate(v*2,tl,mid,l,min(mid,r),val);\r\n\tupdate(v*2+1,mid+1,tr,max(mid+1,l),r,val);\t\r\n}\r\n\r\nll get(int v, int tl ,int tr, int pos){\r\n\tif(tl==tr) return st[v];\r\n\tint mid=(tl+tr)>>1;\r\n\tll re=st[v];\r\n\tif (mid>=pos)return re+get(v*2,tl,mid,pos);\r\n\telse return re+get(v*2+1,mid+1,tr,pos);\r\n}\r\n\r\nint main(){\r\n\tfastio;\r\n\tint q;\r\n\tcin>>n>>q;\r\n\tarr.assign(n,0);\r\n\tst.assign(4*n,0);\r\n\tfor (auto&v:arr)cin>>v;\r\n\tint k,a,b,u,pos;\r\n\tfor (int i=0;i<q;i++){\r\n\t\tcin>>k;\r\n\t\tif (k==1) {\r\n\t\t\tcin>>a>>b>>u;\r\n\t\t\tupdate(1,0,n-1,a-1,b-1,u);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>pos;\r\n\t\t\tpos--;\r\n\t\t\tcout<<get(1,0,n-1,pos)+arr[pos]<<'\\n';\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}",
//   "1652":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint n,q;\nvector<vector<int>> F;\n\nint sum(int r,int c){\n\tif (r<0||c<0) return 0;\n\tint re=0;\n\tfor (int i=r;i>=0;i=(i&(i+1))-1){\n\t\tfor (int j=c;j>=0;j=(j&(j+1))-1){\n\t\t\tre+=F[i][j];\n\t\t}\n\t}\n\treturn re;\n}\n\nvoid increase(int r,int c,int num){\n\tfor (int i=r;i<n;i=i|(i+1)){\n\t\tfor (int j=c;j<n;j=j|(j+1)){\n\t\t\tF[i][j]+=num;\n\t\t}\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n>>q;\n\tF.assign(n,vector<int>(n,0));\n\tstring s;\n\tfor (int i=0;i<n;++i) {\n\t\tcin>>s;\n\t\tfor (int j=0;j<n;++j){\n\t\t\tif (s[j]=='*') increase(i,j,1);\n\t\t}\n\t}\n\tfor (int i=0;i<q;++i){\n\t\tint r1,c1,r2,c2;\n\t\tcin>>r1>>c1>>r2>>c2;--r1;--c1;--r2;--c2;\n\t\tcout<<sum(r2,c2)-sum(r2,c1-1)-sum(r1-1,c2)+sum(r1-1,c1-1)<<'\\n';\n\t}\n\treturn 0;\n}\n",
//   "1653":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nvector<pair<int,ll>> dp;\nvector<ll> arr;\nint n;\nll x,mx;\n\npair<int,ll> get(ll currW, ll state) {\n\tif (dp[state].first==-1) {\n        pair<int,ll> re = {n+1,0LL};\n        for (ll i=0;i<n;++i) {\n            if (state & (1LL<<i)) continue;\n            re=min(re,get(arr[i],state|(1LL<<i)));\n        }\n        dp[state] = re;\n    }\n    ll w = dp[state].second+currW;\n    if (w<=x) return {dp[state].first,w};\n    return {dp[state].first+1,min(dp[state].second,currW)};\n}\n \nint main() {\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n>>x;\n\tmx=(1LL<<n);\n\tarr.assign(n,0LL);\n\tdp.assign(mx,{-1,0LL});\n\tfor (ll &v:arr) cin>>v;\n\tdp[mx-1]={0,0LL};\n\tcout<<get(0LL,0LL).first+1<<'\\n';\n\treturn 0;\n}",
//   "1655":
//     "#include <bits/stdc++.h>\n#define fastio ios::sync_with_stdio(false);cin.tie(NULL)\n#define ll long long\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\nusing namespace std;\n\nstruct Trie{\n\tstruct Node {\n\t\tint idx=-1;\n\t\tNode* arr[2]={nullptr,nullptr};\n\t};\n\tNode* root=new Node;\n\tvoid add(int y,int idx){\n\t\tNode* cur=root;\n\t\tfor (int i=20;i>=0;--i){\n\t\t\tif ((1<<i)&y){\n\t\t\t\tif (!cur->arr[1]) cur->arr[1]=new Node;\n\t\t\t\tcur=cur->arr[1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!cur->arr[0]) cur->arr[0]=new Node;\n\t\t\t\tcur=cur->arr[0];\n\t\t\t}\n\t\t}\n\t\tcur->idx=idx;\n\t}\n\tint get(int y){\n\t\tNode* cur=root;\n\t\tfor (int i=20;i>=0;--i){\n\t\t\tif (!((1<<i)&y)){\n\t\t\t\tif (cur->arr[1]!=nullptr) {\n\t\t\t\t\tcur=cur->arr[1];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcur=cur->arr[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (cur->arr[0]!=nullptr) {\n\t\t\t\t\tcur=cur->arr[0];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcur=cur->arr[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cur->idx;\n\t}\n};\n\n\nint main(){\n\tfastio;\n\tint n;\n\tcin>>n;\n\tvector<int> a(n);\n\tfor (int &v:a) cin>>v;\n\tvector<int> b(n+1);\n\tfor (int i=0;i<n;++i) b[i+1]=b[i]^a[i];\n\tTrie t;\n\tfor (int i=0;i<=n;++i) t.add(b[i],i);\n\tint mx=0;\n\tfor (int i=0;i<=n;++i) {\n\t\tmx=max(mx,b[i]^b[t.get(b[i])]);\n\t}\n\tcout<<mx<<'\\n';\n}",
//   "1660":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\nusing namespace std;\r\nint main(){\r\n\tfastio;\r\n\tint n,tmp;\r\n\tll x;\r\n\tcin>>n>>x;\r\n\tvector <ll> s(n+1);\r\n\tfor (int i=1;i<=n;i++){\r\n\t\tcin>>tmp;\r\n\t\ts[i]=tmp+s[i-1];\r\n\t}\r\n\tsort(s.begin()+1,s.end());\r\n\tint l=0,r=0;\r\n\tll re=0;\r\n\twhile(l<=n&&r<=n){\r\n\t\tll tg=s[r]-s[l];\r\n\t\tif (tg<x) r++;\r\n\t\telse if (tg>x) l++;\r\n\t\telse {\r\n\t\t\tll a=1,b=1;\r\n\t\t\twhile (l<n&&s[l+1]==s[l]){l++;a++;}\r\n\t\t\tl++;\r\n\t\t\twhile (r<n&&s[r+1]==s[r]){r++;b++;}\r\n\t\t\tr++;\r\n\t\t\tre+=a*b;\r\n\t\t}\r\n\t}\r\n\tcout<<re<<'\\n';\r\n\treturn 0;\r\n}",
//   "1661":
//     "# include <bits/stdc++.h>\n# define ll long long\n# define all(x) x.begin(), x.end()\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\nusing namespace std;\nint main(){\n\tfastio;\n\tint n,tmp;\n\tll x;\n\tcin>>n>>x;\n\tvector <ll> s(n+1);\n\tfor (int i=1;i<=n;i++){\n\t\tcin>>tmp;\n\t\ts[i]=tmp+s[i-1];\n\t}\n\tll re=0;\n\tmap <ll,int> m;\n\tfor (int i=n;i>=0;i--){\n\t\tre+=m[s[i]+x];\n\t\tm[s[i]]++;\n\t}\n\tcout<<re<<'\\n';\n\treturn 0;\n}",
//   "1662":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\nusing namespace std;\r\nint main(){\r\n\tfastio;\r\n\tint n,tmp;\r\n\tcin>>n;\r\n\tvector <ll> s(n+1);\r\n\tfor (int i=1;i<=n;i++){\r\n\t\tcin>>tmp;\r\n\t\ts[i]=tmp+s[i-1];\r\n\t}\r\n\tll re=0;\r\n\tunordered_map <ll,int> m;\r\n\tm.reserve(n+1);\r\n\tfor (int i=n;i>=0;i--){\r\n\t\ttmp=s[i]%n;\r\n\t\tif (tmp<0)tmp+=n;\r\n\t\tif (m.find(tmp)!=m.end()) re+=m[tmp];\r\n\t\tm[tmp]++;\r\n\t}\r\n\tcout<<re<<'\\n';\r\n\treturn 0;\r\n}",
//   "1666":
//     "# include <bits/stdc++.h>\n# define ll long long\n# define all(x) x.begin(), x.end()\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\n# define MOD 1000000007\n# define ten6 1000002\nusing namespace std;\nint n, m;\nvector<vector<int>> adList; \nvector<bool> visited;\nint cnt;\nvoid dfs(int x) {\n    visited[x]=true;\n    for (int v:adList[x]) {\n        if (visited[v]) continue;\n        dfs(v);\n    }\n}\nint main()\n{\n    fastio;\n    cin>>n>>m;\n    adList.assign(n,vector<int>());\n    visited.assign(n,false);\n    for (int i=0;i<m;++i){\n        int x,y;\n        cin>>x>>y;--x;--y;\n        adList[x].push_back(y);\n        adList[y].push_back(x);\n    }\n    vector<pair<int,int>> ls;\n    for (int i=0;i<n;++i) {\n        if (visited[i]) continue;\n        if (i>0) ls.push_back({i-1,i}); \n        dfs(i);\n    }\n    cout<<ls.size()<<'\\n';\n    for (auto p:ls) cout<<p.first+1<<' '<<p.second+1<<'\\n';\n    return 0;\n}",
//   "1667":
//     "# include <bits/stdc++.h>\n# define ll long long\n# define all(x) x.begin(), x.end()\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n# define MOD 1000000007\nusing namespace std;\n \nint n,m;\nvector <vector<int>> adList;\nvector <bool> visit;\nvector<int> p;\nqueue <int> q;\n\t\nbool bfs(int start,vector<int>&path){\n    p.assign(n,0);\n    visit.assign(n,0);\n    q.push(start);\n    visit[start]=true;\n    bool connect=false;\n\twhile (!q.empty()){\n\t\tint v=q.front();\n        if (v==n-1) {\n            connect=true;\n            break;\n        }\n\t\tq.pop();\n\t\tfor (int &u:adList[v]){\n\t\t\tif (visit[u]) continue;\n\t\t\tvisit[u]=true;\n\t\t\tp[u]=v;\n\t\t\tq.push(u);\n\t\t}\n\t}\n    if (!connect) return false;\n    int tmp=n-1;\n    while (tmp!=0){\n        path.push_back(tmp);\n        tmp=p[tmp];\n    }\n    reverse(path.begin(),path.end());\n    return true;\n}\nint main(){\n\tfastio;\n\tcin>>n>>m;\n\tadList.assign(n,vector<int>());\n    int x,y;\n\tfor (int i=0;i<m;++i){\n\t\tcin>>x>>y;x--;y--;\n\t\tadList[x].push_back(y);\n\t\tadList[y].push_back(x);\n\t}\n    vector<int> path;\n    if (bfs(0,path)){\n        cout<<path.size()+1<<'\\n';\n        cout<<1;\n        for (int &v:path){\n            cout<<' '<<v+1;\n        }\n        cout<<'\\n';\n    }\n    else cout<<\"IMPOSSIBLE\\n\";\n\treturn 0;\n}\n\n",
//   "1668":
//     "# include <bits/stdc++.h>\n# define ll long long\n# define all(x) x.begin(), x.end()\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n# define MOD 1000000007\nusing namespace std;\n \nint n,m;\nvector <vector<int>> adList;\nvector <bool> visit;\nvector<int> p;\n\t\nbool bfs(int start){\n    queue <int> q;\n    q.push(start);\n    visit[start]=true;\n\twhile (!q.empty()){\n\t\tint v=q.front();\n\t\tq.pop();\n\t\tfor (int &u:adList[v]){\n\t\t\tif (visit[u]) {\n                if (p[u]==p[v]) return false;\n                continue;\n            }\n\t\t\tvisit[u]=true;\n\t\t\tp[u]=(p[v]+1)%2;\n\t\t\tq.push(u);\n\t\t}\n\t}\n    return true;\n}\nint main(){\n\tfastio;\n\tcin>>n>>m;\n\tadList.assign(n,vector<int>());\n    visit.assign(n,0);\n    p.assign(n,-1);\n    int x,y;\n\tfor (int i=0;i<m;++i){\n\t\tcin>>x>>y;x--;y--;\n\t\tadList[x].push_back(y);\n\t\tadList[y].push_back(x);\n\t}\n    for (int start=0;start<n;++start){\n        if (visit[start]) continue;\n        p[start]=0;\n        visit[start]=true;\n        if (!bfs(start)){\n            cout<<\"IMPOSSIBLE\\n\";\n            return 0;\n        }\n    }\n    for (int i=0;i<n;++i) {\n        if (i!=0) cout<<' ';\n        cout<<p[i]+1;\n    }\n    cout<<'\\n';\n\treturn 0;\n}\n\n",
//   "1669":
//     "# include <bits/stdc++.h>\n# define ll long long\n# define all(x) x.begin(), x.end()\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n# define MOD 1000000007\nusing namespace std;\n \nint n,m;\nvector <vector<int>> adList;\nvector <bool> visit;\nvector <bool> marked;\nvector<int> path;\n\t\nbool dfs(int curr, vector<int>&eulerPath,int p){\n    marked[curr]=true;\n    eulerPath.push_back(curr);\n    for (int &v:adList[curr]) {\n        if (visit[v]) {\n            if (p!=v&&marked[v]) {\n                path.push_back(v);\n                int eusz=eulerPath.size();\n                int tmp=eusz-1;\n                while (eulerPath[tmp]!=v){\n                    path.push_back(eulerPath[tmp]);\n                    --tmp;\n                }\n                path.push_back(v);\n                return true;\n            }\n            continue;\n        }\n        visit[v]=true;\n        if (dfs(v,eulerPath,curr)) return true;\n    }\n    marked[curr]=false;\n    eulerPath.pop_back();\n    return false;\n}\nint main(){\n\tfastio;\n\tcin>>n>>m;\n\tadList.assign(n,vector<int>());\n    visit.assign(n,0);\n    marked.assign(n,0);\n    int x,y;\n\tfor (int i=0;i<m;++i){\n\t\tcin>>x>>y;x--;y--;\n\t\tadList[x].push_back(y);\n\t\tadList[y].push_back(x);\n\t}\n    vector<int>eulerPath;\n    for (int start=0;start<n;++start){\n        if (visit[start]) continue;\n        visit[start]=true;\n        if (dfs(start,eulerPath,-1)) {\n                cout<<path.size()<<'\\n';\n                for (int i=0;i<path.size();++i) {\n                    if (i!=0) cout<<' ';\n                    cout<<path[i]+1;\n                }\n                cout<<'\\n';\n                return 0;\n        }\n    }\n    cout<<\"IMPOSSIBLE\\n\";\n\n\treturn 0;\n}\n\n",
//   "1671":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\n\nll MOD = 1000000007;\n\nstruct edge {\n\tint to;\n\tll w;\n};\n\nvector<vector<edge>> adjList;\nint n,m;\n\nint main() {\n\tMOD*=MOD;\n\tcin>>n>>m;\n\tadjList.assign(n,vector<edge>());\n\tfor (int i=0; i<m; ++i) {\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t--a;--b;\n\t\tadjList[a].push_back(edge({b,(ll)c}));\n\t}\n\t\n\t// map<ll,int> m;\n\tset<pair<ll,int>> m;\n\tvector<ll> d (n,MOD);\t\n\td[0]=0;\n\n\tm.insert(pair<ll,int>(0LL,0));\n\n\twhile (!m.empty()) {\n\t\tint curr = m.begin()->second;\n\t\tm.erase(m.begin());\n\n\t\tfor (edge &e: adjList[curr]) {\n\t\t\tif (d[e.to]>d[curr]+e.w){\n\t\t\t\tm.erase({d[e.to],e.to});\n\t\t\t\td[e.to]=d[curr]+e.w;\n\t\t\t\tm.insert(pair<ll,int>(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tfor (int i=0;i<n;++i){\n\t\tif (i!=0) cout<<' ';\n\t\tcout<<d[i];\n\t}\n\tcout<<'\\n';\n\treturn 0;\n}",
//   "1672":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\n\nll MOD = 1000000007;\n\nvector <vector<ll>> d;\nint n,m,q;\n\nint main() {\n\tfastio;\n\tMOD*=MOD;\n\tcin>>n>>m>>q;\n\td.assign(n,vector<ll>(n,MOD));\n\tfor (int i=0;i<n;++i) d[i][i]=0;\n\tfor (int i=0; i<m; ++i) {\n\t\tint a,b;\n\t\tll c;\n\t\tcin>>a>>b>>c;\n\t\t--a;--b;\n\t\td[a][b]=d[b][a]=min(d[a][b],c);\n\t}\n\t\n\tfor (int i=0; i<n; ++i) {\n\t\tfor (int j=0;j<n; ++j){\n\t\t\tfor (int k=j+1; k<n; ++k) {\n\t\t\t\tif (d[j][i]==MOD || d[i][k]==MOD) continue;\n\t\t\t\td[k][j] = d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i=0;i<q;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;--b;\n\t\tif (d[a][b]!=MOD)\n\t\tcout<<d[a][b]<<'\\n';\n\t\telse cout<<-1<<'\\n';\n\t}\n\tcout<<'\\n';\n\treturn 0;\n}",
//   "1673":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\n\nll INF = 1000000007;\nstruct edge{\n\tint from;\n\tint to;\n\tll w;\n};\n\nvector <ll> d;\nvector <edge> eL;\nvector<vector<int>>adjList;\nint n,m;\n\nll solve() {\n\tfor (int i=0;i<n-1;++i){\n\t\tfor (int j=0;j<m;++j){\n\t\t\tif (d[eL[j].from]!=INF && d[eL[j].from]+eL[j].w<d[eL[j].to]){\n\t\t\t\td[eL[j].to]=d[eL[j].from]+eL[j].w;\n\t\t\t} \n\t\t}\n\t}\n\tvector<int> check(n);\n\tfor (int j=0;j<m;++j){\n\t\tif (d[eL[j].from]!=INF && d[eL[j].from]+eL[j].w<d[eL[j].to]){\n\t\t\tcheck[eL[j].to]=1;\n\t\t\td[eL[j].to]=d[eL[j].from]+eL[j].w;\n\t\t} \n\t}\n\tqueue<int>q,q1;\n\tq.push(0);\n\twhile(!q.empty()){\n\t\tint s=q.front();\n\t\tq.pop();\n\t\tif (check[s]==2) continue;\n\t\tif (check[s]==1) q1.push(s);\n\t\tcheck[s]=2;\n\t\tfor (int &v:adjList[s]) q.push(v);\n\t}\n\twhile(!q1.empty()){\n\t\tint s=q1.front();\n\t\tif (s==n-1) return -1;\n\t\tq1.pop();\n\t\tif (check[s]==3) continue;\n\t\tcheck[s]=3;\n\t\tfor (int &v:adjList[s]) q1.push(v);\n\t}\n\treturn -d[n-1];\n}\n\nint main() {\n\tfastio;\n\tINF*=INF;\n\tcin>>n>>m;\n\td.assign(n,INF);\n\td[0]=0;\n\tadjList.assign(n,vector<int>());\n\tfor (int i=0; i<m; ++i) {\n\t\tint a,b;\n\t\tll c;\n\t\tcin>>a>>b>>c;\n\t\t--a;--b;c=-c;\n\t\teL.push_back(edge({a,b,c}));\n\t\tadjList[a].push_back(b);\n\t}\n\tcout<<solve()<<'\\n';\n\treturn 0;\n}",
//   "1674":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\r\n# define MOD 1000000007\r\nusing namespace std;\r\n\r\nint n;\r\nvector <vector<int>> adj;\r\nvector <bool> visit;\r\nvector <ll> ans;\r\nll dfs(int v){\r\n\tll re=0;\r\n\tfor (auto u:adj[v]){\r\n\t\tif (visit[u]) continue;\r\n\t\tvisit[u]=true;\r\n\t\tre+=dfs(u);\r\n\t}\r\n\treturn ans[v]=re+1;\r\n}\r\n\r\nint main(){\r\n\tfastio;\r\n\tcin>>n;\r\n\tadj.assign(n,vector<int>());\r\n\tvisit.assign(n,false);\r\n\tans.assign(n,0);\r\n\tint tmp;\r\n\tfor (int i=1;i<n;i++){\r\n\t\tcin>>tmp;\r\n\t\ttmp--;\r\n\t\tadj[tmp].push_back(i);\r\n\t}\r\n\tdfs(0);\r\n\tcout<<ans[0]-1;\r\n\tfor (int i=1;i<n;i++){\r\n\t\tcout<<' '<<ans[i]-1;\r\n\t}\r\n\tcout<<'\\n';\r\n\treturn 0;\r\n}",
//   "1675":
//     '#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1000000007;\nint n,m;\nvector<array<int,3>> eL;\nvector<int> p;\nvector<int> sz;\nll re;\n\nint find(int x){\n\treturn p[x]=(x==p[x])?x:find(p[x]);\n}\n\nvoid uni(int a, int b){\n\tint x=find(a),y=find(b);\n\tif (x==y) return;\n\tif (sz[x]>sz[y]) {\n\t\tp[y]=x;\n\t\tsz[x]+=sz[y];\n\t}\n\telse {\n\t\tp[x]=y;\n\t\tsz[y]+=sz[x];\n\t}\n}\n\nbool solve(){\n\tp.assign(n,0);\n\tiota(p.begin(),p.end(),0);\n\tsz.assign(n,1);\n\tre=0;\n\tfor (auto &arr:eL) {\n\t\tint a=find(arr[1]),b=find(arr[2]);\n\t\tif (a==b) continue;\n\t\telse uni(a,b);\n\t\tre+=arr[0];\n\t}\n\treturn sz[find(0)]==n;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(NULL);\n\tcin>>n>>m;\n\tfor (int i=0;i<m;++i){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;--a;--b;\n\t\teL.push_back({c,a,b});\n\t}\n\tsort(eL.begin(),eL.end());\n\tif (solve()) cout<<re;\n\telse cout<<"IMPOSSIBLE";\n\treturn 0;\n}',
//   "1676":
//     "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1000000007;\nint n,m;\nvector<array<int,2>> eL;\nvector<int> p;\nvector<int> sz;\nint re,cc;\n\nint find(int x){\n\treturn p[x]=(x==p[x])?x:find(p[x]);\n}\n\nint uni(int a, int b){\n\tint x=find(a),y=find(b);\n\tif (x==y) return sz[x];\n\tif (sz[x]>sz[y]) {\n\t\tp[y]=x;\n\t\treturn sz[x]+=sz[y];\n\t}\n\telse {\n\t\tp[x]=y;\n\t\treturn sz[y]+=sz[x];\n\t}\n}\n\nvoid solve(){\n\tp.assign(n,0);\n\tiota(p.begin(),p.end(),0);\n\tsz.assign(n,1);\n\tre=1;cc=n;\n\tfor (auto &arr:eL) {\n\t\tint a=find(arr[0]),b=find(arr[1]);\n\t\tif (a!=b) {\n\t\t\tre=max(re,uni(a,b));\n\t\t\t--cc;\n\t\t}\n\t\tcout<<cc<<' '<<re<<'\\n';\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(NULL);\n\tcin>>n>>m;\n\tfor (int i=0;i<m;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;--a;--b;\n\t\teL.push_back({a,b});\n\t}\n\tsolve();\n\treturn 0;\n}",
//   "1678":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\n\nconst ll INF = 1e18;\n\nvector<vector<int>>adjList;\nvector<int>color;\nvector<int>p;\nint n,m;\nint dfs(int curr){\n\tcolor[curr]=1;\n\tfor (int &v:adjList[curr]){\n\t\tif (color[v]==2) continue;\n\t\tp[v]=curr;\n\t\tif (color[v]==1) return v;\n\t\tint tmp=dfs(v);\n\t\tif (tmp!=-1) return tmp;\n\t}\n\tcolor[curr]=2;\n\treturn -1;\n}\n\nvoid solve() {\n\tcolor.assign(n,0);\n\tp.assign(n,-1);\n\tint x=-1;\n\tfor (int i=0;i<n;++i){\n\t\tif (color[i]) continue;\n\t\tx=dfs(i);\n\t\tif (x!=-1) break;\n\t}\n\tif (x==-1){\n\t\tcout<<\"IMPOSSIBLE\";\n\t\treturn;\n\t}\n\tvector<int>path;\n\tint y=p[x];\n\twhile (y!=x) {\n\t\tpath.push_back(y);\n\t\ty=p[y];\n\t}\n\treverse(path.begin(),path.end());\n\tcout<<path.size()+2<<'\\n';\n\tcout<<x+1;\n\tfor (int&v:path)cout<<' '<<v+1;\n\tcout<<' '<<x+1;\n}\n\nint main() {\n\tfastio;\n\tcin>>n>>m;\n\tadjList.assign(n,vector<int>());\n\tfor (int i=0; i<m; ++i) {\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;--b;\n\t\tadjList[a].push_back(b);\n\t}\n\tsolve();\n\treturn 0;\n}",
//   "1679":
//     "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nvector<vector<int>> adjList;\nvector<int> color;\nvector<int> path;\n\nbool dfs(int curr){\n\tcolor[curr]=1;\n\tfor(int &v:adjList[curr]){\n\t\tif (color[v]==2) continue;\n\t\tif (color[v]==1 || dfs(v)) return true;\n\t}\n\tcolor[curr]=2;\n\tpath.push_back(curr);\n\treturn false;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(NULL);\n\tcin>>n>>m;\n\tadjList.assign(n,vector<int>());\n\tcolor.assign(n,0);\n\tfor (int i=0;i<m;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;--a;--b;\n\t\tadjList[a].push_back(b);\n\t}\n\tfor (int i=0;i<n;++i){\n\t\tif (color[i]) continue;\n\t\tif (dfs(i)) {\n\t\t\tcout<<\"IMPOSSIBLE\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i=n-1;i>=0;--i) cout<<path[i]+1<<' ';\n\treturn 0;\n}",
//   "1680":
//     "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nvector<vector<int>> adjList;\nvector<int> p;\nvector<int> d;\nint dfs(int curr){\n\td[curr]=-2;\n\tint re=-1;\n\tfor (int &v:adjList[curr]){\n\t\tif (d[v]==-2) continue; // can't reach\n\t\tint nxt;\n\t\tif (d[v]==-1){\t\t\t// not tried\n\t\t\tnxt = dfs(v);\n\t\t\tif (nxt==-2) continue;\t// can't reach\n\t\t}\n\t\telse nxt=d[v];\t\t\t\t// has tried already\n\t\tif (re<nxt) {\n\t\t\tre=nxt;\n\t\t\tp[curr]=v;\n\t\t}\n\t}\n\tif (re!=-1) d[curr]=re+1;\n\treturn d[curr];\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(NULL);\n\tcin>>n>>m;\n\tadjList.assign(n,vector<int>());\n\td.assign(n,-1);\n\tp.assign(n,-1);\n\tfor (int i=0;i<m;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;--a;--b;\n\t\tadjList[a].push_back(b);\n\t}\n\td[n-1]=0;\n\tdfs(0);\n\tvector<int> path;\n\tint y=0;\n\twhile (y!=n-1&&y!=-1){\n\t\tpath.push_back(y);\n\t\ty=p[y];\n\t}\n\tif (y==n-1){\n\t\tcout<<1+path.size()<<'\\n';\n\t\tfor (int &v:path) cout<<v+1<<' ';\n\t\tcout<<n;\n\t}\n\telse cout<<\"IMPOSSIBLE\";\n\treturn 0;\n}",
//   "1681":
//     "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1000000007;\nint n,m;\nvector<vector<int>> adjList;\nvector<ll> p;\n\nll dfs(int curr){\n\tp[curr]=0;\n\tll &re=p[curr];\n\tfor (int &v:adjList[curr]){\n\t\tif (p[v]!=-1) {\n\t\t\tre=(re+p[v])%MOD;\n\t\t\tcontinue;\n\t\t}\n\t\tre=(re+dfs(v))%MOD;\n\t}\n\treturn re;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(NULL);\n\tcin>>n>>m;\n\tadjList.assign(n,vector<int>());\n\tp.assign(n,-1);\n\tp[n-1]=1;\n\tfor (int i=0;i<m;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;--a;--b;\n\t\tadjList[a].push_back(b);\n\t}\n\tcout<<dfs(0);\n\treturn 0;\n}",
//   "1682":
//     "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1000000007;\nint n,m;\nvector<vector<int>> g1,g2;\nvector<int> p;\nvector<int> order;\nint cnt;\n\nvoid dfs1(int curr){\n\tp[curr]=1;\n\tfor (int &v:g1[curr]){\n\t\tif (p[v]) continue;\n\t\tdfs1(v);\n\t}\n\torder.push_back(curr);\n}\n\n\nvoid dfs2(int curr){\n\tp[curr]=2;\n\tfor (int &v:g2[curr]){\n\t\tif (p[v]==2) continue;\n\t\tdfs2(v);\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(NULL);\n\tcin>>n>>m;\n\tg1.assign(n,vector<int>());\n\tg2.assign(n,vector<int>());\n\tfor (int i=0;i<m;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;--a;--b;\n\t\tg1[a].push_back(b);\n\t\tg2[b].push_back(a);\n\t}\n\tp.assign(n,0);\n\tfor (int i=0;i<n;++i){\n\t\tif (p[i]) continue;\n\t\tdfs1(i);\n\t}\n\tcnt=0;\n\tfor (int i=n-1;i>=0;--i){\n\t\tif (p[order[i]]==2) continue;\n\t\tdfs2(order[i]);\n\t\t++cnt;\n\t\tif (cnt>1) {\n\t\t\tcout<<\"NO\\n\";\n\t\t\tcout<<order[i]+1<<' '<<order[i+1]+1<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"YES\";\n\treturn 0;\n}",
//   "1683":
//     "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1000000007;\nint n,m;\nvector<vector<int>> g1,g2;\nvector<int> p,order,re;\nint cnt;\n\nvoid dfs1(int curr){\n\tp[curr]=1;\n\tfor (int &v:g1[curr]){\n\t\tif (p[v]) continue;\n\t\tdfs1(v);\n\t}\n\torder.push_back(curr);\n}\n\n\nvoid dfs2(int curr){\n\tp[curr]=2;\n\tre[curr]=cnt;\n\tfor (int &v:g2[curr]){\n\t\tif (p[v]==2) continue;\n\t\tdfs2(v);\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(NULL);\n\tcin>>n>>m;\n\tg1.assign(n,vector<int>());\n\tg2.assign(n,vector<int>());\n\tfor (int i=0;i<m;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;--a;--b;\n\t\tg1[a].push_back(b);\n\t\tg2[b].push_back(a);\n\t}\n\tp.assign(n,0);\n\tfor (int i=0;i<n;++i){\n\t\tif (p[i]) continue;\n\t\tdfs1(i);\n\t}\n\tcnt=1;\n\tre.assign(n,-1);\n\tfor (int i=n-1;i>=0;--i){\n\t\tif (p[order[i]]==2) continue;\n\t\tdfs2(order[i]);\n\t\t++cnt;\n\t}\n\tcout<<cnt-1<<'\\n';\n\tfor (int &v:re) cout<<v<<' ';\n\treturn 0;\n}",
//   "1684":
//     "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,q;\nvector<vector<int>> neg,pos;\nvector<int> ans1,ans2;\n\nbool dfs(int cur, bool isPos,vector<int>&ans){\n\tbool re=true;\n\tif (ans[cur]) return (ans[cur]>0&&isPos)||(ans[cur]<0&&!isPos);\n\tans[cur]=(isPos)?1:-1;\n\tif (isPos) {\n\t\tfor(int &v:pos[cur]){\n\t\t\tif (v>0) re=re&&dfs(v-1,true,ans);\n\t\t\telse re=re&&dfs(abs(v)-1,false,ans);\n\t\t}\n\t}\n\telse {\n\t\tfor(int &v:neg[cur]){\n\t\t\tif (v>0) re=re&&dfs(v-1,true,ans);\n\t\t\telse re=re&&dfs(abs(v)-1,false,ans);\n\t\t}\t\n\t}\n\treturn re;\n}\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>q>>n;\n\tneg.assign(n,vector<int>());\n\tpos.assign(n,vector<int>());\n\n\tfor (int i=0;i<q;++i){\n\t\tint a,b;char ca,cb;\n\t\tcin>>ca>>a>>cb>>b;\n\t\ta=a*((ca=='-')*-2+1);\n\t\tb=b*((cb=='-')*-2+1);\n\t\tif (b<0) pos[-b-1].push_back(a);\n\t\telse neg[b-1].push_back(a);\n\t\tif (a<0) pos[-a-1].push_back(b);\n\t\telse neg[a-1].push_back(b);\n\t}\n\n\tans1.assign(n,0);\n\tans2.assign(n,0);\n\tvector<int> ans(n,0);\n\tfor (int i=0;i<n;++i){\n\t\tif (ans[i]) continue;\n\t\tif(dfs(i,true,ans1)) \n\t\t\tdfs(i,true,ans);\n\t\telse if (dfs(i,false,ans2))\n\t\t\tdfs(i,false,ans);\n\t\telse {\n\t\t\tcout<<\"IMPOSSIBLE\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i=0;i<n;++i){\n\t\tif (ans[i]>0) cout<<\"+ \";\n\t\telse cout<<\"- \";\n\t}\n\tcout<<'\\n';\n\treturn 0;\n}",
//   "1686":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint n,m,cnt;\nvector<int> coins;\nvector<vector<int>> adj1,adj2;\nvector<ll> coins2;\nvector<bool> vis;\nvector<int> ord,par;\n\nvoid dfs1(int x){\n\tvis[x]=1;\n\tfor (int &v:adj1[x]){\n\t\tif (!vis[v]) dfs1(v);\n\t}\n\tord.push_back(x);\n}\n\nvoid dfs2(int x,const int &r){\n\tvis[x]=1;\n\tpar[x]=cnt;\n\tfor (int &v:adj2[x]){\n\t\tif (!vis[v]) dfs2(v,r);\n\t}\n}\n\nll dfs(int i){\n\tll re=0;\n\tvis[i]=true;\n\tfor (int &v:adj2[i]){\n\t\tif (vis[v]) re=max(re,coins2[v]);\n\t\telse re=max(re,dfs(v));\n\t}\n\treturn coins2[i]=re+coins2[i];\n}\nint main(){\n\tcin>>n>>m;\n\tcoins.assign(n,0);\n\tadj1.assign(n,vector<int>());\n\tadj2.assign(n,vector<int>());\n\tfor (int &v:coins)cin>>v;\n\tfor (int i=0;i<m;++i){\n\t\tint a,b;cin>>a>>b;--a;--b;\n\t\tadj1[a].push_back(b);\n\t\tadj2[b].push_back(a);\n\t}\n\tvis.assign(n,false);\n\tfor (int i=0;i<n;++i) {\n\t\tif (!vis[i]) dfs1(i);\n\t}\n\tvis.clear();vis.assign(n,false);\n\tpar.assign(n,0);\n\tcnt=0;\n\tfor (int i=n-1;i>=0;--i){\n\t\tif (!vis[ord[i]]) {\n\t\t\tdfs2(ord[i],ord[i]);\n\t\t\t++cnt;\n\t\t}\n\t}\n\tvis.clear();vis.assign(cnt,false);\n\tadj2.clear();adj2.assign(cnt,vector<int>());\n\tcoins2.assign(cnt,0);\n\tfor (int i=0;i<n;++i){\n\t\tcoins2[par[i]]+=coins[i];\n\t\tfor (int &v:adj1[i]) \n\t\t\tif (par[i]!=par[v]) adj2[par[i]].push_back(par[v]);\n\t}\n\tll re=0;\n\tfor (int i=0;i<cnt;++i){\n\t\tif (vis[i]) continue;\n\t\tre=max(re,dfs(i));\n\t}\n\tcout<<re<<'\\n';\n\treturn 0;\n}",
//   "1687":
//     "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adjList;\nint up[(int)(2e5+1.5)][20] {};\nint n,q;\n\nvoid dfs(int curr,int pre){\n\tup[curr][0]=pre;\n\tfor (int i=1;i<20;++i){\n\t\tif (up[curr][i-1]==-1) up[curr][i]=-1;\n\t\telse up[curr][i]=up[up[curr][i-1]][i-1];\n\t}\n\tfor (int &v:adjList[curr]){\n\t\tdfs(v,curr);\n\t}\n}\n\nint get(int node,int pos){\n\tfor (int i=19;i>=0;--i){\n\t\tif (node==-1) return node;\n\t\tif ((1<<i)&pos) \n\t\t\t{\n\t\t\t\tnode=up[node][i];\n\t\t\t}\n\t}\n\treturn node;\n}\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n>>q;\n\tadjList.assign(n,vector<int>());\n\tfor (int i=1;i<n;++i){\n\t\tint a;cin>>a;\n\t\tadjList[a-1].push_back(i);\n\t}\n\tdfs(0,-1);\n\tfor (int i=0;i<q;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;--a;\n\t\tint x=get(a,b);\n\t\tcout<<(x==-1?-1:x+1)<<'\\n';\n\t}\n\treturn 0;\n}",
//   "1688":
//     "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adjList;\nint up[(int)(2e5+1.5)][20] {};\nvector<int>tin,tout;\nint n,q,timer;\n\nvoid dfs(int curr,int pre){\n\ttin[curr]=timer++;\n\tup[curr][0]=pre;\n\tfor (int i=1;i<20;++i){\n\t\tup[curr][i]=up[up[curr][i-1]][i-1];\n\t}\n\tfor (int &v:adjList[curr]){\n\t\tdfs(v,curr);\n\t}\n\ttout[curr]=timer++;\n}\n\nbool is_ancestor(int par,int child){\n\treturn tin[par]<=tin[child]&&tout[par]>=tout[child];\n}\n\nint lca(int n1,int n2){\n\tif (is_ancestor(n1,n2)) return n1;\n\tif (is_ancestor(n2,n1)) return n2;\n\tfor (int i=19;i>=0;--i){\n\t\tif (!is_ancestor(up[n1][i],n2)) n1=up[n1][i];\n\t}\n\treturn up[n1][0];\n}\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n>>q;\n\tadjList.assign(n,vector<int>());\n\ttin.assign(n,-1);\n\ttout.assign(n,-1);\n\ttimer=0;\n\tfor (int i=1;i<n;++i){\n\t\tint a;cin>>a;\n\t\tadjList[a-1].push_back(i);\n\t}\n\tdfs(0,0);\n\tfor (int i=0;i<q;++i){\n\t\tint a,b;\n\t\tcin>>a>>b;--a;--b;\n\t\tcout<<lca(a,b)+1<<'\\n';\n\t}\n\treturn 0;\n}",
//   "1691":
//     '#include <bits/stdc++.h>\n#define fastio ios::sync_with_stdio(false);cin.tie(NULL)\n#define ll long long\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\nusing namespace std;\nvector<vector<array<int,2>>> adj;\nvector<vector<bool>> vis;\nint m,n;\nint pre=-1;\nvector<int> re;\n// euler circuit\t\nvoid dfs(int cur){\n    while (sz(adj[cur])){\n        int u=adj[cur].back()[0],nxtj=adj[cur].back()[1],i=sz(adj[cur])-1;\n        adj[cur].pop_back();\n        if (vis[cur][i]) continue;\n        vis[u][nxtj]=true;\n        dfs(u);\n    }\n\tre.push_back(cur);\n}\nint main(){\n\tfastio;\n\tcin>>n>>m;\n    adj.assign(n,vector<array<int,2>>());\n\tfor (int i=0;i<m;++i){\n\t\tint x,y;cin>>x>>y;--x;--y;\n        adj[y].push_back({x,sz(adj[x])});\n        adj[x].push_back({y,sz(adj[y])-1});\n\t}\n\tfor (int i=0;i<n;++i){\n        if (sz(adj[i])%2){\n            cout<<"IMPOSSIBLE\\n";\n            exit(0);\n        }\n    }\n    for (int i=0;i<n;++i){\n        vis.push_back(vector<bool>(sz(adj[i]),false));\n    }\n    dfs(0);\n    if (sz(re)!=m+1){\n        cout<<"IMPOSSIBLE\\n";\n        exit(0);\n    }\n    for (auto&s:re) cout<<s+1<<\' \';\n\n}',
//   "1694":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll INF=1e18;\nvector<vector<ll>> cap;\nvector<vector<int>> adj;\nvector<int> par;\nint n,m;\n\nll bfs(){\n\tfill(par.begin(), par.end(),-1);\n\tqueue<array<ll,2>> q;\n\tq.push({0,INF});\n\twhile (!q.empty()){\n\t\tauto p=q.front();\n\t\tq.pop();\n\t\tfor (int &v:adj[p[0]]){\n\t\t\tif(par[v]!=-1) continue;\n\t\t\tif (cap[p[0]][v]){\n\t\t\t\tpar[v]=p[0];\n\t\t\t\tll nxt=min(p[1],cap[p[0]][v]);\n\t\t\t\tif (v==n-1) return nxt;\n\t\t\t\tq.push({(ll)v,nxt});\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tcin>>n>>m;\n\tcap.assign(n,vector<ll>(n,0));\n\tadj.assign(n,vector<int>());\n\tpar.assign(n,-1);\n\tfor (int i=0;i<m;++i){\n\t\tint a,b;ll c;cin>>a>>b>>c;--a;--b;\n\t\tcap[a][b]+=c;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tll x,re=0;\n\twhile (x=bfs()){\n\t\tint cur=n-1;\n\t\twhile (cur!=0){\n\t\t\tcap[par[cur]][cur]-=x;\n\t\t\tcap[cur][par[cur]]+=x;\n\t\t\tcur=par[cur];\n\t\t}\n\t\tre+=x;\n\t}\n\tcout<<re<<'\\n';\n\treturn 0;\n}",
//   "1695":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll INF=1e18;\nvector<vector<ll>> cap;\nvector<vector<int>> adj;\nvector<int> scut;\nvector<int> par;\nint n,m;\n\nbool bfs(){\n\tfill(par.begin(), par.end(),-1);\n\tqueue<int> q;\n\tq.push(0);\n\tpar[0]=0;\n\twhile (!q.empty()){\n\t\tint p=q.front();\n\t\tq.pop();\n\t\tfor (int &v:adj[p]){\n\t\t\tif(par[v]!=-1) continue;\n\t\t\tif (cap[p][v]){\n\t\t\t\tpar[v]=p;\n\t\t\t\tif (v==n-1) return true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nvoid dfs(int cur){\n\tpar[cur]=1;\n\tscut.push_back(cur);\n\tfor (int&v:adj[cur]){\n\t\tif (par[v]==1) continue;\n\t\tif (cap[cur][v]) dfs(v);\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tcap.assign(n,vector<ll>(n,0));\n\tadj.assign(n,vector<int>());\n\tpar.assign(n,-1);\n\tfor (int i=0;i<m;++i){\n\t\tint a,b;cin>>a>>b;--a;--b;\n\t\tcap[a][b]+=1;\n\t\tcap[b][a]+=1;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tint re=0;\n\twhile (bfs()){\n\t\tre+=1;\n\t\tint cur=n-1;\n\t\twhile (cur!=0){\n\t\t\tcap[par[cur]][cur]-=1;\n\t\t\tcap[cur][par[cur]]+=1;\n\t\t\tcur=par[cur];\n\t\t}\n\t}\n\tfill(par.begin(), par.end(),-1);\n\tdfs(0);\n\tcout<<re<<'\\n';\n\tfor (int &x:scut){\n\t\tfor (int &v:adj[x]){\n\t\t\tif (par[v]==1) continue;\n\t\t\tif (!cap[x][v]) {\n\t\t\t\tcout<<x+1<<' '<<v+1<<'\\n';\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
//   "1696":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll INF=1e18;\nvector<vector<ll>> cap;\nvector<vector<int>> adj;\nvector<int> scut;\nvector<int> par;\nint n,m,k;\n\nbool bfs(){\n\tfill(par.begin(), par.end(),-1);\n\tqueue<int> q;\n\tq.push(0);\n\tpar[0]=0;\n\twhile (!q.empty()){\n\t\tint p=q.front();\n\t\tq.pop();\n\t\tfor (int &v:adj[p]){\n\t\t\tif(par[v]!=-1) continue;\n\t\t\tif (cap[p][v]){\n\t\t\t\tpar[v]=p;\n\t\t\t\tif (v==n+m+1) return true;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin>>n>>m>>k;\n\tcap.assign(n+m+2,vector<ll>(n+m+2,0));\n\tadj.assign(n+m+2,vector<int>());\n\tpar.assign(n+m+2,-1);\n\tvector<array<int,2>> kar;\n\tfor (int i=0;i<k;++i){\n\t\tint a,b;cin>>a>>b;b+=n;\n\t\tif (cap[a][b]) continue;\n\t\tcap[a][b]+=1;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t\tkar.push_back({a,b});\n\t}\n\tfor (int i=1;i<=n;++i) {\n\t\tcap[0][i]+=1;\n\t\tadj[0].push_back(i);\n\t\tadj[i].push_back(0);\n\t}\n\tfor (int i=n+1;i<=n+m;++i) {\n\t\tcap[i][n+m+1]+=1;\n\t\tadj[n+m+1].push_back(i);\n\t\tadj[i].push_back(n+m+1);\n\t}\n\tint re=0;\n\twhile (bfs()){\n\t\tre+=1;\n\t\tint cur=n+m+1;\n\t\twhile (cur!=0){\n\t\t\tcap[par[cur]][cur]-=1;\n\t\t\tcap[cur][par[cur]]+=1;\n\t\t\tcur=par[cur];\n\t\t}\n\t}\n\tcout<<re<<'\\n';\n\tfor (auto &p:kar){\n\t\tif (!cap[p[0]][p[1]]) {\n\t\t\tcout<<p[0]<<' '<<p[1]-n<<'\\n';\n\t\t}\n\t}\n\treturn 0;\n}",
//   "1712":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define REP(i,a,b) for (int i=a;i<=b;i++)\r\nusing namespace std;\r\n\r\nconst ll MOD=1000000007;\r\nll expo(ll p, ll q,ll mod){\r\n\tll re=1;\r\n\twhile (q){\r\n\t\tif (q&1)re=re*p%mod;\r\n\t\tq>>=1;\r\n\t\tp=p*p%mod;\r\n\t}\r\n\treturn re%mod;\t\r\n}\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tint t;\r\n\tcin>>t;\r\n\twhile(t--){\r\n\tll a,b,c;\r\n\tcin>>a>>b>>c;\r\n\tb=expo(b,c,MOD-1);\r\n\tcout<<expo(a,b,MOD)<<'\\n';\r\n\t}\r\n\treturn 0;\r\n}",
//   "1713":
//     "# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\r\n# define ten6 1e6+1.5\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n    fastio;\r\n    int n,k;\r\n    cin>>n;\r\n    vector <vector<int>> div (ten6,vector<int>());\r\n    vector <ll> re (ten6,1);\r\n    for (ll i = 2;i<ten6;i++){\r\n        if (div[i].size()==0){\r\n            ll j;\r\n            for (j=i;j<ten6 ;j+=i)\r\n                    div[j].push_back(1);\r\n\r\n            j=i*i;\r\n            ll k =j;\r\n            while (j<ten6){\r\n                for (k=j;k<ten6 ;k+=j)\r\n                    div[k][div[k].size()-1]=div[k].back()+1;\r\n                j*=i;\r\n            }\r\n        }\r\n    }\r\n    for (int i=2;i<ten6;i++){\r\n        for (auto &v:div[i])re[i]*=v+1;\r\n    }\r\n    while (n--){\r\n        cin>>k;\r\n        cout<<re[k]<<'\\n';\r\n    }\r\n    return 0;    \r\n}",
//   "1715":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll binpow(ll x,ll y,ll m){\n\tll re=1;\n\twhile(y){\n\t\tif (y&1) re=(re*x)%m;\n\t\ty>>=1;\n\t\tx=(x*x)%m;\n\t}\n\treturn re;\n}\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tstring s;\n\tcin>>s;\n\tint n=s.size();\n\tll m=1000000007;\n\tint x[26]={0};\n\tfor (char &c: s)\n\t\tx[c-'a']+=1;\n\n\tvector<ll> invFac(n+1,1);\n\tvector<ll> fac(n+1,1);\n\tfor (int i=2;i<=n;++i){\n\t\tfac[i]=fac[i-1]*i%m;\n\t\tinvFac[i]=binpow(fac[i],m-2,m);\n\t}\n\tll re=fac[n];\n\tfor (int i=0;i<26;++i)\n\tre=(re*invFac[x[i]])%m;\n\tcout<<re<<'\\n';\n}",
//   "1716":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll binpow(ll x,ll y,ll m){\n\tll re=1;\n\twhile(y){\n\t\tif (y&1) re=(re*x)%m;\n\t\ty>>=1;\n\t\tx=(x*x)%m;\n\t}\n\treturn re;\n}\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tint n,m;\n\tcin>>m>>n;\n\tm-=1;\n\tn+=m;\n\tll M=1000000007;\n\tvector<ll> invFac(n+1,1);\n\tvector<ll> fac(n+1,1);\n\tfor (int i=2;i<=n;++i){\n\t\tfac[i]=fac[i-1]*i%M;\n\t\tinvFac[i]=binpow(fac[i],M-2,M);\n\t}\n\tll re=fac[n]*invFac[m]%M*invFac[n-m]%M;\n\tcout<<re<<'\\n';\n}",
//   "1717":
//     '#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll MOD = 1000000007LL;\nconst int maxn = 1000000;\n\nll dp[maxn+1];\nll K[maxn+1];\nll invFac[maxn+1];\nll Fac[maxn+1];\nint n;\n\nll binpow(ll x, ll y){\n\tll re=1;\n\twhile (y){\n\t\tif (y&1) re = (re*x)%MOD;\n\t\tx=(x*x)%MOD;\n\t\ty>>=1;\n\t}\n\treturn re;\n}\n\nvoid preCalc(){\n\tinvFac[0]=Fac[0]=1;\n\tfor (ll i=1;i<n;++i){\n\t\tinvFac[i]= (binpow(i,MOD-2)*invFac[i-1])%MOD;\n\t\tFac[i]=Fac[i-1]*i%MOD;\n\t}\n}\n\nint main(){\n\tcin>>n;\n\tpreCalc();\n\tdp[1]=0;dp[2]=1;dp[3]=2;\n\tK[1]=K[2]=K[3]=0;\n\tfor (ll i=4;i<=n;++i){\n\t\tK[i] = ((K[i-1] * (i-1))%MOD +(dp[i-2]*invFac[i-2])%MOD * Fac[i-1]%MOD)%MOD;\n\t\tdp[i]= (K[i]+Fac[i-1])%MOD;\n\t}\n\t// for (int i=1;i<=n;++i){\n\t// \tcout<<"K: "<<K[i]<<", dp: "<<dp[i]<<endl;\n\t// }\n\tcout<<dp[n]<<\'\\n\';\n\treturn 0;\n}',
//   "1722":
//     "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1000000007;\nll n;\nll pow2(ll x, ll y){\n\treturn ((x*(y+MOD-x)%MOD)+(x*y%MOD))%MOD;\t\n}\npair<ll,ll> fib(ll y){\n\tif (y==0) return {0,1};\n\tpair<ll,ll> x = fib(y>>1);\n\tll fs = pow2(x.first,x.second);\n\tll sc = (pow2(x.second, x.first+x.second)+MOD-fs)%MOD;\n\tif (y&1) return {sc,(fs+sc)%MOD};\n\treturn {fs,sc};\n}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(NULL);\n\tcin>>n;\n\tcout<<fib(n).first<<'\\n';\n\treturn 0;\n}",
//   "1723":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll MOD=1000000007;\nint n,m,k;\nvector<vector<ll>> mult(vector<vector<ll>>& x, vector<vector<ll>> &y){\n\tint n1=x.size(),m1=x[0].size(),n2=y.size(),m2=y[0].size();\n\tvector<vector<ll>> re (n1,vector<ll>(m2,0));\n\tfor (int i=0;i<n1;++i){\n\t\tfor (int j=0;j<m2;++j){\n\t\t\tfor (int k=0;k<m1;++k){\n\t\t\t\tre[i][j]=(re[i][j]+x[i][k]*y[k][j])%MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn re;\n}\n\nvector<vector<ll>> binpow(vector<vector<ll>> x , ll y){\n\tvector<vector<ll>> re(n,vector<ll>(n,0));\n\tfor (int i=0;i<n;++i) re[i][i]=1;\n\twhile (y){\n\t\tif (y&1) re=mult(re,x);\n\t\ty>>=1;\n\t\tx=mult(x,x);\n\t}\n\treturn re;\n}\n\nint main(){\n\tcin>>n>>m>>k;\n\tvector<vector<ll>> mat(n,vector<ll>(n,0));\n\t// for (int i=0;i<6;++i) mat[i][0]=1;\n\t// for (int i=0;i<5;++i) mat[i][i+1]=1;\n\tfor (int i=0;i<m;++i) {\n\t\tint a,b;cin>>a>>b;--a;--b;\n\t\t++mat[a][b];\n\t}\n\tmat=binpow(mat,k);\n\tvector<vector<ll>> init(1,vector<ll>(n,0));\n\tinit[0][0]=1;\n\tcout<<mult(init,mat)[0][n-1]<<'\\n';\n}",
//   "1724":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll MOD=1e18+1000;\nint n,m,k;\nvector<vector<ll>> mult(vector<vector<ll>>& x, vector<vector<ll>> &y){\n\tint n1=x.size(),m1=x[0].size(),n2=y.size(),m2=y[0].size();\n\tvector<vector<ll>> re (n1,vector<ll>(m2,MOD));\n\tfor (int i=0;i<n1;++i){\n\t\tfor (int j=0;j<m2;++j){\n\t\t\tfor (int k=0;k<m1;++k){\n\t\t\t\tre[i][j]=min(re[i][j],x[i][k]+y[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn re;\n}\n\nvector<vector<ll>> binpow(vector<vector<ll>> x , ll y){\n\tvector<vector<ll>> re(n,vector<ll>(n,MOD));\n\tfor (int i=0;i<n;++i) re[i][i]=0;\n\twhile (y){\n\t\tif (y&1) re=mult(re,x);\n\t\ty>>=1;\n\t\tx=mult(x,x);\n\t}\n\treturn re;\n}\n\nvoid print(ll x){\n\tcout<<((x==MOD)?-1LL:x)<<'\\n';\t\n}\n\nint main(){\n\tcin>>n>>m>>k;\n\tvector<vector<ll>> mat(n,vector<ll>(n,MOD));\n\tfor (int i=0;i<m;++i) {\n\t\tint a,b;ll c;cin>>a>>b>>c;--a;--b;\n\t\tmat[a][b]=min(c,mat[a][b]);\n\t}\n\tmat=binpow(mat,k);\n\tprint(mat[0][n-1]);\n}",
//   "1725":
//     '#include <bits/stdc++.h>\nusing namespace std;\nint n,a,b;\nvoid solve(){\n\tint mxn=6*n;\n\tvector<vector<double>> dp(n+1,vector<double>(mxn+1));\n\tfor (int i=0;i<=mxn;++i) dp[0][i]=1;\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int k=1;k<=mxn;++k){\n\t\t\tfor (int j=1;j<=6;++j){\n\t\t\t\tif (j<=k) dp[i][k]+=dp[i-1][k-j]/6.0;\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\tprintf("%.6f\\n",dp[n][b]-dp[n][a-1]);\n}\n\nint main(){\n\tscanf("%d %d %d",&n,&a,&b);\n\tsolve();\n\treturn 0;\n}',
//   "1726":
//     '#include <bits/stdc++.h>\nusing namespace std;\nint k;\nstruct br{\n\tarray<double,64> board;\n\tpublic: br(){\n\t\tboard.fill(0);\n\t}\n};\narray<int,2>dir[]={{-1,0},{1,0},{0,-1},{0,1}};\nvoid solve(){\n\tvector<vector<br>> dp(64,vector<br>(k+1,br()));\n\tfor (int i=0;i<64;++i) dp[i][0].board[i]=1;\n\tfor (int i=1;i<=k;++i){\n\t\tfor (int r=0;r<8;++r){\n\t\t\tfor (int c=0;c<8;++c){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor (int j=0;j<4;++j){\n\t\t\t\t\tint nr=r+dir[j][0],nc=c+dir[j][1];\n\t\t\t\t\tif (nr<0||nr>=8||nc<0||nc>=8) continue;\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t\tfor (int j=0;j<4;++j){\n\t\t\t\t\tint nr=r+dir[j][0],nc=c+dir[j][1];\n\t\t\t\t\tif (nr<0||nr>=8||nc<0||nc>=8) continue;\n\t\t\t\t\tfor (int pos=0;pos<64;++pos){\n\t\t\t\t\t\tdp[r*8+c][i].board[pos]+=dp[nr*8+nc][i-1].board[pos]/cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble re=0;\n\tfor (int i=0;i<64;++i){\n\t\tdouble tmp=1;\n\t\tfor (int j=0;j<64;++j)\n\t\t\ttmp*=(1-dp[j][k].board[i]);\n\t\tre+=tmp;\n\t}\n\tprintf("%.6f\\n",re);\n}\n\nint main(){\n\tscanf("%d",&k);\n\tsolve();\n\treturn 0;\n}',
//   "1727":
//     '#include <bits/stdc++.h>\nusing namespace std;\nint n,k;\nvoid solve(){\n\tvector<vector<double>> dp(n+1,vector<double>(k+1,0));\n\tdp[0][0]=1;\n\tfor (int i=1;i<=n;++i){\n\t\tdouble acu=dp[i-1][0];\n\t\tfor (int j=1;j<=k;++j){\n\t\t\tdp[i][j]+=acu/k+j*dp[i-1][j]/k;\n\t\t\tacu+=dp[i-1][j];\n\t\t}\n\t}\n\tdouble re=0;\n\tfor (int i=1;i<=k;++i) {\n\t\tre+=i*dp[n][i];\n\t}\n\tprintf("%.6f\\n",re);\n}\n\nint main(){\n\tscanf("%d %d",&n,&k);\n\tsolve();\n\treturn 0;\n}',
//   "1728":
//     '#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvoid solve(){\n\tvector<int> r(n);\n\tfor (int&v:r)cin>>v;\n\tdouble re=0;\n\tfor (int i=0;i<n;++i){\n\t\tfor (int j=i+1;j<n;++j){\n\t\t\tfor (int a=r[i];a>1;--a){\n\t\t\t\tre+=1.0*min(a-1,r[j])/r[j]/r[i];\n\t\t\t}\n\t\t}\n\t}\n\tprintf("%.6f\\n",re);\n}\nint main(){\n\tscanf("%d",&n);\n\tsolve();\n\treturn 0;\n}',
//   "1729":
//     "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1000000;\nbool dp[maxn+1]={0};\nint main(){\n\tint n,k;cin>>n>>k;\n\tvector<int> mv(k);\n\tfor (int &v:mv)cin>>v;\n\tdp[0]=true;\n\tfor(int i=1;i<=n;++i){\n\t\tfor (int&v:mv) {\n\t\t\tif (v<=i&&dp[i-v]) {\n\t\t\t\tdp[i]=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdp[i]=!dp[i];\n\t\tcout<<((dp[i])?'L':'W');\n\t}\n\tcout<<'\\n';\n\treturn 0;\n}",
//   "1731":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll MOD=1000000007;\nstruct Node{\n\tint val;\n\tvector<Node*>child;\npublic:\n\tNode():val(0){\n\t\tchild.assign(26,nullptr);\n\t};\n\tNode(int val):val(val)\t{\n\t\tchild.assign(26,nullptr);\n\t};\n\t~Node(){\n\t\tfor (auto x:child)\n\t\t\tif (x) delete(x);\n\t}\n};\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tstring s;cin>>s;\n\tint n;cin>>n;\n\tvector<string> aS(n);\n\tNode * trie=new Node;\n\tfor (string &s1:aS){\n\t\tcin>>s1;\n\t\treverse(s1.begin(), s1.end());\n\t\tNode **tmp=&trie;\n\t\tfor (char &c:s1){\n\t\t\ttmp=&((*tmp)->child[c-'a']);\n\t\t\tif((*tmp)==nullptr) *tmp=new Node;\n\t\t}\n\t\t(*tmp)->val+=1;\n\t}\n\tvector<ll> dp(s.size()+1,0);\n\tdp[0]=1;\n\tfor (int i=1;i<=s.size();++i){\n\t\tNode **x=&trie;\n\t\tfor (int j=i-1;j>=0;--j){\n\t\t\tx=&((*x)->child[s[j]-'a']);\n\t\t\tif (!(*x)) break;\n\t\t\tdp[i]=(dp[i]+dp[j]*((*x)->val)%MOD)%MOD;\n\t\t}\n\t}\n\tdelete trie;\n\tcout<<dp[(int)s.size()]<<'\\n';\t\n\treturn 0;\n}",
//   "1732":
//     "#include <bits/stdc++.h>\nusing namespace std;\nstring t;\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>t;\n\tvector<int>pi(t.size()+1,-1);\n\tfor (int i=1;i<=t.size();++i){\n\t\tint k=pi[i-1];\n\t\twhile (k>=0&& t[i-1]!=t[k]) k=pi[k];\n\t\tpi[i]=k+1;\n\t}\n\tint k=pi[t.size()];\n\tvector<int> re;\n\twhile (k>0){\n\t\tre.push_back(k);\n\t\tk=pi[k];\n\t}\n\tfor (int i=1;i<=re.size();++i){\n\t\tcout<<re[re.size()-i]<<' ';\n\t}\n\treturn 0;\n}",
//   "1733":
//     "#include <bits/stdc++.h>\nusing namespace std;\nstring t;\nint n;\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>t;\n\tn=t.size();\n\tvector<int>z(n,0);\n\tfor (int i=1,l=0,r=0;i<n;++i){\n\t\tif (i<=r) z[i]=min(r-i+1,z[i-l]);\n\t\twhile (i+z[i]<n && t[z[i]]==t[z[i]+i]) ++z[i];\n\t\tif (z[i]+i-1>r){\n\t\t\tr=z[i]+i-1;\n\t\t\tl=i;\n\t\t}\n\t\tif (z[i]+i==n) cout<<i<<' ';\n\t}\n\tcout<<n<<'\\n';\n\treturn 0;\n}",
//   "1734":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,q;\nvector<int> a,F;\nmap<int,int> lvis;\n\nvoid increase(int pos, int add){\n\tfor (int i=pos;i<n;i=i|(i+1)){\n\t\tF[i]+=add;\n\t}\n}\n\nint sum1(int x){\n\tint re=0;\n\tfor (int i=x;i>=0;i=(i&(i+1))-1){\n\t\tre+=F[i];\n\t}\n\treturn re;\n}\nint sum(int l,int r){\n\treturn sum1(r)-sum1(l-1);\n}\n\nint main(){\n\tcin>>n>>q;\n\ta.assign(n,0);\n\tfor (int &v:a) cin>>v;\n\tvector<array<int,3>> Q(q);\n\tfor (int i=0;i<q;++i){\n\t\tcin>>Q[i][1]>>Q[i][0];\n\t\tQ[i][2]=i;\n\t\t--Q[i][1];--Q[i][0];\n\t}\n\tsort(Q.begin(),Q.end());\n\tvector<int> ans(q);\n\tint curr=0;\n\tF.assign(n,0);\n\tfor (auto &qu:Q){\n\t\twhile (curr<=qu[0]) {\n\t\t\tint x=lvis[a[curr]];\n\t\t\tif (x) {\n\t\t\t\tincrease(x-1,-1);\n\t\t\t}\n\t\t\tlvis[a[curr]]=curr+1;\n\t\t\tincrease(curr,1);\n\t\t\t++curr;\n\t\t}\n\t\tans[qu[2]]=sum(qu[1],qu[0]);\n\t}\n\tfor (int &r:ans) cout<<r<<'\\n';\n\treturn 0;\n}",
//   "1735":
//     "#include <bits/stdc++.h>\n#define fastio ios::sync_with_stdio(false);cin.tie(NULL)\n#define sz(x) (int)((x).size())\n#define ll long long\nusing namespace std;\n\nconst ll M=998244353LL;\nstruct Node{\n\tll s,a,inc;\n    Node(ll s,ll a,ll inc){\n        this->s=s;\n        this->a=a;\n        this->inc=inc;\n\t}\n};\n    \nstruct ST{\n\tvector<ll> a;\n\tvector<Node> st;\n\tll n;\n    ST(vector<ll>&a,ll n){\n        st.assign(n*4,Node(0,0,0));\n        this->a=a;\n        buildTree(0,n-1,1);\n\t}\n    void buildTree(ll tl,ll tr,ll v){\n        if (tl==tr){\n            st[v]=Node(a[tl],0,0);\n            return;\n\t\t}\n        ll mid=(tl+tr)>>1;\n        buildTree(tl,mid,v*2);\n        buildTree(mid+1,tr,v*2+1);\n        st[v].s=st[v*2].s+st[v*2+1].s;\n\t}\n    void ass(ll tl,ll tr,ll l,ll r,ll v,ll val){\n        if (l>r) return;\n        push(v,tr-tl+1);\n        if (tl==l && tr==r){\n            st[v].a=val;\n            st[v].s=val*(r-l+1);\n            return;\n\t\t}\n        ll mid=(tl+tr)>>1;\n        ass(tl,mid,l,min(mid,r),v*2,val);\n        ass(mid+1,tr,max(mid+1,l),r,v*2+1,val);\n        st[v].s=st[v*2].s+st[v*2+1].s;\n\t}\n\tvoid add(ll tl,ll tr,ll l,ll r,ll v,ll val){\n        if (l>r) return;\n        push(v,tr-tl+1);\n        if (tl==l && tr==r){\n            st[v].inc=val;\n            st[v].s+=val*(r-l+1);\n            return;\n\t\t}\n        ll mid=(tl+tr)>>1;\n        add(tl,mid,l,min(mid,r),v*2,val);\n        add(mid+1,tr,max(mid+1,l),r,v*2+1,val);\n        st[v].s=st[v*2].s+st[v*2+1].s;\n\t}\n    ll query(ll tl,ll tr,ll l,ll r,ll v){\n        if (l>r) return 0;\n        if (tl==l && tr==r) return st[v].s;\n        push(v,tr-tl+1);\n        ll mid=(tl+tr)>>1;\n        ll re=0;\n        re+=query(tl,mid,l,min(mid,r),v*2);\n        re+=query(mid+1,tr,max(mid+1,l),r,v*2+1);\n        return re;\n\t}\n    void push(ll v,ll n){\n        if (n==1) return;\n        if (st[v].a){\n            st[v*2].a=st[v*2+1].a=st[v].a;\n            st[v*2].s=(n+1)/2*st[v].a;\n\t\t\tst[v*2+1].s=n/2*st[v].a;\n            st[v].a=0;\n\t\t\tst[v*2].inc=st[v*2+1].inc=0;\n\t\t}\n\t\telse if (st[v].inc){\n            st[v*2].inc+=st[v].inc;\n\t\t\tst[v*2+1].inc+=st[v].inc;\n            st[v*2].s+=(n+1)/2*st[v].inc;\n\t\t\tst[v*2+1].s+=n/2*st[v].inc;\n            st[v].inc=0;\n\t\t\tif (st[v*2].a){\n\t\t\t\tst[v*2].a+=st[v*2].inc;\n\t\t\t\tst[v*2].inc=0;\n\t\t\t}\n\t\t\tif (st[v*2+1].a){\n\t\t\t\tst[v*2+1].a+=st[v*2+1].inc;\n\t\t\t\tst[v*2+1].inc=0;\n\t\t\t}\n\t\t}\n\t}\n};\nint main(){\n\tfastio;\n\tint n,q;cin>>n>>q;\n\tvector<ll> a(n);\n\tfor (auto &v:a) cin>>v;\n\tST st=ST(a,n);\n\tfor (ll i=0;i<q;++i){\n\t\tint t,x,y;cin>>t>>x>>y;\n\t\tif (t==3){\n\t\t\tcout<<st.query(0,n-1,x-1,y-1,1)<<'\\n';\n\t\t}\n\t\telse if (t==1){\n\t\t\tint z;cin>>z;\n\t\t\tst.add(0,n-1,x-1,y-1,1,z);\n\t\t}\n\t\telse {\n\t\t\tint z;cin>>z;\n\t\t\tst.ass(0,n-1,x-1,y-1,1,z);\n\t\t}\n\t}\n}",
//   "1739":
//     "#include <bits/stdc++.h>\nusing namespace std;\nint n,q;\nvector<vector<int>> F;\nvoid increase(int r,int c,int add){\n\tfor (int i=r;i<n;i=i|(i+1)){\n\t\tfor (int j=c;j<n;j=j|(j+1)){\n\t\t\tF[i][j]+=add;\n\t\t}\n\t}\n}\nint sum(int r,int c){\n\tint re=0;\n\tfor (int i=r;i>=0;i=(i&(i+1))-1){\n\t\tfor (int j=c;j>=0;j=(j&(j+1))-1){\n\t\t\tre+=F[i][j];\n\t\t}\n\t}\n\treturn re;\n}\nint get(int r1,int c1,int r2,int c2){\n\treturn sum(r2,c2)-sum(r2,c1-1)-sum(r1-1,c2)+sum(r1-1,c1-1);\n}\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n>>q;\n\tF.assign(n,vector<int>(n,0));\n\tvector<string> br(n);\n\tfor (int i=0;i<n;++i){\n\t\tcin>>br[i];\n\t\tfor (int j=0;j<n;++j){\n\t\t\tif (br[i][j]=='*') increase(i,j,1);\n\t\t}\n\t}\n\tfor (int i=0;i<q;++i){\n\t\tint t;cin>>t;\n\t\tif (t==2){\n\t\t\tint r1,c1,r2,c2;cin>>r1>>c1>>r2>>c2;--r1;--r2;--c1;--c2;\n\t\t\tcout<<get(r1,c1,r2,c2)<<'\\n';\n\t\t}\n\t\telse{\n\t\t\tint r,c;cin>>r>>c;--r;--c;\n\t\t\tint x=1;\n\t\t\tif (br[r][c]=='*'){\n\t\t\t\tx=-1;\n\t\t\t\tbr[r][c]='.';\n\t\t\t}\n\t\t\telse br[r][c]='*';\n\t\t\tincrease(r,c,x);\n\t\t}\n\t}\n\treturn 0;\n}",
//   "1744":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MOD = 1000000007;\n\nint main(){\n\tint a,b;\n\tcin>>a>>b;\n\tint mx=max(a,b);\n\tvector <vector<int>> dp (mx+1,vector<int>(mx+1,MOD));\n\tfor (int i=1;i<=mx;++i) dp[i][i]=0;\n\tfor (int i=1;i<=mx;++i) {\n\t\tfor (int j=i;j<=mx;++j) {\n\t\t\tfor (int k=1;k<=mx;++k) {\n\t\t\t\tif (k+j<=mx) dp[k+j][i]=dp[i][k+j]=min(dp[i][k+j],dp[i][j]+dp[i][k]+1);\n\t\t\t\tif (k+i<=mx) dp[k+i][j]=dp[j][k+i]=min(dp[j][k+i],dp[i][j]+dp[j][k]+1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[a][b]<<endl;\n    return 0;\n}",
//   "1745":
//     "# include <bits/stdc++.h>\n# define ll long long\n# define all(x) x.begin(), x.end()\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n# define MOD 1000000007\nusing namespace std;\nint n;\nvector<int> lsCoin;\nvector<int> dp;\n\nint main(){\n\tfastio;\n    cin>>n;\n    lsCoin.assign(n,0);\n    int s=0;\n    for (int i=0;i<n;++i) {\n        cin>>lsCoin[i];\n        s+=lsCoin[i];\n    }\n    dp.assign(s+1,-1);\n    dp[0]=1;\n    vector<int> allSum;\n    for (int k=0;k<lsCoin.size();++k){\n        for (int i=s;i>=1;--i) {\n            if (lsCoin[k]<=i&&dp[i-lsCoin[k]]==1){\n                dp[i]=1;\n            }\n        }\n    }\n    for (int i=1;i<=s;++i) {\n        if (dp[i]==1)\n                allSum.push_back(i);\n    }\n    cout<<allSum.size()<<'\\n';\n    for (int i=0;i<allSum.size();++i){\n        if (i!=0) cout<<' ';\n        cout<<allSum[i];\n    }\n    cout<<'\\n';\n\treturn 0;\n}\n\n",
//   "1746":
//     '# include <bits/stdc++.h>\n# define ll long long\n# define all(x) x.begin(), x.end()\n# define fastio ios_base::sync_with_stdio(false); cin.tie(NULL)\n# define MOD 1000000007\n# define ten6 1000002\nusing namespace std;\nvector<vector<ll>> dp;\nvector<vector<ll>> coeff;\nint n,m;\n\nvoid setCoeff(){\n    coeff[0][0]=1;\n    for(int i=1;i<=m;++i){\n        // coeff[i] = coeff[i-1]<<1 - coeff[i-1] - coeff[i-2]\n        coeff[i][0]=-coeff[i-1][0];\n        for (int k=1;k<=i;++k) {\n            coeff[i][k]=(coeff[i-1][k-1]-coeff[i-1][k])%MOD;\n        }\n        if (i>1) {\n            for (int k=0;k<=i-2;++k) {\n                coeff[i][k]=(coeff[i][k]-coeff[i-2][k])%MOD;\n            }   \n        }\n    }\n}\n\nvoid setDP(){\n    // dp[dis][0->m]\n    dp[0][0]=1;\n    for(int i=1;i<=n+m;++i){\n        // dp[i][k] = dp[i-1][k] + dp[i-1][k-1] +dp[i-1][k+1]\n        for (int k=0;k<=m;++k) {\n            ll ans=dp[i-1][k];\n            if (k<m) ans+=dp[i-1][k+1];\n            if (k>0) ans+=dp[i-1][k-1];\n            ans%=MOD;\n            dp[i][k]=ans;\n        }\n    }\n}\n\nll getShit(int from, int to, int dis) {\n    if (dis==1) return from==-1 || abs(to-from)<=1;\n    ll ans=0;\n    for (int i=0;i<=m;++i) {\n        ans=(ans+dp[dis+i][to]*coeff[from][i]%MOD)%MOD;\n    }\n    return ans;\n}\nint main()\n{\n    // freopen("test_input.txt","r",stdin);\n    fastio; \n    cin>>n>>m;\n    --m;\n    dp.assign(n+m+1,vector<ll>(m+1,0));\n    coeff.assign(m+1,vector<ll>(m+1,0));\n    setCoeff();\n    setDP();\n    vector<int> arr(n);\n    for (int i=0;i<n;++i) cin>>arr[i];\n    ll re=1;\n    int from=-1,to=0;\n    while (from<n) {\n        while(to<n&&arr[to]==0) ++to;\n        if (from==-1 && to==n) {\n            ll tmp=0;\n            for (int i=0; i<=m; ++i) {\n                for (int k=0; k<=m; ++k) {\n                    tmp=(tmp+getShit(i,k,n-1))%MOD;\n                }\n            }\n            re=(re*tmp)%MOD;\n            break;\n        }\n        if (from==-1) {\n            if (to!=0) {\n                ll tmp=0;\n                for (int i=0; i<=m; ++i) {\n                    tmp=(tmp+getShit(i,arr[to]-1,to))%MOD;\n                }\n                re=(re*tmp)%MOD;\n            }\n        }\n        else if (to==n) {\n            if (to-from!=1){\n                ll tmp=0;\n                for (int i=0; i<=m; ++i) {\n                    tmp=(tmp+getShit(arr[from]-1,i,to-from-1))%MOD;\n                }\n                re=(re*tmp)%MOD;\n            }\n        }\n        else re=(re*getShit(arr[from]-1,arr[to]-1,to-from))%MOD;\n        from=to;\n        ++to;\n    }\n    if (re<0) re+=MOD;\n    cout<<re<<\'\\n\';\n    return 0;\n}',
//   "1749":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint n,m;\nvector<int> a;\nvector<int> v;\nvector<int> st;\nvoid buildTree(int v,int tl, int tr){\n\tif (tl==tr){\n\t\tst[v]=a[tl];\n\t}\n\telse{\n\t\tint mid = (tl+tr)>>1;\n\t\tbuildTree(v*2,tl,mid);\n\t\tbuildTree(v*2+1,mid+1,tr);\n\t\tst[v]=st[v*2]+st[v*2+1];\n\t}\n}\nint get(int v,int l, int r, int tl, int tr){\n\tif (l==tl&&r==tr){\n\t\treturn st[v];\n\t}\n\tif (l>r) return 0;\n\tint mid=(tl+tr)>>1;\n\treturn get(v*2,l,min(mid,r),tl,mid)+get(v*2+1,max(l,mid+1),r,mid+1,tr);\n}\nvoid update(int v,int tl, int tr, int val,int pos){\n\tif (tl==tr){\n\t\tst[v]=val;\n\t\treturn;\n\t}\n\tint mid=(tl+tr)>>1;\n\tif (pos<=mid) update(v*2,tl,mid,val,pos);\n\telse update(v*2+1,mid+1,tr,val,pos);\n\tst[v]=st[v*2]+st[v*2+1];\n}\n\nint getVal(int tg){\n\tint l=0,r=n-1;\n\twhile (l<=r){\n\t\tint mid = (l+r)>>1;\n\t\tint mx=get(1,0,mid,0,n-1);\n\t\tif (mx>=tg) {\n\t\t\tr=mid-1;\n\t\t}\n\t\telse {\n\t\t\tl=mid+1;\n\t\t}\n\t}\n\tupdate(1,0,n-1,0,l);\n\treturn v[l];\n}\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n;\n\ta.assign(n,1);\n\tv.assign(n,0);\n\tst.assign(4*n,0);\n\tfor (int i=0;i<n;++i) {\n\t\tcin>>v[i];\n\t}\n\tbuildTree(1,0,n-1);\n\tfor (int i=0;i<n;++i){\n\t\tint r;cin>>r;\n\t\tcout<<getVal(r)<<' ';\n\t}\n\treturn 0;\n}\n",
//   "1750":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint n,m,timer;\nvector<int> p;\nvector<array<int,3>> idx;\nvector<vector<int>> l;\nvector<vector<int>>up;\n\nvoid genLine(int x){\n\tvector<int> v;\n\twhile (idx[x][0]>0){\n\t\tv.push_back(x);\n\t\tidx[x][0]=-2;\n\t\tx=p[x];\n\t}\n\tif (idx[x][0]!=0) x=-1;\n\telse v.push_back(x);\n\n \treverse(v.begin(),v.end());\n \tfor (int& c:v){\n \t\tif (c!=x) up[c][0]=p[c];\n \t\telse up[c][0]=c;\n \t\tfor (int i=1;i<20;++i){\n \t\t\tup[c][i]=up[up[c][i-1]][i-1];\n \t\t}\n \t}\n\n}\n\nvoid genCycle(int x){\n\tint pos=l.size();\n\tint turtle=p[x], rabbit=p[p[x]];\n\twhile (turtle!=rabbit){\n\t\tturtle=p[turtle];\n\t\trabbit=p[p[rabbit]];\n\t}\n\tint y=x;\n\t\n\twhile (y!=turtle){\n\t\ty=p[y];\n\t\tturtle=p[turtle];\n\t}\n\n\tl.push_back({y});\n\tvector<int> &cycle=l[pos];\n\tidx[y]={0,pos,0};\n\tint y1=p[y];\n\tint tmp=1;\n\twhile (y1!=y) {\n\t\tidx[y1]={0,pos,tmp++};\n\t\tcycle.push_back(y1);\n\t\ty1=p[y1];\n\t}\n\n \tgenLine(x);\n}\n \nvoid merge(int x){\n\tidx[x][0]=timer;\n\tint tmp=p[x];\n\twhile (idx[tmp][0]==-1){\n\t\tidx[tmp][0]=timer;\n\t\ttmp=p[tmp];\n\t}\n\tint a=idx[tmp][0];\n\tif (a==timer) genCycle(x);\n\telse genLine(x);\n\t++timer;\n}\n\nbool checkroot(int x){\n\treturn idx[x][0]==0;\n}\nint get(int x, int k){\n\tif (idx[x][0]==0){\n\t\tint & b=idx[x][1], &c=idx[x][2];\n\t\treturn l[b][(c+k)%(l[b].size())];\n\t}\n\telse {\n\t\tfor(int i=19;k>0&&i>=0;--i){\n\t\t\tif ((1<<i)<=k&&!checkroot(up[x][i])) {\n\t\t\t\tx=up[x][i];\n\t\t\t\tk-=(1<<i);\n\t\t\t}\n\t\t}\n\t\tif (k==0) return x;\n\t\telse return get(up[x][0],k-1);\n\t}\n}\n\nvoid solve(){\n\tidx.assign(n,{-1,-1,-1});\n\tup.assign(n,vector<int>(20,-1));\n\ttimer=1;\n\tfor (int i=0;i<n;++i){\n\t\tif (idx[i][0]==-1) merge(i);\n\t}\n\tfor (int i=0;i<m;++i){\n\t\tint x,k;\n\t\tcin>>x>>k;\n\t\tcout<<get(x-1,k)+1<<'\\n';\n\t}\n}\n \nint main(){\n\tios::sync_with_stdio(0);cin.tie(NULL);\n\tcin>>n>>m;\n\tp.assign(n,-1);\n\tfor (int i=0;i<n;++i){\n\t\tcin>>p[i];\n\t\t--p[i];\n\t}\n\tsolve();\n\treturn 0;\n}",
//   "1751":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint n,m,timer,timer1;\nvector<int> p,tin,tout;\nvector<array<int,3>> idx;\nvector<vector<int>> l,up,adjList;\n\nvoid genLine(int x){\n\tvector<int> v;\n\twhile (idx[x][0]>0){\n\t\tv.push_back(x);\n\t\tidx[x][0]=-2;\n\t\tx=p[x];\n\t}\n\tif (idx[x][0]!=0) x=-1;\n \treverse(v.begin(),v.end());\n \tfor (int& c:v){\n \t\tif (p[c]!=x) adjList[p[c]].push_back(c);\n \t\telse adjList[l[idx[x][1]][0]].push_back(c);\n \t}\n\n}\n\nvoid genCycle(int x){\n\tint pos=l.size();\n\tint turtle=p[x], rabbit=p[p[x]];\n\twhile (turtle!=rabbit){\n\t\tturtle=p[turtle];\n\t\trabbit=p[p[rabbit]];\n\t}\n\tint y=x;\n\t\n\twhile (y!=turtle){\n\t\ty=p[y];\n\t\tturtle=p[turtle];\n\t}\n\n\tl.push_back({y});\n\tvector<int> &cycle=l[pos];\n\tidx[y]={0,pos,0};\n\tint y1=p[y];\n\tint tmp=1;\n\twhile (y1!=y) {\n\t\tidx[y1]={0,pos,tmp++};\n\t\tcycle.push_back(y1);\n\t\ty1=p[y1];\n\t}\n\n \tgenLine(x);\n}\n\nvoid merge(int x){\n\tidx[x][0]=timer;\n\tint tmp=p[x];\n\twhile (idx[tmp][0]==-1){\n\t\tidx[tmp][0]=timer;\n\t\ttmp=p[tmp];\n\t}\n\tint a=idx[tmp][0];\n\tif (a==timer) genCycle(x);\n\telse genLine(x);\n\t++timer;\n}\n\nvoid dfs(int x,int pre){\n\ttin[x]=timer1++;\n\tup[x][0]=pre;\n\tfor (int i=1;i<20;++i)\n\t\tup[x][i]=up[up[x][i-1]][i-1];\n\n\tfor (int &c:adjList[x])\tdfs(c,x);\n\ttout[x]=timer1++;\n}\n\nbool is_ancestor(int x,int y){\n\treturn tin[x]<=tin[y]&&tout[x]>=tout[y];\n}\n\nint get(int x){\n\tint &a=idx[x][0],&b=idx[x][1];\n\tif (a==0)\n\t\treturn l[b].size();\n\t\t\t\n\tint re=0;\n\tfor (int i=19;i>=0;--i){\n\t\tif (idx[up[x][i]][0]==0)continue;\n\t\tx=up[x][i];\n\t\tre+=(1<<i);\n\t}\n\tx=p[x];\n\t++re;\n\treturn re+get(x);\n}\n\nvoid solve(){\n\tidx.assign(n,{-1,-1,-1});\n\tup.assign(n,vector<int>(20,-1));\n\tadjList.assign(n,vector<int>());\n\ttin.assign(n,-1);\n\ttout.assign(n,-1);\n\ttimer=timer1=1;\n\tfor (int i=0;i<n;++i){\n\t\tif (idx[i][0]==-1) merge(i);\n\t}\n\tfor (int i=0;i<n;++i){\n\t\tif (idx[i][0]==0&&idx[i][2]==0) dfs(i,i);\n\t}\n\tfor (int i=0;i<n;++i){\n\t\tcout<<get(i)<<'\\n';\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(NULL);\n\tcin>>n;\n\tp.assign(n,-1);\n\tfor (int i=0;i<n;++i){\n\t\tcin>>p[i];\n\t\t--p[i];\n\t}\n\tsolve();\n\treturn 0;\n}",
//   "1753":
//     "#include <bits/stdc++.h>\nusing namespace std;\nstring s,t;\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>s>>t;\n\tvector<int>pi(t.size()+1,-1);\n\tfor (int i=1;i<=t.size();++i){\n\t\tint k=pi[i-1];\n\t\twhile (k>=0&& t[i-1]!=t[k]) k=pi[k];\n\t\tpi[i]=k+1;\n\t}\n\tint re=0,pre=0;\n\tfor (int i=0;i<s.size();++i){\n\t\twhile (pre>=0&&t[pre]!=s[i]) pre=pi[pre];\n\t\t++pre;\n\t\tif (pre==t.size()){\n\t\t\t++re;\n\t\t\tpre=pi[pre];\n\t\t} \n\t}\n\tcout<<re<<'\\n';\n\treturn 0;\n}",
//   "1754":
//     '# include <bits/stdc++.h>\r\n# define ll long long\r\n# define all(x) x.begin(), x.end()\r\nusing namespace std;\r\nll md=1000000007;\r\nbool solve(int a,int b){\r\n\tif (a>b) swap(a,b);\r\n\ta=a*2-b;\r\n\treturn !(a%3)&&a>=0;\r\n}\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tint tc;\r\n\tcin>>tc;\r\n\twhile(tc--){\r\n\t\tint a,b;\r\n\t\tcin>>a>>b;\r\n\t\tif (solve(a,b)) cout<<"YES\\n";\r\n\t\telse cout<<"NO\\n";\r\n\t}\r\n\treturn 0;\r\n}',
//   "1755":
//     "# include <bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tstring s;\r\n\tcin>>s;\r\n\tunordered_map <char,int> a;\r\n\tfor (auto c:s){\r\n\t\ta[c]++;\r\n\t}\r\n\tstring s1 (s.size(),' ');\r\n\tint l=0,r=s.size()-1;\r\n\tint m=-1;\r\n\tif (s.size()%2) m=(l+r)/2;\r\n\tfor (auto x:a){\r\n\t\tif (x.second%2){\r\n\t\t\tif (m!=-1){\r\n\t\t\t\ts1[m]=x.first;\r\n\t\t\t\tm=-1;\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tcout<<\"NO SOLUTION\\n\";\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (int c=x.second;c>=2;c-=2){\r\n\t\t\ts1[l++]=s1[r--]=x.first;\r\n\t\t}\t\r\n\t}\r\n\tcout<<s1<<endl;\r\n\treturn 0;\r\n}",
//   "2064":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll M=1000000007;\nvector<ll> invFac;\nvector<ll> fac;\n\nll binpow(ll x,ll y,ll m){\n\tll re=1;\n\twhile(y){\n\t\tif (y&1) re=(re*x)%m;\n\t\ty>>=1;\n\t\tx=(x*x)%m;\n\t}\n\treturn re;\n}\nll C(int n, int k){\n\treturn fac[n]*invFac[k]%M*invFac[n-k]%M;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tif (n%2){\n\t\tcout<<0<<'\\n';\n\t\treturn 0;\n\t}\n\tfac.assign(n+1,1);\n\tinvFac.assign(n+1,1);\n\tfor (int i=2;i<=n;++i){\n\t\tfac[i]=fac[i-1]*i%M;\n\t\tinvFac[i]=binpow(fac[i],M-2,M);\n\t}\n\tn/=2;\n\tll re=C(2*n,n)-C(2*n,n-1)+M;\n\tre%=M;\n\tcout<<re<<'\\n';\n\treturn 0;\n}",
//   "2136":
//     "#include <bits/stdc++.h>\n#define fastio ios::sync_with_stdio(false);cin.tie(NULL)\n#define ll long long\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\nusing namespace std;\n\nint main(){\n\tfastio;\n\tint n,k;\n\tcin>>n>>k;\n\tvector<int> a(n);\n\tfor (int&v:a){\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor (int i=0;i<sz(s);++i){\n\t\t\tif (s[i]=='1'){\n\t\t\t\tv|=1<<(sz(s)-i-1);\n\t\t\t}\n\t\t}\n\t}\n\tint re=31;\n\tfor (int i=0;i<n;++i){\n\t\tfor (int j=i+1;j<n;++j){\n\n\t\t\tre=min(re,__builtin_popcount(a[i]^a[j]));\n\t\t}\n\t}\n\tcout<<re<<'\\n';\n}\n",
//   "2162":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\n\nvector<int> a;\nint n;\n\nint root(int x){\n\twhile (a[x]!=x) x=a[x]=a[a[x]];\n\treturn x;\n}\n\nint main(){\n\tfastio;\n\tcin>>n;\n\ta.assign(n,0);\n\tiota(a.begin(),a.end(),0);\n\tint cnt = 0, i=0;\n\twhile (cnt<n){\n\t\ti = root(i);\n\t\ti= (i+1)%n;\n\t\ti = root(i);\n\t\tif (cnt!=0) cout<<' ';\n\t\tcout<<i+1;\n\t\ta[i]=root((i+1)%n);\n\t\ti= (i+1)%n;\n\t\t++cnt;\n\t}\t\n\tcout<<'\\n';\n    return 0;\n}",
//   "2163":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\n\nvector<int> st;\nint n,k;\n\nvoid update(int tl, int tr, int idx,int val, int curr){\n\tif (tl>idx || tr <idx) return;\n\tif (tl==tr) {\n\t\tst[curr]=val;\n\t\treturn;\n\t}\n\tint mid = (tl+tr)/2;\n\tupdate(tl,mid,idx,val,curr*2);\n\tupdate(mid+1,tr,idx,val,curr*2+1);\n\tst[curr]=st[curr*2]+st[curr*2+1];\n}\n\nint get(int tl, int tr, int l, int r, int curr){\n\tif (l>r) return 0;\n\tif (tl==l && tr==r) return st[curr];\n\tint mid = (tl+tr)/2;\n\treturn get(tl,mid,l,min(r,mid),curr*2)+get(mid+1,tr,max(l,mid+1),r,curr*2+1);\n}\n\nint getIdx(int vtidx){\n\tint l=0,r=n-1;\n\twhile (l<r){\n\t\tint mid = (l+r)/2;\n\t\tint x=get(0,n-1,0,mid,1);\n\t\tif (x>=vtidx+1) r=mid;\n\t\telse l=mid+1;\n\t}\n\treturn l;\n}\n\nint main(){\n\tfastio;\n\tcin>>n>>k;\n\tst.assign(4*n,0);\n\tfor (int i=0;i<n;++i){\n\t\tupdate(0,n-1,i,1,1);\n\t}\n\tint prev=0;\n\twhile (st[1]) {\n\t\tint i;\n\t\tfor (i=(k-prev)%st[1];i<st[1];i+=k%st[1]) {\n\t\t\tint x=getIdx(i);\n\t\t\tupdate(0,n-1,x,0,1);\n\t\t\tcout<<x+1;\n\t\t\tif (st[1]==0) break;\n\t\t\tcout<<' ';\n\t\t\tprev=st[1]-i;\n\t\t}\n\t}\n\tcout<<'\\n';\n    return 0;\n}",
//   "2164":
//     "#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(int n,int k){\n\tint curr=n,cnt=0,f=2,step=1,s=1;\n\twhile (k>cnt+(curr+2-f)/2){\n\t\tint tmp=(curr+2-f)/2;\n\t\tcnt+=tmp;\n\t\tif (f==1) s+=(1<<(step-1));\n\t\tif (curr%2) f=3-f;\n\t\tcurr-=tmp;\n\t\t++step;\n\t}\n\tif (f==2) s+=(1<<(step-1));\t\n\treturn s+(1<<step)*(k-cnt-1);\n}\n\nint main(){\n\t// ios::sync_with_stdio(false);cin.tie(NULL);\n\tint q;\n\tcin>>q;\n\tfor (int i=0;i<q;++i){\n\t\tint n,k;\n\t\tcin>>n>>k;\n\t\tcout<<solve(n,k)<<'\\n';\n\t}\n\treturn 0;\n}",
//   "2166":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nstruct Node{\n\tll pre;\n\tll addend;\n};\n\nvector<Node> st;\nvector<ll> a;\nint n,q;\n\nvoid buildTree(int v,int tl, int tr){\n\tif (tl==tr){\n\t\tst[v].pre=a[tl];\n\t\treturn;\n\t}\n\tint mid = (tl+tr)>>1;\n\tbuildTree(v*2,tl,mid);\n\tbuildTree(v*2+1,mid+1,tr);\n\tst[v].pre=max(st[v*2].pre,st[v*2+1].pre);\n}\n\nvoid push(int v) {\n\tst[v*2].pre+=st[v].addend;\n\tst[v*2+1].pre+=st[v].addend;\n\tst[v*2].addend+=st[v].addend;\n\tst[v*2+1].addend+=st[v].addend;\n\tst[v].addend=0;\t\n}\n\nll get(int v, int l, int r, int tl, int tr){\n\tif(tl==l&&tr==r){\n\t\treturn st[v].pre;\n\t}\n\tif (l>r) return -1e18;\n\tpush(v);\n\tint mid = (tl+tr)>>1;\n\treturn max(get(v*2,l,min(r,mid),tl,mid),get(v*2+1,max(mid+1,l),r,mid+1,tr));\n}\n\nvoid update(int v, int l, int r, int tl, int tr, int add){\n\tif (l>r) return;\n\tif (l==tl&&r==tr) {\n\t\tst[v].pre+=add;\n\t\tst[v].addend+=add;\n\t}\n\telse {\n\t\tpush(v);\n\t\tint mid =(tl+tr)>>1;\n\t\tupdate(v*2,l,min(r,mid),tl,mid,add);\n\t\tupdate(v*2+1,max(l,mid+1),r,mid+1,tr,add);\n\t\tst[v].pre=max(st[v*2].pre,st[v*2+1].pre);\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tcin>>n>>q;\n\ta.assign(n,0);\n\tvector<int>v(n);\n\tfor (int i=0;i<n;++i){\n\t\tcin>>v[i];\n\t\ta[i]=v[i];\n\t\tif (i) a[i]+=a[i-1];\n\t}\n\tst.assign(4*n,Node({0,0}));\n\tbuildTree(1,0,n-1);\n\tfor (int i=0;i<q;++i){\n\t\tint t;cin>>t;\n\t\tif (t==2){\n\t\t\tint x,y;cin>>x>>y;--x;--y;\n\t\t\tll re=get(1,x,y,0,n-1);\n\t\t\tif (x) re-=get(1,x-1,x-1,0,n-1);\n\t\t\tcout<<max(re,0LL)<<'\\n';\n\t\t}\n\t\telse{\n\t\t\tassert(t==1);\n\t\t\tint k,u;\n\t\t\tcin>>k>>u;--k;\n\t\t\tupdate(1,k,n-1,0,n-1,u-v[k]);\n\t\t\tv[k]=u;\n\t\t}\n\t}\n\treturn 0;\n}",
//   "2168":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int INF=1e9;\nint main() {\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tint n;cin>>n;\n\tvector<array<int,2>> a(n);\n\tvector<array<int,3>> b(n);\n\tvector<array<int,3>> c(n);\n\tvector<int> yidx(n);\n\tfor (int i=0;i<n;++i) {\n\t\tcin>>a[i][0]>>a[i][1];\n\t\tb[i][0]=a[i][0];b[i][1]=-a[i][1];b[i][2]=i;\n\t\tc[i][0]=a[i][1];c[i][1]=-a[i][0];c[i][2]=i;\n\t}\n\tsort(b.begin(), b.end());\n\tsort(c.begin(), c.end());\n\tfor (int i=0;i<n;++i) yidx[b[i][2]]=i;\n\tint mx=-INF;\n\tvector<array<int,2>> s;\n\tfill(a.begin(),a.end(),array<int,2>({0,0}));\n\tfor (int i=0;i<n;++i){\n\t\tarray<int,2>cur={yidx[c[i][2]],c[i][2]};\n\t\twhile (s.size()&&s.back()[0]>cur[0]){\n\t\t\ta[s.back()[1]][1]=1;\n\t\t\ta[cur[1]][0]=1;\n\t\t\ts.pop_back();\n\t\t}\n\t\ta[cur[1]][0]=cur[0]<mx;\n\t\tmx=max(mx,cur[0]);\n\t\ts.push_back(cur);\n\t}\n\tfor (int i=0; i<n; ++i){\n\t\tif (i!=0) cout<<' ';\n\t\tcout<<a[i][0];\n\t}\n\tcout<<'\\n';\n\n\tfor (int i=0; i<n; ++i){\n\t\tif (i!=0) cout<<' ';\n\t\tcout<<a[i][1];\n\t}\n\tcout<<'\\n';\n\treturn 0;\n}",
//   "2169":
//     "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define ll long long\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\nusing namespace std;\nusing namespace __gnu_pbds;\n\nconst int INF=1e9;\nint main() {\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tint n;cin>>n;\n\tvector<array<int,2>> a(n);\n\tvector<array<int,3>> b(n);\n\tvector<array<int,3>> c(n);\n\tvector<int> yidx(n);\n\tfor (int i=0;i<n;++i) {\n\t\tcin>>a[i][0]>>a[i][1];\n\t\tb[i][0]=a[i][0];b[i][1]=-a[i][1];b[i][2]=i;\n\t\tc[i][0]=a[i][1];c[i][1]=-a[i][0];c[i][2]=i;\n\t}\n\tsort(b.begin(), b.end());\n\tsort(c.begin(), c.end());\n\tfor (int i=0;i<n;++i) yidx[b[i][2]]=i;\n\n\tordered_set s;\n\tfill(a.begin(),a.end(),array<int,2>({0,0}));\n\tfor (int i=0;i<n;++i){\n\t\tint idx=c[i][2];\n\t\tint cur=yidx[idx];\n\t\tint nless=s.order_of_key(cur);\n\t\tint nbig=s.size()-nless;\n\t\ta[idx][0]=nbig;\n\t\ta[idx][1]=cur-nless;\n\t\ts.insert(cur);\n\t}\n\tfor (int i=0; i<n; ++i){\n\t\tif (i!=0) cout<<' ';\n\t\tcout<<a[i][0];\n\t}\n\tcout<<'\\n';\n\n\tfor (int i=0; i<n; ++i){\n\t\tif (i!=0) cout<<' ';\n\t\tcout<<a[i][1];\n\t}\n\tcout<<'\\n';\n\treturn 0;\n}",
//   "2181":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MOD = 1000000007;\nvector<vector<ll>> dp;\nll suplement(vector<ll>& row,ll state,ll i) {\n\tll re=0;\n\twhile (i<state){\n\t\tif (i&state) {\n\t\t\ti<<=1;\n\t\t\twhile (i&state){\n\t\t\t\tll nstate=state^(i+(i>>1));\n\t\t\t\ti<<=1;\n\t\t\t\tre= (re+row[nstate]+suplement(row,nstate,i))%MOD;\n\t\t\t}\n\t\t}\n\t\ti<<=1;\n\t}\n\treturn re;\n}\nint main(){\n\tll n,m;\n\tcin>>n>>m;\n\tll mxn=1LL<<n;\n\tdp.assign(m+1,vector<ll>(mxn,0));\n\tdp[0][(mxn)-1]=1;\n\tfor (int r=1;r<=m;++r) {\n\t\tfor (ll state=0;state<mxn;++state) \n\t\t\tdp[r][state]=(dp[r][state]+dp[r-1][state^(mxn-1)])%MOD;\n\t\tfor (ll state=mxn-1;state>=0;--state) \n\t\t\tdp[r][state]=(dp[r][state]+suplement(dp[r],state,1))%MOD;\n\t\t\n\t}\n\tcout<<dp[m][mxn-1]<<'\\n';\n    return 0;\n}",
//   "2182":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll M=1000000007;\nll binpow(ll x,ll y,ll m){\n\tll re=1;\n\twhile(y){\n\t\tif (y&1) re=(re*x)%m;\n\t\ty>>=1;\n\t\tx=(x*x)%m;\n\t}\n\treturn re;\n}\nll sumTo(ll n,ll m){\n\treturn (n*(n+1)/2)%m;\n}\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tint n;\n\tcin>>n;\n\tvector<ll> invFac(n+1,1);\n\tvector<ll> fac(n+1,1);\n\tvector<array<int,2>> p(n);\n\tfor (int i=0;i<n;++i){\n\t\tcin>>p[i][0]>>p[i][1];\n\t}\n\t\n\tbool hasDiv2=false;\n\tll numOfDivisor=1;\n\tll numOfDivisor_1=1;\n\tfor (int i=0;i<n;++i){\n\t\tnumOfDivisor=(numOfDivisor*(p[i][1]+1))%M;\n\t\tif (p[i][1]%2&&!hasDiv2){\n\t\t\tnumOfDivisor_1=(numOfDivisor_1*((p[i][1]+1)/2))%(M-1);\n\t\t\thasDiv2=true;\n\t\t}\n\t\telse\n\t\t\tnumOfDivisor_1=(numOfDivisor_1*(p[i][1]+1))%(M-1);\n\t}\n\tcout<<numOfDivisor<<'\\n';\n\n\tll sumOfDivisor=1;\n\tfor (int i=0;i<n;++i){\n\t\tsumOfDivisor=(sumOfDivisor*(binpow(p[i][0],p[i][1]+1,M)-1)%M*binpow(p[i][0]-1,M-2,M)%M+M)%M;\n\t}\n\tcout<<sumOfDivisor<<'\\n';\n\n\tll productOfDivisor=1;\n\tfor (int i=0;i<n;++i){\n\t\tif (!hasDiv2) p[i][1]/=2;\n\t\tproductOfDivisor=(productOfDivisor*binpow(p[i][0],p[i][1]*numOfDivisor_1%(M-1),M)%M);\n\t}\n\n\tcout<<productOfDivisor<<'\\n';\n\treturn 0;\n}",
//   "2183":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\n\nint main(){\n\tfastio;\n\tint n;\n\tcin>>n;\n\tvector<int> a(n);\n\tfor (int &v:a)cin>>v;\n\tsort(a.begin(),a.end());\n\tll s=0;\n\tfor (int &v:a){\n\t\tif (v>s+1) {\n\t\t\tcout<<s+1<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t\ts+=v;\n\t}\n\tcout<<s+1<<'\\n';\n    return 0;\n}",
//   "2185":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n,k;\nll l[20];\nll gett(int idx,int ck,int cnt,ll curr){\n\tif (cnt==ck)\n\t\treturn n/curr;\n\tif (idx==k)\n\t\treturn 0;\n\tif (n/l[idx]+1<curr) return gett(idx+1,ck,cnt,curr);\n\treturn gett(idx+1,ck,cnt,curr)+ gett(idx+1,ck,cnt+1,curr*l[idx]);\n}\nint main(){\n\tcin>>n>>k;\n\tfor (int i=0;i<k;++i)cin>>l[i];\n\tll re=0;\n\tll tmp=1;\n\tfor (int i=1;i<=k;++i){\n\t\tre+=tmp*gett(0,i,0,1);\n\t\ttmp*=-1;\n\t}\n\tcout<<re<<'\\n';\n\treturn 0;\n}",
//   "2187":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll M=1000000007;\nvector<ll> invFac;\nvector<ll> fac;\n\nll binpow(ll x,ll y,ll m){\n\tll re=1;\n\twhile(y){\n\t\tif (y&1) re=(re*x)%m;\n\t\ty>>=1;\n\t\tx=(x*x)%m;\n\t}\n\treturn re;\n}\nll C(int n, int k){\n\treturn fac[n]*invFac[k]%M*invFac[n-k]%M;\n}\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tint n;\n\tcin>>n;\n\tif (n%2){\n\t\tcout<<0<<'\\n';\n\t\treturn 0;\n\t}\n\tstring s;\n\tcin>>s;\n\tint k=0;\n\tfor (char &c:s){\n\t\tif (c=='(') k+=1;\n\t\telse{\n\t\t\tk-=1;\n\t\t\tif (k<0){\n\t\t\t\tcout<<0<<'\\n';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t--n;\n\t}\n\tif (n<k){\n\t\tcout<<0<<'\\n';\n\t\treturn 0;\n\t}\n\tfac.assign(n+1,1);\n\tinvFac.assign(n+1,1);\n\tfor (int i=2;i<=n;++i){\n\t\tfac[i]=fac[i-1]*i%M;\n\t\tinvFac[i]=binpow(fac[i],M-2,M);\n\t}\n\tn=(n-k)/2;\n\tif (n==0){\n\t\tcout<<1<<'\\n';\n\t\treturn 0;\n\t}\n\tll re=C(2*n+k,n)-C(2*n+k,n-1)+M;\n\tre%=M;\n\tcout<<re<<'\\n';\n\treturn 0;\n}",
//   "2206":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int INF=2e9;\n\nvoid buildTree(int v, int tl, int tr,vector<int>&st,vector<int>&a){\n\tif (tl==tr){\n\t\tst[v]=a[tl];\n\t\treturn;\n\t}\n\tint mid = (tl+tr)>>1;\n\tbuildTree(v*2,tl,mid,st,a);\n\tbuildTree(v*2+1,mid+1,tr,st,a);\n\tst[v]=min(st[v*2],st[v*2+1]);\n}\n\nint get(int v, int l, int r, int tl, int tr,vector<int>&st){\n\tif (l>r) return INF;\n\tif (tl==l&&tr==r)return st[v];\n\tint mid=(tl+tr)>>1;\n\treturn min(get(v*2,l,min(mid,r),tl,mid,st),get(v*2+1,max(l,mid+1),r,mid+1,tr,st));\n}\n\nvoid update(int v, int tl, int tr, int pos,vector<int>&st,vector<int>&a){\n\tif (tl==tr){\n\t\tst[v]=a[pos];\n\t\treturn;\n\t}\n\tint mid=(tl+tr)>>1;\n\tif (pos<=mid) update(v*2,tl,mid,pos,st,a);\n\telse update(v*2+1,mid+1,tr,pos,st,a);\n\tst[v]=min(st[v*2],st[v*2+1]);\n}\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tint n,q;\n\tcin>>n>>q;\n\tvector<int> a1(n),a2(n),a(n);\n\tfor(int i=0;i<n;++i){\n\t\tcin>>a[i];\n\t\ta1[i]=a[i]-i-1;\n\t\ta2[i]=a[i]-n+i;\n\t}\n\tvector<int>st1(n*4),st2(n*4);\n\tbuildTree(1,0,n-1,st1,a1);\n\tbuildTree(1,0,n-1,st2,a2);\n\tfor (int i=0;i<q;++i){\n\t\tint t,pos;cin>>t>>pos;--pos;\n\t\tif (t==2){\n\t\t\tint re1=get(1,0,pos,0,n-1,st1)-a1[pos];\n\t\t\tint re2=get(1,pos,n-1,0,n-1,st2)-a2[pos];\n\t\t\tcout<<min(re1,re2)+a[pos]<<'\\n';\n\t\t}\n\t\telse {\n\t\t\tint val;cin>>val;\n\t\t\ta1[pos]+=val-a[pos];\n\t\t\ta2[pos]+=val-a[pos];\n\t\t\ta[pos]=val;\n\t\t\tupdate(1,0,n-1,pos,st1,a1);\n\t\t\tupdate(1,0,n-1,pos,st2,a2);\n\t\t}\n\t}\n\treturn 0;\n}",
//   "2207":
//     '#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int maxn=2000;\nll g[maxn+1];\n\nvoid setG(){\n\tg[0]=0;\n\tfor (int i=1;i<=maxn;++i){\n\t\tset<int>tmp;\n\t\tfor (int j=1;j*2<i;++j){\n\t\t\ttmp.insert(g[j]^g[i-j]);\n\t\t}\n\t\tfor ( g[i]=0;!tmp.empty();++g[i]){\n\t\t\tif (g[i]!=*(tmp.begin())) break;\n\t\t\ttmp.erase(tmp.begin());\n\t\t}\n\t}\n}\n\nvoid solve(int n){\n\tcout<<((n<=2000&&g[n]==0)?"second":"first")<<\'\\n\';\n}\n\nint main(){\n\tsetG();\n\tint t;cin>>t;\n\twhile (t--){\n\t\tint n;cin>>n;\n\t\tsolve(n);\n\t}\n\treturn 0;\n}',
//   "2208":
//     '#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(int n){\n\tbool o=false;\n\twhile (n--){\n\t\tint x;cin>>x;\n\t\tif (x%2)o=true;\n\t}\n\tcout<<(o?"first":"second")<<\'\\n\';\n}\n\nint main(){\n\tint t;cin>>t;\n\twhile (t--){\n\t\tint n;cin>>n;\n\t\tsolve(n);\n\t}\n\treturn 0;\n}',
//   "2216":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\n\nint main(){\n\tfastio;\n\tint n;\n\tcin>>n;\n\tvector<pair<int,int>> a(n);\n\tfor (int i=0;i<n;++i){\n\t\tcin>>a[i].first;\n\t\ta[i].second=i;\n\t}\n\tsort(a.begin(),a.end());\n\tll re=1;\n\tfor (int i=1;i<n;++i){\n\t\tif (a[i].second < a[i-1].second) ++re;\n\t}\n\tcout<<re<<'\\n';\n    return 0;\n}",
//   "2217":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false); cin.tie(NULL)\nusing namespace std;\n\nvector<pair<int,int>> a;\nvector<int> arr;\nint n,q;\n\nint change(int pos, int num){\n\tint re=0;\n\tif (pos>0){\n\t\tif (a[pos-1].second < a[pos].second && a[pos-1].second >= num) ++re;\n\t\tif (a[pos-1].second > a[pos].second && a[pos-1].second <= num) --re;\n\t}\n\tif (pos<n-1) {\n\t\tif (a[pos+1].second < a[pos].second && a[pos+1].second >= num) --re;\n\t\tif (a[pos+1].second > a[pos].second && a[pos+1].second <= num) ++re;\n\t}\n\ta[pos].second=num;\n\treturn re;\n}\n\nint main(){\n\tfastio;\n\tcin>>n>>q;\n\tarr.assign(n,0);\n\ta.assign(n,{0,0});\n\tfor (int i=0;i<n;++i){\n\t\tcin>>arr[i];\n\t\ta[i].first=arr[i];\n\t\ta[i].second=i;\n\t}\n\tsort(a.begin(),a.end());\n\tll re=1;\n\n\tfor (int i=1;i<n;++i){\n\t\tif (a[i].second < a[i-1].second) ++re;\n\t}\n\n\tfor (int i=0;i<q;++i){\n\t\tint x,y;\n\t\tcin>>x>>y;--x;--y;\n\t\tauto it1 = lower_bound(a.begin(),a.end(),make_pair(arr[x],-1));\n\t\tauto it2 = lower_bound(a.begin(),a.end(),make_pair(arr[y],-1));\n\t\tint ox=(*it1).second,oy=(*it2).second;\n\t\tre+=change(it1-a.begin(),oy);\n\t\tre+=change(it2-a.begin(),ox);\n\t\tswap(arr[x],arr[y]);\n\t\tcout<<re<<'\\n';\n\t}\n    return 0;\n}\t",
//   "2229":
//     "#include <bits/stdc++.h>\n#define fastio ios::sync_with_stdio(false);cin.tie(NULL)\n#define ll long long\n#define sz(x) (int)((x).size())\n#define all(x) x.begin(),x.end()\nusing namespace std;\n\nconst ll M=1000000007LL;\nint main(){\n\tfastio;\n\tint n,k;cin>>n>>k;\n\tif (k==0) {\n\t\tcout<<\"1\\n\";\n\t\treturn 0;\n\t}\n\tvector<vector<ll>> dp(n+1,vector<ll>(k+1,-1));\n\tfor (int i=1;i<=n;++i) dp[i][0]=1;\n\tfor (int j=1;j<=k;++j) dp[1][j]=1;\n\tfor (int i=2;i<=n;++i){\n\t\tfor (int j=1;j<=k;++j){\n\t\t\tdp[i][j]=(dp[i-1][j]-((j>=i)?dp[i-1][j-i]:0)+M)%M;\n\t\t\tif (i==n&&j==k) {\n\t\t\t\tcout<<dp[n][k]<<'\\n';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[i][j]=(dp[i][j]+dp[i][j-1])%M;\n\t\t}\n\t}\n}",
//   "2413":
//     "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\nconst ll MOD = 1000000007;\nconst int maxn = 1e6+0.5;\nll dp[maxn+1];\nint main() {\n\tdp[0]=1;dp[1]=2;\n\tll acu1=3, acu2=1;\n\tfor (int i=2;i<=maxn; ++i) {\n\t\tacu2=(acu2*3+dp[i-1])%MOD;\n\t\tdp[i]=(acu1+acu2)%MOD;\n\t\tacu1=(acu1+dp[i])%MOD;\n\t}\n\tint t;\n\tcin>>t;\n\tfor (int i=0;i<t;++i) {\n\t\tint x;cin>>x;\n\t\tcout<<dp[x]<<'\\n';\n\t}\n\treturn 0;\n}",
//   "2416":
//     "#include <bits/stdc++.h>\n#define ll long long\n#define fastio ios::sync_with_stdio(false);cin.tie(NULL)\nusing namespace std;\n\nconst int INF=1e9;\n\nint n,q;\nvector<int>a;\nvector<int>p;\nvector<ll>acu;\nvector<ll> F;\n\nll sumr(int l, int r){\n\treturn acu[r+1]-acu[l];\n}\n\nll sum(int idx){\n\tll re=0;\n\tfor (int i=idx;i>=0;i=(i&(i+1))-1){\n\t\tre+=F[i];\n\t}\n\treturn re;\n}\n\nll sum(int l,int r){\n\treturn sum(r)-sum(l-1);\n}\n\nvoid increase(int idx, ll add){\n\tfor (int i=idx;i<n;i=(i|(i+1))){\n\t\tF[i]+=add;\n\t}\n}\n\nint main(){\n\tfastio;\n\tcin>>n>>q;\n\ta.assign(n,0);\n\tF.assign(n,0);\n\tp.assign(n,-1);\n\tacu.assign(n+1,0);\n\tfor (int i=0;i<n;++i){\n\t\tcin>>a[i];\n\t\tacu[i+1]=acu[i]+a[i];\n\t}\n\t\n\tvector<array<int,2>> st;\n\tfor (int i=0;i<n;++i){\n\t\twhile (st.size()&&st.back()[0]<a[i]){\n\t\t\tp[st.back()[1]]=i-1;\n\t\t\tst.pop_back();\n\t\t}\n\t\tst.push_back({a[i],i});\n\t}\n\twhile (st.size()){\n\t\tp[st.back()[1]]=n-1;\n\t\tst.pop_back();\n\t}\n\t\n\tdeque<int> ans;\n\tfor (int i=0;i<n;i=p[i]+1){\n\t\tans.push_back(i);\n\t\tincrease(i,1LL*(p[i]-i+1)*a[i]);\n\t}\n\tvector<array<int,3>> query;\n\tfor (int i=0;i<q;++i){\n\t\tint l,r;cin>>l>>r;--l;--r;\n\t\tquery.push_back({l,r,i});\n\t}\n\tsort(query.begin(),query.end());\n\t\n\tstack<int>tmp;\n\tvector<ll> re(q,-1);\n\tfor (int i=0;i<q;++i){\n\t\tint l=query[i][0],r=query[i][1],idx=query[i][2];\n\t\twhile (l>ans[0]){\n\t\t\tint cur=ans[0]+1;\n\t\t\tans.pop_front();\n\t\t\tint nxt=(ans.size()>0)?ans[0]:n;\n\t\t\twhile (cur<nxt){\n\t\t\t\ttmp.push(cur);\n\t\t\t\tincrease(cur,1LL*(p[cur]-cur+1)*a[cur]);\n\t\t\t\tcur=p[cur]+1;\n\t\t\t}\n\t\t\twhile (!tmp.empty()){\n\t\t\t\tans.push_front(tmp.top());\n\t\t\t\ttmp.pop();\n\t\t\t}\n\t\t}\n\t\tauto it=upper_bound(ans.begin(),ans.end(),r);\n\t\tint e=ans[prev(it)-ans.begin()];\n\t\tre[idx]=sum(l,r)-1LL*a[e]*(p[e]-r)-sumr(l,r);\n\t\t\n\t}\n\tfor (int i=0;i<q;++i) cout<<re[i]<<'\\n';\n\t\n}",
//   "2417":
//     "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=1000000;\n\nvector<int> p(maxn+1,1);\nint m[maxn+1]={0};\n\nvoid sieve(){\n\tfor (int i=2;i<=maxn;++i) {\n\t\tll j=i*i;\n\t\tif (j>maxn) break;\n\t\tif (p[i]!=1) continue;\n\t\twhile (j<=maxn){\n\t\t\tif (p[j]==1) p[j]=i;\n\t\t\tj+=i;\n\t\t}\n\t}\n}\n\nvector<int> primeFac(int x){\n\tvector<int> re;\n\twhile (p[x]!=1){\n\t\tre.push_back(p[x]);\n\t\tint tmp=p[x];\n\t\twhile (x%tmp==0){\n\t\t\tx/=tmp;\n\t\t}\n\t}\n\tif (x!=1) re.push_back(x);\n\treturn re;\n}\n\nll Set(const vector<int>&a, int curr, int idx, int cnt){\n\tll re=0;\n\tif (idx==a.size()){\n\t\tif (curr>1){\n\t\t\tre= ((cnt%2)?1:-1) * m[curr];\n\t\t\t++m[curr];\n\t\t}\n\t}\n\telse{\n\t\tre=Set(a,curr*a[idx],idx+1,cnt+1)+Set(a,curr,idx+1,cnt);\n\t}\n\treturn re;\n}\n\nint main(){\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tsieve();\n\tll n;cin>>n;\n\tll re = (n-1)*n/2;\n\tfor (int i=0;i<n;++i){\n\t\tint a;cin>>a;\n\t\tre-=Set(primeFac(a),1,0,0);\n\t}\n\tcout<<re<<'\\n';\n\treturn 0;\n}",
//   "2428":
//     "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);cin.tie(NULL);\n\tint n,k;\n\tcin>>n>>k;\n\t\n\tvector<int>arr(n);\n\tmap<int,int> m;\n\tll re = 0;\n\n\tint beg=0;\n\tfor (int i=0; i<n; ++i) {\n\t\tcin>>arr[i];\n\t\tif (m.find(arr[i])==m.end() && m.size()==k) {\n\t\t\twhile (beg<=i) {\n\t\t\t\tauto it = m.find(arr[beg]);\n\t\t\t\t--(*it).second;\n\t\t\t\t++beg;\n\t\t\t\tif ((*it).second==0) {\n\t\t\t\t\tm.erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++m[arr[i]];\n\t\tll n1=i-beg+1;\n\t\tre+= n1;\n\t}\n\n\tcout<<re<<'\\n';\n\treturn 0;\n}",
//   "2431":
//     "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nchar solve(ll k) {\n\tll curr=0;\n\tll ten=9;\n\tll i =1;\n\twhile (true){\n\t\tif (k<=curr+ten*i) break;\n\t\tcurr+=ten*i;\n\t\t++i;\n\t\tten*=10LL;\n\t}\n\tcurr = k-curr-1;\n\treturn to_string(curr/i+ten/9)[curr%i];\n}\n\nint main(){\n\tint q;cin>>q;\n\tll k;\n\tfor (int i=0; i<q; ++i) {\n\t\tcin>>k;\n\t\tcout<<solve(k)<<'\\n';\n\t}\n\treturn 0;\n}",
// };

// const solution1: Record<string, string> = {
//   "1068":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long N;\n\nint main(){\n    scanf("%lld", &N);\n    while(N > 1){\n        printf("%lld ", N);\n        if(N&1) N = 3*N+1;\n        else    N >>= 1;\n    }\n    printf("1\\n");\n}\n',
//   "1069":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6+5;\n\nchar S[maxN];\nint N, cur, best;\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n    cur = best = 1;\n    for(int i = 1; i < N; i++){\n        if(S[i] == S[i-1])  cur++;\n        else                cur = 1;\n        best = max(best, cur);\n    }\n    printf("%d\\n", best);\n}\n',
//   "1071":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint T;\nll X, Y;\n\nll solve(ll x, ll y){\n    ll l = max(x, y)-1;\n    if(l&1){\n        if(x < y)   return l*l + x;\n        else        return l*l+2*l-y+2;\n    } else {\n        if(x < y)   return l*l+2*l-x+2;\n        else        return l*l + y;\n    }\n}\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        scanf("%lld %lld", &X, &Y);\n        printf("%lld\\n", solve(X, Y));\n    }\n}\n',
//   "1072":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\n\nint main(){\n    scanf("%d", &N);\n    for(int k = 1; k <= N; k++){\n        ll cnt = 1LL + (k-1)*(k-2)/2;\n        cnt = cnt * (k-1) * (k+4);\n        printf("%lld\\n", cnt);\n    }\n}\n',
//   "1073":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, k;\nmultiset<int> S;\nmultiset<int>::iterator it;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &k);\n        it = S.upper_bound(k);\n        if(it != S.end())\n            S.erase(it);\n        S.insert(k);\n    }\n    printf("%d\\n", (int) S.size());\n}\n',
//   "1074":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, p[maxN];\nll median, sum;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &p[i]);\n    sort(p, p+N);\n\n    median = p[(N-1)/2];\n    for(int i = 0; i < N; i++)\n        sum += abs(p[i]-median);\n    printf("%lld\\n", sum);\n}\n',
//   "1075":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1000;\nconst ll MOD = 1e9+7;\n\nint N;\nll dp[maxN+1];\n\nvoid init(){\n    dp[0] = dp[1] = 1;\n    dp[2] = dp[3] = 0;\n    for(int i = 4; i <= maxN; i++){\n        ll a = (i+1) * dp[i-1] % MOD;\n        ll b = (i-2) * dp[i-2] % MOD;\n        ll c = (i-5) * dp[i-3] % MOD;\n        ll d = (i-3) * dp[i-4] % MOD;\n\n        dp[i] = (a-b-c+d);\n        while(dp[i] < 0)\n            dp[i] += MOD;\n        dp[i] %= MOD;\n    }\n}\n\nint main(){\n    init();\n    scanf("%d", &N);\n    printf("%lld\\n", dp[N]);\n}\n',
//   "1076":
//     '#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5;\n\nint N, K, x[maxN];\ntree<pii, null_type, less<pii>, rb_tree_tag,\ntree_order_statistics_node_update> T;\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 0; i < K; i++){\n        scanf("%d", &x[i]);\n        T.insert({x[i], i});\n    }\n\n    printf("%d%c", (*T.find_by_order((K-1)/2)).first, (" \\n")[N==K]);\n    for(int i = K; i < N; i++){\n        scanf("%d", &x[i]);\n        T.insert({x[i], i});\n        T.erase({x[i-K], i-K});\n        printf("%d%c", (*T.find_by_order((K-1)/2)).first, (" \\n")[i==N-1]);\n    }\n}\n',
//   "1077":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, K, x[maxN];\nll losum, hisum;\nmultiset<int> lo, hi;\n\nll cost(){\n    ll median = *lo.rbegin();\n    ll locost = (median * lo.size()) - losum;\n    ll hicost = hisum - (median * hi.size());\n    return locost + hicost;\n}\n\nvoid lowToHigh(){\n    ll val = *lo.rbegin();\n    lo.erase(lo.lower_bound(val));\n    hi.insert(val);\n    losum -= val;\n    hisum += val;\n}\n\nvoid highToLow(){\n    ll val = *hi.begin();\n    lo.insert(val);\n    hi.erase(hi.lower_bound(val));\n    losum += val;\n    hisum -= val;\n}\n\nvoid adjust(){\n    int tot = (int) (lo.size() + hi.size());\n    if(lo.size() < (tot+1)/2)       highToLow();\n    else if(lo.size() > (tot+1)/2)  lowToHigh();\n}\n\nvoid erase(ll val){\n    ll median = *lo.rbegin();\n    if(val > median){\n        hi.erase(hi.lower_bound(val));\n        hisum -= val;\n    } else {\n        lo.erase(lo.lower_bound(val));\n        losum -= val;\n    }\n    adjust();\n}\n\nvoid insert(ll val){\n    if(lo.size() == 0){\n        lo.insert(val);\n        losum += val;\n        return;\n    }\n\n    ll median = *lo.rbegin();\n    if(val > median){\n        hi.insert(val);\n        hisum += val;\n    } else {\n        lo.insert(val);\n        losum += val;\n    }\n    adjust();\n}\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 0; i < K; i++){\n        scanf("%d", &x[i]);\n        insert(x[i]);\n    }\n\n    printf("%lld%c", cost(), (" \\n")[K==N]);\n    for(int i = K; i < N; i++){\n        scanf("%d", &x[i]);\n        insert(x[i]);\n        erase(x[i-K]);\n        printf("%lld%c", cost(), (" \\n")[i==N-1]);\n    }\n}',
//   "1079":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxA = 1e6;\nconst ll MOD = 1e9+7;\n\nint N, a, b;\nll fact[maxA+1], inv[maxA+1];\n\nll inverse(ll x){\n    ll res = 1;\n    ll expo = MOD-2;\n    while(expo > 0){\n        if(expo&1)\n            res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        expo >>= 1;\n    }\n    return res;\n}\n\nvoid init(){\n    fact[0] = inv[0] = 1;\n    for(int i = 1; i <= maxA; i++){\n        fact[i] = i * fact[i-1] % MOD;\n        inv[i] = inverse(fact[i]);\n    }\n}\n\nint main(){\n    init();\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d %d", &a, &b);\n        printf("%lld\\n", fact[a] * inv[b] % MOD * inv[a-b] % MOD);\n    }\n}\n',
//   "1080":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 505;\nconst ll MOD = 1e9+7;\n\nint N;\nchar S[maxN];\nll fac[maxN], inv[maxN], dp[maxN][maxN];\n\nll fastpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n        if(b&1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll choose(int n, int k){\n    if(k < 0 || n < k)  return 0;\n    return fac[n] * inv[k] % MOD * inv[n-k] % MOD;\n}\n\nvoid init(){\n    fac[0] = inv[0] = 1;\n    for(int i = 1; i < maxN; i++){\n        fac[i] = (fac[i-1] * i) % MOD;\n        inv[i] = fastpow(fac[i], MOD-2);\n    }\n\n    for(int i = 0; i < maxN; i++)\n        for(int j = i; j < maxN; j++)\n            dp[i][j] = -1;\n}\n\nll solve(int l, int r){\n    if((r-l+1)&1)       return 0;\n    if(l > r)           return 1;\n    if(dp[l][r] != -1)  return dp[l][r];\n\n    ll cnt = 0;\n    for(int m = l+1; m <= r; m++){\n        if(S[l] == S[m]){\n            ll subcases = solve(l+1, m-1) * solve(m+1, r) % MOD;\n            ll aftercombine = subcases * choose((r-l+1)/2, (m-l+1)/2) % MOD;\n            cnt = (cnt + aftercombine) % MOD;\n        }\n    }\n\n    return dp[l][r] = cnt;\n}\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n    init();\n    printf("%lld\\n", N&1 ? 0 : solve(0, N-1));\n}',
//   "1081":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxX = 1e6;\n\nint N, a, cnt, d[maxX+1];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &a);\n        d[a]++;\n    }\n    for(int i = maxX; i >= 1; i--){\n        cnt = 0;\n        for(int j = i; j <= maxX; j += i)\n            cnt += d[j];\n        if(cnt >= 2){\n            printf("%d\\n", i);\n            return 0;\n        }\n    }\n}\n',
//   "1082":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nll N, sum;\n\nll sigma(ll x){\n    return ((x%MOD)*((x+1)%MOD)/2)%MOD;\n}\n\nint main(){\n    scanf("%lld", &N);\n    for(ll l = 1; l <= N; l++){\n        ll r = N/(N/l);\n        sum += (N/l)%MOD*(sigma(r)-sigma(l-1)+MOD)%MOD;\n        sum = (sum+MOD)%MOD;\n        l = r;\n    }\n    printf("%lld\\n", sum);\n}\n',
//   "1083":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, x, xum;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++)\n        xum ^= i;\n    for(int i = 0; i < N-1; i++){\n        scanf("%d", &x);\n        xum ^= x;\n    }\n    printf("%d\\n", xum);\n}\n',
//   "1084":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, M, K, a[maxN], b[maxN];\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n    for(int i = 0; i < N; i++)  scanf("%d", &a[i]);\n    for(int i = 0; i < M; i++)  scanf("%d", &b[i]);\n\n    sort(a, a+N);\n    sort(b, b+M);\n\n    int cnt = 0;\n    int aptr = 0, bptr = 0;\n    while(aptr < N){\n        while(bptr < M && b[bptr] < a[aptr]-K)  bptr++;\n        if(bptr < M && a[aptr]-K <= b[bptr] && b[bptr] <= a[aptr]+K){\n            cnt++;\n            aptr++;\n            bptr++;\n        } else aptr++;\n    }\n    printf("%d\\n", cnt);\n}\n',
//   "1085":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, K, a[maxN];\nll lo = 0, hi = 1e18;\n\nbool check(ll X){\n    int k = 1;\n    ll sum = 0;\n    for(int i = 0; i < N; i++){\n        sum += a[i];\n        if(sum > X){\n            k++;\n            sum = a[i];\n        }\n    }\n    return k <= K;\n}\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &a[i]);\n        lo = max(lo, (ll) a[i]);\n    }\n\n    while(lo <= hi){\n        ll mid = lo + (hi-lo)/2;\n        if(check(mid))  hi = mid-1;\n        else            lo = mid+1;\n    }\n    printf("%lld\\n", lo);\n}\n',
//   "1086":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nll p[19];\n\nvoid init(){\n    p[0] = 1;\n    for(int i = 1; i <= 18; i++)\n        p[i] = p[i-1] * 10;\n}\n\nll check(ll N){\n    ll cnt = 0, l = N, r = 0;\n    for(int i = 0; l; i++){\n        int d = l % 10;\n        l /= 10;\n        cnt += (d == 1 ? l*p[i]+r+1 : (l+(d!=0))*p[i]);\n        r += p[i] * d;\n    }\n    return cnt;\n}\n\nint main(){\n    ll K;\n    scanf("%lld", &K);\n    ll lo = 1, hi = 1e18;\n    init();\n    while(hi-lo > 1){\n        ll mid = lo+(hi-lo)/2;\n        if(check(mid) <= K) lo = mid;\n        else                hi = mid;\n    }\n    printf("%lld\\n", lo);\n}',
//   "1087":
//     "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6+5;\n\nint N, cnt;\nchar S[maxN], ch[4] = {'A', 'C', 'G', 'T'};\nbool has[4];\nvector<int> segs;\nmap<char,int> mp;\n\nvoid init(){\n    mp['A'] = 0;\n    mp['C'] = 1;\n    mp['G'] = 2;\n    mp['T'] = 3;\n}\n\nint main(){\n    init();\n    scanf(\" %s\", S);\n\n    N = (int) strlen(S);\n    for(int i = 0; i < N; i++){\n        int c = mp[S[i]];\n        if(!has[c]){\n            has[c] = true;\n            cnt++;\n            if(cnt == 4){\n                fill(has, has+4, false);\n                segs.push_back(i);\n                cnt = 0;\n            }\n        }\n    }\n\n    for(int i : segs)\n        printf(\"%c\", S[i]);\n    for(int i = 0; i < 4; i++){\n        if(!has[i]){\n            printf(\"%c\\n\", ch[i]);\n            return 0;\n        }\n    }\n}",
//   "1090":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5;\n\nint N, X, l, ans, p[maxN];\n\nint main(){\n    scanf("%d %d", &N, &X);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &p[i]);\n    sort(p, p+N);\n\n    l = 0;\n    for(int r = N-1; r >= l; r--){\n        if(p[l] + p[r] <= X)\n            l++;\n        ans++;\n    }\n    printf("%d\\n", ans);\n}\n',
//   "1091":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, h, t;\nmultiset<int> prices;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &h);\n        prices.insert(-h);\n    }\n    for(int i = 0; i < M; i++){\n        scanf("%d", &t);\n        if(prices.lower_bound(-t) == prices.end())\n            printf("-1\\n");\n        else {\n            printf("%d\\n", -(*prices.lower_bound(-t)));\n            prices.erase(prices.lower_bound(-t));\n        }\n    }\n}\n',
//   "1093":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\n/**\n * A058377\n * Retrivied from https://oeis.org/A058377\n */\n\nint N, mp[501];\n\nvoid init(){\n    mp[3] = 1;\n    mp[4] = 1;\n    mp[7] = 4;\n    mp[8] = 7;\n    mp[11] = 35;\n    mp[12] = 62;\n    mp[15] = 361;\n    mp[16] = 657;\n    mp[19] = 4110;\n    mp[20] = 7636;\n    mp[23] = 49910;\n    mp[24] = 93846;\n    mp[27] = 632602;\n    mp[28] = 1199892;\n    mp[31] = 8273610;\n    mp[32] = 15796439;\n    mp[35] = 110826888;\n    mp[36] = 212681976;\n    mp[39] = 512776583;\n    mp[40] = 915017346;\n    mp[43] = 965991877;\n    mp[44] = 536015750;\n    mp[47] = 245739109;\n    mp[48] = 497111739;\n    mp[51] = 319303648;\n    mp[52] = 661531964;\n    mp[55] = 919134122;\n    mp[56] = 526597333;\n    mp[59] = 857860749;\n    mp[60] = 323065127;\n    mp[63] = 142897738;\n    mp[64] = 454622296;\n    mp[67] = 832964922;\n    mp[68] = 112945499;\n    mp[71] = 21130483;\n    mp[72] = 134912852;\n    mp[75] = 58392205;\n    mp[76] = 594756797;\n    mp[79] = 116285762;\n    mp[80] = 46020942;\n    mp[83] = 199311883;\n    mp[84] = 637852081;\n    mp[87] = 681073029;\n    mp[88] = 687587655;\n    mp[91] = 403293621;\n    mp[92] = 859161650;\n    mp[95] = 135570834;\n    mp[96] = 16951659;\n    mp[99] = 90174435;\n    mp[100] = 906443459;\n    mp[103] = 445036292;\n    mp[104] = 696064542;\n    mp[107] = 589938798;\n    mp[108] = 17765238;\n    mp[111] = 671699270;\n    mp[112] = 979144036;\n    mp[115] = 717567569;\n    mp[116] = 962408760;\n    mp[119] = 24874238;\n    mp[120] = 651719820;\n    mp[123] = 882521441;\n    mp[124] = 815306501;\n    mp[127] = 177673311;\n    mp[128] = 381523124;\n    mp[131] = 647107433;\n    mp[132] = 822743471;\n    mp[135] = 951125976;\n    mp[136] = 913762232;\n    mp[139] = 860772858;\n    mp[140] = 718799291;\n    mp[143] = 546548485;\n    mp[144] = 520899315;\n    mp[147] = 348826222;\n    mp[148] = 979465686;\n    mp[151] = 551269897;\n    mp[152] = 226367872;\n    mp[155] = 224237396;\n    mp[156] = 275455845;\n    mp[159] = 597702194;\n    mp[160] = 580526114;\n    mp[163] = 837164670;\n    mp[164] = 579854574;\n    mp[167] = 643888367;\n    mp[168] = 547744591;\n    mp[171] = 362172782;\n    mp[172] = 203753851;\n    mp[175] = 472078730;\n    mp[176] = 414960148;\n    mp[179] = 751350256;\n    mp[180] = 597996235;\n    mp[183] = 302890488;\n    mp[184] = 463389357;\n    mp[187] = 28369705;\n    mp[188] = 625260957;\n    mp[191] = 439010166;\n    mp[192] = 625343710;\n    mp[195] = 345211145;\n    mp[196] = 783212645;\n    mp[199] = 171026155;\n    mp[200] = 746149676;\n    mp[203] = 574908810;\n    mp[204] = 400819234;\n    mp[207] = 797285006;\n    mp[208] = 671068618;\n    mp[211] = 857904807;\n    mp[212] = 118539037;\n    mp[215] = 258515519;\n    mp[216] = 103887197;\n    mp[219] = 692754470;\n    mp[220] = 307691579;\n    mp[223] = 543477917;\n    mp[224] = 494845326;\n    mp[227] = 461141061;\n    mp[228] = 681627336;\n    mp[231] = 194431224;\n    mp[232] = 798222254;\n    mp[235] = 34177070;\n    mp[236] = 324550451;\n    mp[239] = 395144714;\n    mp[240] = 314224734;\n    mp[243] = 256354567;\n    mp[244] = 216295565;\n    mp[247] = 556521816;\n    mp[248] = 594547313;\n    mp[251] = 701665484;\n    mp[252] = 287171616;\n    mp[255] = 305999810;\n    mp[256] = 817725356;\n    mp[259] = 456522567;\n    mp[260] = 42456953;\n    mp[263] = 53352478;\n    mp[264] = 896195082;\n    mp[267] = 374247344;\n    mp[268] = 900048655;\n    mp[271] = 613110673;\n    mp[272] = 91338349;\n    mp[275] = 904876664;\n    mp[276] = 300880501;\n    mp[279] = 604541603;\n    mp[280] = 441166519;\n    mp[283] = 73667549;\n    mp[284] = 41483999;\n    mp[287] = 51276243;\n    mp[288] = 149197976;\n    mp[291] = 539103967;\n    mp[292] = 982253554;\n    mp[295] = 969982399;\n    mp[296] = 98482383;\n    mp[299] = 605461327;\n    mp[300] = 65785519;\n    mp[303] = 548373331;\n    mp[304] = 421491751;\n    mp[307] = 480765781;\n    mp[308] = 925355425;\n    mp[311] = 850819946;\n    mp[312] = 434384766;\n    mp[315] = 747079619;\n    mp[316] = 140715817;\n    mp[319] = 154291092;\n    mp[320] = 436737393;\n    mp[323] = 694334366;\n    mp[324] = 278298264;\n    mp[327] = 100011200;\n    mp[328] = 186925353;\n    mp[331] = 951803656;\n    mp[332] = 826521841;\n    mp[335] = 467206470;\n    mp[336] = 625245512;\n    mp[339] = 37014692;\n    mp[340] = 370302058;\n    mp[343] = 942594593;\n    mp[344] = 625802329;\n    mp[347] = 696810018;\n    mp[348] = 839447903;\n    mp[351] = 973813010;\n    mp[352] = 340829958;\n    mp[355] = 333578000;\n    mp[356] = 162910708;\n    mp[359] = 898163184;\n    mp[360] = 938735258;\n    mp[363] = 969420912;\n    mp[364] = 767331949;\n    mp[367] = 49040853;\n    mp[368] = 864361228;\n    mp[371] = 666086921;\n    mp[372] = 681324453;\n    mp[375] = 406330883;\n    mp[376] = 715350645;\n    mp[379] = 276425302;\n    mp[380] = 691275326;\n    mp[383] = 936153559;\n    mp[384] = 806887794;\n    mp[387] = 672700998;\n    mp[388] = 324056520;\n    mp[391] = 624244157;\n    mp[392] = 887151949;\n    mp[395] = 111928807;\n    mp[396] = 555201478;\n    mp[399] = 892266330;\n    mp[400] = 406976742;\n    mp[403] = 179624853;\n    mp[404] = 766709833;\n    mp[407] = 615024703;\n    mp[408] = 25276943;\n    mp[411] = 675398735;\n    mp[412] = 373735428;\n    mp[415] = 283235362;\n    mp[416] = 613728485;\n    mp[419] = 581407804;\n    mp[420] = 135760574;\n    mp[423] = 421029356;\n    mp[424] = 925084280;\n    mp[427] = 409496848;\n    mp[428] = 345330916;\n    mp[431] = 754684998;\n    mp[432] = 388429454;\n    mp[435] = 997193850;\n    mp[436] = 722803385;\n    mp[439] = 747396848;\n    mp[440] = 879532546;\n    mp[443] = 363180870;\n    mp[444] = 301109892;\n    mp[447] = 337814331;\n    mp[448] = 439172004;\n    mp[451] = 142119927;\n    mp[452] = 761228466;\n    mp[455] = 649629227;\n    mp[456] = 868002592;\n    mp[459] = 927500726;\n    mp[460] = 71856333;\n    mp[463] = 621649641;\n    mp[464] = 86464550;\n    mp[467] = 159973467;\n    mp[468] = 281964303;\n    mp[471] = 220801847;\n    mp[472] = 172221992;\n    mp[475] = 631635476;\n    mp[476] = 30971150;\n    mp[479] = 664722592;\n    mp[480] = 692804591;\n    mp[483] = 620001363;\n    mp[484] = 22371363;\n    mp[487] = 541326371;\n    mp[488] = 8514587;\n    mp[491] = 996643776;\n    mp[492] = 106479414;\n    mp[495] = 920757401;\n    mp[496] = 236457589;\n    mp[499] = 608650075;\n    mp[500] = 71857061;\n}\n\nint main(){\n    init();\n    scanf("%d", &N);\n    printf("%d\\n", mp[N]);\n}\n',
//   "1094":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll x, mx, sum;\n\nint main(){\n    scanf("%d", &N);\n    scanf("%lld", &mx);\n    for(int i = 1; i < N; i++){\n        scanf("%lld", &x);\n        mx = max(mx, x);\n        sum += (mx - x);\n    }\n    printf("%lld\\n", sum);\n}\n',
//   "1096":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nll N, x[6][6], y[6][6];\n\nvoid init(){\n    for(int i = 0; i < 6; i++)\n        x[0][i] = 1;\n    for(int i = 0; i < 5; i++)\n        x[i+1][i] = 1;\n    for(int i = 0; i < 6; i++)\n        y[i][i] = 1;\n}\n\nvoid mult(ll A[6][6], ll B[6][6]){\n    ll C[6][6];\n    memset(C, 0, sizeof(C));\n    for(int i = 0; i < 6; i++){\n        for(int j = 0; j < 6; j++){\n            for(int k = 0; k < 6; k++){\n                C[i][j] += A[i][k] * B[k][j];\n                C[i][j] %= MOD;\n            }\n        }\n    }\n    for(int i = 0; i < 6; i++)\n        for(int j = 0; j < 6; j++)\n            A[i][j] = C[i][j];\n}\n\nint main(){\n    init();\n\n    scanf("%lld", &N);\n    while(N){\n        if(N&1)\n            mult(y, x);\n        mult(x, x);\n        N >>= 1;\n    }\n\n    printf("%lld\\n", y[0][0]);\n}\n',
//   "1097":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 5000;\n\nint N, x[maxN+1];\nll p[maxN+1], dp[maxN+1][maxN+1];\nbool found[maxN+1][maxN+1];\n\nll sum(int l, int r){\n\treturn p[r] - p[l-1];\n}\n\nll solve(int l, int r){\n\tif(found[l][r])\treturn dp[l][r];\n\tif(l == r)\t\treturn x[l];\n\tfound[l][r]=true;\n\treturn dp[l][r] = max(x[l]+sum(l+1, r)-solve(l+1, r), x[r]+sum(l,r-1)-solve(l,r-1));\n}\n\nint main(){\n\tscanf("%d", &N);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf("%d", &x[i]);\n\t\tp[i] = p[i-1] + x[i];\n\t}\n\tprintf("%lld\\n", solve(1, N));\n}\n',
//   "1098":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T, N, x, xum;\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        scanf("%d", &N);\n        xum = 0;\n        for(int i = 0; i < N; i++){\n            scanf("%d", &x);\n            xum ^= (x%4);\n        }\n        printf(xum ? "first\\n" : "second\\n");\n    }\n}\n',
//   "1099":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T, N, p, xum;\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        scanf("%d", &N);\n        xum = 0;\n        for(int i = 0; i < N; i++){\n            scanf("%d", &p);\n            if(i%2)\n                xum ^= p;\n        }\n        printf(xum ? "first\\n" : "second\\n");\n    }\n}\n',
//   "1110":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e6+5;\n\nint N, F[maxN];\nchar S[maxN];\n\nint main(){\n    scanf("%s", S);\n\n    N = (int) strlen(S);\n    for(int i = 0; i < N; i++)\n        S[i+N] = S[i];\n\n    N = (int) strlen(S);\n    fill(F, F+N, -1);\n\n    int k = 0;\n    for(int i = 1; i < N; i++){\n        char c = S[i];\n        int f = F[i-k-1];\n        while(f != -1 && c != S[k+f+1]){\n            if(c < S[k+f+1])\n                k = i-f-1;\n            f = F[f];\n        }\n\n        if(c != S[k+f+1]){\n            if(c < S[k])\n                k = i;\n            F[i-k] = -1;\n        } else F[i-k] = f+1;\n    }\n\n    for(int i = 0; i < N/2; i++)\n        printf("%c", S[i+k]);\n}',
//   "1111":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6+5;\n\nchar S[maxN];\nint N, bestl, bestr, d1[maxN], d2[maxN];\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n\n    for(int i = 0, l = 0, r = -1; i < N; i++){\n        int k = (i > r ? 1 : min(d1[l+r-i], r-i+1));\n        while(0 <= i-k && i+k < N && S[i-k] == S[i+k])  k++;\n\n        if(2*k-1 > bestr-bestl+1){\n            bestl = i-k+1;\n            bestr = i+k-1;\n        }\n\n        d1[i] = k--;\n        if(i+k > r){\n            l = i-k;\n            r = i+k;\n        }\n    }\n\n    for(int i = 0, l = 0, r = -1; i < N; i++){\n        int k = (i > r ? 0 : min(d2[l+r-i+1], r-i+1));\n        while(0 <= i-k-1 && i+k < N && S[i-k-1] == S[i+k])  k++;\n\n        if(2*k > bestr-bestl+1){\n            bestl = i-k;\n            bestr = i+k-1;\n        }\n\n        d2[i] = k--;\n        if(i+k > r){\n            l = i-k-1;\n            r = i+k;\n        }\n    }\n\n    for(int i = bestl; i <= bestr; i++)\n        printf("%c", S[i]);\n}',
//   "1112":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1005, maxM = 505;\nconst ll MOD = 1e9+7;\n\nint N, M, best[26][maxM];\nchar S[maxN];\nll ans, dp[maxM][maxN];\n\nll pow26(ll b){\n    ll a = 26;\n    ll res = 1;\n    while(b){\n        if(b&1) res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nbool good(vector<char> pre, int k){\n    int SZ = (int) pre.size();\n    for(int i = 0; i < SZ-k; i++)\n        if(pre[i+k] != S[i])\n            return false;\n    return true;\n}\n\nint main(){\n    scanf("%d %s", &N, S);\n    M = (int) strlen(S);\n    if(M > N){\n        printf("0\\n");\n        return 0;\n    }\n\n    for(int r = 0; r < M; r++){\n        for(int c = 0; c < 26; c++){\n            vector<char> pre;\n            for(int i = 0; i < r; i++)\n                pre.push_back(S[i]);\n            pre.push_back((char) (c+\'A\'));\n\n            for(int k = 0; k < r+1; k++){\n                if(good(pre, k)){\n                    best[c][r] = r-k+1;\n                    break;\n                }\n            }\n        }\n    }\n\n    dp[0][0] = 1;\n    for(int i = 1; i <= N; i++)\n        for(int j = 0; j < M; j++)\n            for(int c = 0; c < 26; c++)\n                dp[best[c][j]][i] = (dp[best[c][j]][i] + dp[j][i-1]) % MOD;\n\n    ans = pow26(N);\n    for(int i = 0; i < M; i++)\n        ans = (ans - dp[i][N] + MOD) % MOD;\n    printf("%lld\\n", ans);\n}',
//   "1113":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6+5;\n\nint N, nxt[maxN];\nchar S[maxN];\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n    for(int i = 0; i < N; i++)  nxt[i] = i;\n    stable_sort(nxt, nxt+N, [](int a, int b){\n        return S[a] < S[b];\n    });\n\n    int ptr = nxt[0];\n    while(ptr != 0){\n        ptr = nxt[ptr];\n        printf("%c", S[ptr]);\n    }\n}',
//   "1130":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, a, b, cnt;\nbool used[maxN];\nvector<int> G[maxN];\n\nvoid dfs(int u = 1, int par = 0){\n    for(int v : G[u])\n        if(v != par)\n            dfs(v, u);\n\n    if(!used[par] && !used[u] && par != 0){\n        used[par] = used[u] = true;\n        cnt++;\n    }\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    dfs();\n    printf("%d\\n", cnt);\n}\n',
//   "1131":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, a, b, last, dist[maxN];\nvector<int> G[maxN];\n\nvoid dfs(int u, int p = 0){\n    for(int v : G[u]){\n        if(v != p){\n            dist[v] = dist[u]+1;\n            dfs(v, u);\n        }\n    }\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs(1);\n    for(int i = 1; i <= N; i++)\n        if(dist[i] > dist[last])\n            last = i;\n    dist[last] = 0;\n    dfs(last);\n    for(int i = 1; i <= N; i++)\n        if(dist[i] > dist[last])\n            last = i;\n    printf("%d\\n", dist[last]);\n}\n',
//   "1132":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, a, b, down[maxN], up[maxN], best[maxN];\nvector<int> G[maxN];\n\nvoid dfs1(int u = 1, int p = 0){\n    for(int v : G[u]){\n        if(v != p){\n            dfs1(v, u);\n            down[u] = max(down[u], down[v]+1);\n        }\n    }\n}\n\nvoid dfs2(int u = 1, int p = 0){\n    int first = 0, second = 0;\n    for(int v : G[u]){\n        if(v != p){\n            if(down[v] >= down[first]){\n                second = first;\n                first = v;\n            } else if(down[v] > down[second]){\n                second = v;\n            }\n        }\n    }\n\n    for(int v : G[u]){\n        if(v != p){\n            up[v] = max(up[v], up[u]+1);\n            if(v == first){\n                if(second != 0){\n                    up[v] = max(up[v], down[second]+2);\n                }\n            } else if(first != 0){\n                up[v] = max(up[v], down[first]+2);\n            }\n            dfs2(v, u);\n        }\n    }\n\n    best[u] = max(up[u], down[u]);\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs1();\n    dfs2();\n\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", best[i], (" \\n")[i==N]);\n}\n',
//   "1133":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, a, b, sz[maxN];\nll down[maxN], up[maxN];\nvector<int> G[maxN];\n\nvoid dfs1(int u = 1, int p = 0){\n    sz[u] = 1;\n    for(int v : G[u]){\n        if(v != p){\n            dfs1(v, u);\n            sz[u] += sz[v];\n            down[u] += down[v] + sz[v];\n        }\n    }\n}\n\nvoid dfs2(int u = 1, int p = 0){\n    if(p != 0)\n        up[u] = (up[p]+down[p]) + N - (2*sz[u]+down[u]);\n    for(int v : G[u])\n        if(v != p)\n            dfs2(v, u);\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs1();\n    dfs2();\n\n    for(int i = 1; i <= N; i++)\n        printf("%lld%c", down[i]+up[i], (" \\n")[i==N]);\n}\n',
//   "1135":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\nconst int logN = 20;\n\nint N, Q, a, b, p[maxN][logN];\nint timer, d[maxN], in[maxN], out[maxN];\nvector<int> G[maxN];\n\nvoid dfs(int u = 1, int par = 1){\n    in[u] = ++timer;\n    d[u] = d[par]+1;\n    p[u][0] = par;\n    for(int i = 1; i < logN; i++)\n        p[u][i] = p[p[u][i-1]][i-1];\n    for(int v : G[u])\n        if(v != par)\n            dfs(v, u);\n    out[u] = ++timer;\n}\n\nbool ancestor(int u, int v){\n    return in[u] <= in[v] && out[u] >= out[v];\n}\n\nint lca(int u, int v){\n    if(ancestor(u, v))  return u;\n    if(ancestor(v, u))  return v;\n    for(int i = logN-1; i >= 0; i--)\n        if(!ancestor(p[u][i], v))\n            u = p[u][i];\n    return p[u][0];\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs();\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &a, &b);\n        printf("%d\\n", d[a] + d[b] - 2*d[lca(a, b)]);\n    }\n}\n',
//   "1136":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\nconst int logN = 20;\n\nint N, M, a, b, sub[maxN], p[maxN][logN];\nint timer, in[maxN], out[maxN];\nvector<int> G[maxN];\n\nvoid dfs1(int u = 1, int par = 1){\n    in[u] = ++timer;\n    p[u][0] = par;\n    for(int i = 1; i < logN; i++)\n        p[u][i] = p[p[u][i-1]][i-1];\n    for(int v : G[u])\n        if(v != par)\n            dfs1(v, u);\n    out[u] = ++timer;\n}\n\nvoid dfs2(int u = 1){\n    for(int v : G[u]){\n        if(v != p[u][0]){\n            dfs2(v);\n            sub[u] += sub[v];\n        }\n    }\n}\n\nbool ancestor(int u, int v){\n    return in[u] <= in[v] && out[u] >= out[v];\n}\n\nint lca(int u, int v){\n    if(ancestor(u, v))  return u;\n    if(ancestor(v, u))  return v;\n    for(int i = logN-1; i >= 0; i--)\n        if(!ancestor(p[u][i], v))\n            u = p[u][i];\n    return p[u][0];\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs1();\n\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        int l = lca(a, b);\n        sub[a]++; sub[b]++;\n        sub[l]--;\n        if(l != 1)\n            sub[p[l][0]]--;\n    }\n\n    dfs2();\n\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", sub[i], (" \\n")[i==N]);\n}\n',
//   "1137":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, Q, a, b, t, s, timer;\nint in[maxN], out[maxN];\nll k[maxN], ds[2*maxN];\nvector<int> G[maxN];\n\nvoid update(int idx, ll val){\n    for(int i = idx; i < 2*maxN; i += i&-i)\n        ds[i] += val;\n}\n\nll query(int idx){\n    ll sum = 0;\n    for(int i = idx; i > 0; i -= i&-i)\n        sum += ds[i];\n    return sum;\n}\n\nvoid dfs(int u, int p = 0){\n    in[u] = ++timer;\n    for(int v : G[u])\n        if(v != p)\n            dfs(v, u);\n    out[u] = ++timer;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++)\n        scanf("%lld", &k[i]);\n\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    timer = 0;\n    dfs(1);\n\n    for(int i = 1; i <= N; i++)\n        update(out[i], k[i]);\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &t, &s);\n        if(t == 1){\n            update(out[s], -k[s]);\n            scanf("%lld", &k[s]);\n            update(out[s], k[s]);\n        } else if(t == 2){\n            printf("%lld\\n", query(out[s])-query(in[s]));\n        }\n    }\n}\n',
//   "1139":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef array<int,3> triple;\nconst int maxN = 2e5+1;\n\nint N, a, b, c[maxN], x[2*maxN], ptr[2*maxN], ds[2*maxN], ans[maxN];\nint timer, in[maxN], out[maxN];\ntriple queries[maxN];\nvector<int> G[maxN];\nmap<int,int> mp;\nset<int> S;\n\nvoid dfs(int u = 1, int p = 0){\n    in[u] = ++ timer;\n    for(int v : G[u])\n        if(v != p)\n            dfs(v, u);\n    out[u] = ++timer;\n}\n\nvoid update(int idx, int val){\n    for(int i = idx; i <= 2*N; i += -i&i)\n        ds[i] += val;\n}\n\nint query(int idx){\n    int sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum += ds[i];\n    return sum;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &c[i]);\n\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    dfs();\n\n    for(int i = 1; i <= N; i++)\n        x[in[i]] = x[out[i]] = c[i];\n\n    for(int i = 2*N; i > 0; i--){\n        if(mp[x[i]])\n            ptr[i] = mp[x[i]];\n        mp[x[i]] = i;\n    }\n\n    for(int i = 1; i <= 2*N; i++){\n        if(S.count(x[i]) == 0)\n            update(i, 1);\n        S.insert(x[i]);\n    }\n\n    for(int i = 1; i <= N; i++)\n        queries[i-1] = {in[i], out[i], i-1};\n    sort(queries, queries+N);\n\n    int l = 1;\n    for(int i = 0; i < N; i++){\n        while(l < queries[i][0]){\n            if(ptr[l])\n                update(ptr[l], 1);\n            l++;\n        }\n        ans[queries[i][2]] = query(queries[i][1]) - query(queries[i][0]-1);\n    }\n\n    for(int i = 0; i < N; i++)\n        printf("%d%c", ans[i], (" \\n")[i==N-1]);\n}\n',
//   "1140":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5+1;\n\nint N, a[maxN], b[maxN];\nll p[maxN], dp[2*maxN];\nstruct project {int time, id, type;} times[2*maxN];\nmap<int,int> mp;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++){\n        scanf("%d %d %lld", &a[i], &b[i], &p[i]);\n        times[2*i] = {a[i], i, 0};\n        times[2*i+1] = {b[i], i, 1};\n    }\n\n    sort(times+2, times+2*N+2, [](project A, project B){\n        return A.time == B.time ? A.id < B.id : A.time < B.time;\n    });\n\n    for(int i = 2; i <= 2*N+1; i++)\n        if(!mp[times[i].time])\n            mp[times[i].time] = i;\n\n    for(int i = 2; i <= 2*N+1; i++){\n        if(times[i].type == 0)  dp[i] = dp[i-1];\n        else dp[i] = max(dp[i-1], dp[mp[a[times[i].id]]-1] + p[times[i].id]);\n    }\n    printf("%lld\\n", dp[2*N+1]);\n}\n',
//   "1141":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, k, l, ans;\nmap<int,int> mp;\n\nint main(){\n    scanf("%d", &N);\n\n    l = 1;\n    for(int r = 1; r <= N; r++){\n        scanf("%d", &k);\n        if(mp[k]){\n            ans = max(ans, r-l);\n            l = max(l, mp[k]+1);\n            mp[k] = r;\n        } else {\n            ans = max(ans, r-l+1);\n            mp[k] = r;\n        }\n    }\n\n    ans = max(N-l+1, ans);\n    printf("%d\\n", ans);\n}\n',
//   "1142":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+5;\n\nint N, l[maxN], r[maxN];\nll best, a[maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++)\n        scanf("%lld", &a[i]);\n\n    for(int i = 1; i <= N; i++){\n        l[i] = i-1;\n        while(a[l[i]] >= a[i])\n            l[i] = l[l[i]];\n    }\n    for(int i = N; i >= 1; i--){\n        r[i] = i+1;\n        while(a[r[i]] >= a[i])\n            r[i] = r[r[i]];\n    }\n\n    for(int i = 1; i <= N; i++)\n        best = max(best, (r[i]-l[i]-1)*a[i]);\n    printf("%lld\\n", best);\n}\n',
//   "1143":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, M, h[maxN], k, ans;\nint lo[4*maxN], hi[4*maxN], mx[4*maxN], mp[maxN];\n\nvoid pull(int i){\n    mx[i] = (h[mx[2*i]] >= h[mx[2*i+1]] ? mx[2*i] : mx[2*i+1]);\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        mp[l] = i;\n        mx[i] = l;\n        return;\n    }\n    int m = l+(r-l)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid update(int i, int v){\n    h[i] -= v;\n    i = mp[i];\n    i >>= 1;\n    while(i > 0){\n        pull(i);\n        i >>= 1;\n    }\n}\n\nint find(int i, int v){\n    if(lo[i] == hi[i])  return lo[i];\n    return (h[mx[2*i]] >= v ? find(2*i, v) : find(2*i+1, v));\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &h[i]);\n    init(1, 1, N);\n\n    for(int i = 0; i < M; i++){\n        scanf("%d", &k);\n        ans = h[mx[1]] < k ? 0 : find(1, k);\n        if(ans) update(ans, k);\n        printf("%d%c", ans, (" \\n")[i==M-1]);\n    }\n}\n',
//   "1144":
//     '#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5;\n\nchar c;\nint N, Q, a, b, p[maxN+1];\ntree<pii, null_type, less<pii>, rb_tree_tag,\ntree_order_statistics_node_update> T;\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &p[i]);\n        T.insert({p[i], i});\n    }\n\n    for(int i = 0; i < Q; i++){\n        scanf(" %c %d %d", &c, &a, &b);\n        if(c == \'!\'){\n            T.erase({p[a], a});\n            T.insert({b, a});\n            p[a] = b;\n        } else if(c == \'?\'){\n            printf("%ld\\n", T.order_of_key({b+1, 0}) - T.order_of_key({a, 0}));\n        }\n    }\n}\n',
//   "1145":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, a;\nmultiset<int> S;\nmultiset<int>::iterator it;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &a);\n        S.insert(a);\n        it = S.lower_bound(a);\n        it++;\n        if(it != S.end())\n            S.erase(it);\n    }\n    printf("%d\\n", (int) S.size());\n}\n',
//   "1146":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nll N;\nmap<ll,ll> dp;\n\nll f(ll a){\n    if(a == 0)  return 0;\n    if(dp[a])   return dp[a];\n    if(a&1)     return dp[a] = 2*f(a/2)+(a/2)+1;\n    else        return dp[a] = f(a/2)+f(a/2-1)+(a/2);\n}\n\nint main(){\n    scanf("%lld", &N);\n    printf("%lld\\n", f(N));\n}\n',
//   "1147":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1002;\n\nint N, M, best, h[maxN], l[maxN], r[maxN];\nchar S[maxN][maxN];\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < N; i++)\n        scanf(" %s", S[i]);\n\n    h[0] = h[M+1] = -1;\n    for(int i = 1; i <= N; i++){\n        for(int j = 1; j <= M; j++)\n            h[j] = (S[i-1][j-1] == \'*\' ? 0 : h[j]+1);\n\n        int smaller;\n        for(int j = 1; j <= M; j++){\n            smaller = j-1;\n            while(h[smaller] >= h[j])\n                smaller = l[smaller];\n            l[j] = smaller;\n        }\n        for(int j = M; j >= 1; j--){\n            smaller = j+1;\n            while(h[smaller] >= h[j])\n                smaller = r[smaller];\n            r[j] = smaller;\n        }\n\n        for(int j = 1; j <= M; j++){\n            int base = r[j]-l[j]-1;\n            best = max(best, base * h[j]);\n        }\n    }\n\n    printf("%d\\n", best);\n}',
//   "1149":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 5e5+5;\nconst ll MOD = 1e9+7;\n\nint N;\nll tot, dp[26];\nchar S[maxN];\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n    for(int i = 0; i < N; i++){\n        int c = (int) (S[i] - \'a\');\n        dp[c]++;\n        for(int j = 0; j < 26; j++)\n            if(j != c)\n                dp[c] = (dp[c] + dp[j]) % MOD;\n    }\n\n    for(int i = 0; i < 26; i++)\n        tot = (tot + dp[i]) % MOD;\n    printf("%lld\\n", tot);\n}',
//   "1157":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint x, y;\n\nint main(){\n    scanf("%d %d", &x, &y);\n    printf("%d\\n", (x-1)^(y-1));\n}\n',
//   "1159":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 100, maxK = 1000, maxX = 1e5+1;\n\nint N, X, h[maxN], s[maxN], k[maxN];\nll dp[maxX];\n\nint main(){\n    scanf("%d %d", &N, &X);\n    for(int i = 0; i < N; i++)  scanf("%d", &h[i]);\n    for(int i = 0; i < N; i++)  scanf("%d", &s[i]);\n    for(int i = 0; i < N; i++)  scanf("%d", &k[i]);\n\n    fill(dp+1, dp+X+1, -1);\n    for(int i = 0; i < N; i++){\n        for(int b = 1; k[i] > 0; b++){\n            int amnt = min(b, k[i]);\n            k[i] -= b;\n            int price = amnt * h[i];\n            int pages = amnt * s[i];\n            for(int j = X; j >= price; j--)\n                if(dp[j-price] != -1)\n                    dp[j] = max(dp[j], dp[j-price] + pages);\n        }\n    }\n\n    for(int i = 1; i <= X; i++)\n        dp[i] = max(dp[i], dp[i-1]);\n    printf("%lld\\n", dp[X]);\n}',
//   "1160":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1, logN = 20;\n\nbool vis[maxN];\nint N, Q, ds[maxN], d[maxN], comp[maxN], cyc[maxN], p[logN][maxN];\nvector<int> cycleSeeds, G[maxN];\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nvoid init_parents(){\n    for(int i = 1; i < logN; i++)\n        for(int j = 1; j <= N; j++)\n            p[i][j] = p[i-1][p[i-1][j]];\n}\n\nint travel(int u, int k){\n    int v = u;\n    for(int i = logN-1; i >= 0; i--)\n        if(k&(1<<i))\n            v = p[i][v];\n    return v;\n}\n\nvoid dfs(int u, int compID){\n    vis[u] = true;\n    comp[u] = compID;\n    for(int v : G[u]){\n        if(!vis[v]){\n            d[v] = d[u]+1;\n            dfs(v, compID);\n        } else cyc[u] = d[u]+1;\n        cyc[u] = max(cyc[u], cyc[v]);\n    }\n}\n\nint query(int a, int b){\n    if(a == b)  return 0;\n\n    // Start and end are on different components\n    if(comp[a] != comp[b])  return -1;\n\n    // Start is on cycle\n    if(cyc[a]){\n        if(!cyc[b]) return -1;\n        return (d[a]-d[b]+cyc[a]) % cyc[a];\n    }\n\n    // Start and end are on tree (must check if same tree)\n    if(!cyc[b]){\n        if(d[a] <= d[b])    return -1;\n        int dist = d[a]-d[b];\n        return (travel(a, dist) == b) ? dist : -1;\n    }\n\n    // Start is on tree and end is on cycle\n    int root = a;\n    for(int i = logN-1; i >= 0; i--){\n        int par = p[i][root];\n        if(!cyc[par])\n            root = par;\n    }\n    root = p[0][root];\n\n    return (d[a]-d[root]) + query(root, b);\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    fill(ds+1, ds+N+1, -1);\n    for(int i = 1, x; i <= N; i++){\n        scanf("%d", &x);\n        p[0][i] = x;\n        G[x].push_back(i);\n        if(!merge(x, i))\n            cycleSeeds.push_back(x);\n    }\n\n    init_parents();\n    int compID = 1;\n    for(int seed : cycleSeeds)\n        dfs(seed, compID++);\n\n    for(int i = 0, a, b; i < Q; i++){\n        scanf("%d %d", &a, &b);\n        printf("%d\\n", query(a, b));\n    }\n}',
//   "1161":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N, x, d;\nll sum;\npriority_queue<int, vector<int>, greater<int>> sticks;\n\nint main(){\n    scanf("%d %d", &x, &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &d);\n        sticks.push(d);\n    }\n    while(sticks.size() > 1){\n        int a = sticks.top(); sticks.pop();\n        int b = sticks.top(); sticks.pop();\n        sticks.push(a+b);\n        sum += a + b;\n    }\n    printf("%lld\\n", sum);\n}\n',
//   "1162":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+5;\n\nint N, x[maxN], ds[maxN];\nll bit[maxN], ans[4];\nset<int> S;\nset<int>::iterator it;\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nvoid update(int idx, int val){\n    for(int i = idx; i < maxN; i += -i&i)\n        bit[i] += val;\n}\n\nll query(int idx){\n    int sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum += bit[i];\n    return sum;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &x[i]);\n\n    int K = N;\n    ans[3] = N;\n    fill(ds+1, ds+N+1, -1);\n    for(int i = 1; i <= N; i++){\n        ans[0] += (i-query(x[i])-1);\n        update(x[i], 1);\n\n        if(!merge(i, x[i]))\n            ans[1] += (-ds[find(i)]-1);\n\n        S.insert(x[i]);\n        it = S.lower_bound(x[i]);\n        if(++it != S.end())\n            S.erase(it);\n\n        if(x[N-i+1] == K){\n            K--;\n            ans[3]--;\n        }\n    }\n    ans[2] = N - (int) S.size();\n\n    for(int i = 0; i < 4; i++)\n        printf("%lld%c", ans[i], (" \\n")[i==3]);\n}',
//   "1163":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5;\n\nset<int> S;\nset<int>::iterator f, c, b;\nint N, X, a, best, ans[maxN];\nstruct light {int pos, id;} x[maxN+2];\n\nint main(){\n    scanf("%d %d", &X, &N);\n    x[0] = {0, 0}; x[N+1] = {X, 1};\n    S.insert(0); S.insert(X);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &a);\n        x[i+1] = {a, i+2};\n        S.insert(a);\n    }\n\n    sort(x, x+maxN+2, [](light A, light B){\n        return A.pos < B.pos;\n    });\n    for(int i = 1; i <= maxN+1; i++)\n        best = max(best, x[i].pos - x[i-1].pos);\n\n    sort(x, x+maxN+2, [](light A, light B){\n        return A.id > B.id;\n    });\n    for(int i = 0; i < N; i++){\n        ans[N-i-1] = best;\n        c = S.find(x[i].pos);\n        f = next(c, 1);\n        b = next(c, -1);\n        best = max(best, *f - *b);\n        S.erase(c);\n    }\n\n    for(int i = 0; i < N; i++)\n        printf("%d%c", ans[i], (" \\n")[i==N]);\n}\n',
//   "1164":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5;\n\nset<int> S;\nint N, a, b, rooms, ans[maxN+1];\nstruct query {int type, time, id;} queries[2*maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        S.insert(i+1);\n        scanf("%d %d", &a, &b);\n        queries[2*i] = {0, a, i+1};\n        queries[2*i+1] = {1, b, i+1};\n    }\n\n    sort(queries, queries+2*N, [](query A, query B){\n        if(A.id == B.id)    return A.type < B.type;\n        return A.time == B.time ? A.type < B.type : A.time < B.time;\n    });\n\n    for(int i = 0; i < 2*N; i++){\n        if(queries[i].type == 0){\n            ans[queries[i].id] = *S.begin();\n            S.erase(S.begin());\n        } else if(queries[i].type == 1){\n            S.insert(ans[queries[i].id]);\n        }\n    }\n\n    for(int i = 1; i <= N; i++)\n        rooms = max(rooms, ans[i]);\n\n    printf("%d\\n", rooms);\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", ans[i], (" \\n")[i==N]);\n}\n',
//   "1188":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\nconst int SIZE = 4*maxN;\n\nint N, M, mp[maxN], lo[SIZE], hi[SIZE], dp[3][SIZE];\nchar S[maxN];\n\nint len(int i){\n    return hi[i]-lo[i]+1;\n}\n\nint combine(int a, int b){\n    return ((a<0)^(b<0)) ? a : a+b;\n}\n\nbool allsame(int i){\n    return abs(dp[2][i]) == len(i);\n}\n\nvoid pull(int i){\n    dp[0][i] = (allsame(2*i) ? combine(dp[0][2*i], dp[0][2*i+1]) : dp[0][2*i]);\n    dp[1][i] = (allsame(2*i+1) ? combine(dp[1][2*i+1], dp[1][2*i]) : dp[1][2*i+1]);\n    dp[2][i] = max(abs(combine(dp[1][2*i], dp[0][2*i+1])), max(dp[2][2*i], dp[2][2*i+1]));\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        mp[l] = i;\n        dp[0][i] = dp[1][i] = (S[l-1] == \'0\' ? -1 : 1);\n        dp[2][i] = abs(dp[0][i]);\n        return;\n    }\n    int m = (l+r)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid update(int idx){\n    int i = mp[idx];\n    dp[0][i] *= -1;\n    dp[1][i] = dp[0][i];\n\n    i >>= 1;\n    while(i){\n        pull(i);\n        i >>= 1;\n    }\n}\n\nint query(){\n    return dp[2][1];\n}\n\nint main(){\n    scanf("%s %d", S, &M);\n    N = (int) strlen(S);\n    init(1, 1, N);\n    for(int i = 0, x; i < M; i++){\n        scanf("%d", &x);\n        update(x);\n        printf("%d%c", query(), (" \\n")[i==M-1]);\n    }\n}\n',
//   "1189":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, A[maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++)  scanf("%d", &A[i]);\n    for(int i = 1, b; i <= N; i++){\n        scanf("%d", &b);\n        A[i] += (A[i-1] - b);\n    }\n    sort(A+1, A+N+1);\n\n    ll ans = 0;\n    for(int i = 1; i <= N; i++)\n        ans += abs(A[i] - A[(N+1)/2]);\n    printf("%lld\\n", ans);\n}',
//   "1190":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int SIZE = 8e5;\n\nint N, Q, k, lo[SIZE], hi[SIZE], mp[SIZE];\nll x, sum[SIZE], dp[SIZE], dpl[SIZE], dpr[SIZE];\n\nvoid pull(int i){\n    dpl[i] = max(dpl[2*i], sum[2*i] + dpl[2*i+1]);\n    dpr[i] = max(dpr[2*i+1], sum[2*i+1] + dpr[2*i]);\n    dp[i] = max(dpr[2*i] + dpl[2*i+1], max(dp[2*i], dp[2*i+1]));\n    sum[i] = sum[2*i] + sum[2*i+1];\n}\n\nvoid build(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        scanf("%lld", &sum[i]);\n        dpl[i] = dpr[i] = dp[i] = sum[i];\n        mp[l] = i;\n        return;\n    }\n    int m = l+(r-l)/2;\n    build(2*i, l, m);\n    build(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid update(int a, ll b){\n    a = mp[a];\n\n    dpl[a] = dpr[a] = dp[a] = sum[a] = b;\n    a >>= 1;\n    while(a > 0){\n        pull(a);\n        a >>= 1;\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n\n    build(1, 1, N);\n    for(int q = 0; q < Q; q++){\n        scanf("%d %lld", &k, &x);\n        update(k, x);\n        printf("%lld\\n", max(0LL, dp[1]));\n    }\n}\n',
//   "1191":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, last[maxN];\nll K, x[2*maxN];\n\nint main(){\n    scanf("%d %lld", &N, &K);\n    for(int i = 0; i < N; i++){\n        scanf("%lld", &x[i]);\n        x[i+N] = x[i];\n    }\n\n    int r = 0;\n    ll sum = 0;\n    for(int l = 0; l < N; l++){\n        while(r < l+N && sum + x[r] <= K){\n            sum += x[r];\n            r++;\n        }\n        last[l] = r % N;\n        sum -= x[l];\n    }\n\n    int opt = 0;\n    for(int i = 0; i < N; i++)\n        opt = last[opt];\n\n    int cnt = 1;\n    sum = x[opt];\n    for(int i = opt+1; i < N+opt; i++){\n        if(sum + x[i] <= K) sum += x[i];\n        else {\n            sum = x[i];\n            cnt++;\n        }\n    }\n\n    printf("%d\\n", cnt);\n}',
//   "1192":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar c;\nint N, M, cnt;\nint h[] = {1, -1, 0, 0}, v[] = {0, 0, 1, -1};\nbool vis[1000][1000];\n\nvoid dfs(int x, int y){\n    vis[x][y] = true;\n    for(int i = 0; i < 4; i++){\n        int dx = x+h[i], dy = y+v[i];\n        if(0 <= dx && dx < N && 0 <= dy && dy < M && !vis[dx][dy])\n            dfs(dx, dy);\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < M; j++){\n            scanf(" %c", &c);\n            vis[i][j] = (c == \'#\');\n        }\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < M; j++){\n            if(!vis[i][j]){\n                dfs(i, j);\n                cnt++;\n            }\n        }\n    }\n    printf("%d\\n", cnt);\n}\n',
//   "1193":
//     "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n\nconst int h[] = {1, -1, 0, 0}, v[] = {0, 0, 1, -1};\n\nbool vis[1000][1000];\nchar c, par[1000][1000], ans[1000000];\nint N, M, sx, sy, ex, ey, dist[1000][1000];\nqueue<pii> Q;\n\n\nint main(){\n    scanf(\"%d %d\", &N, &M);\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < M; j++){\n            scanf(\" %c\", &c);\n            if(c == '#')    vis[i][j] = true;\n            else if(c == 'A'){\n                sx = i; sy = j;\n            } else if(c == 'B'){\n                ex = i; ey = j;\n            }\n        }\n    }\n\n    vis[sx][sy] = true;\n    Q.push({sx, sy});\n    while(!Q.empty()){\n        pii P = Q.front(); Q.pop();\n        for(int i = 0; i < 4; i++){\n            int dx = P.x+h[i];\n            int dy = P.y+v[i];\n            if(0 <= dx && dx < N && 0 <= dy && dy < M && !vis[dx][dy]){\n                if(i == 0)      par[dx][dy] = 'D';\n                else if(i == 1) par[dx][dy] = 'U';\n                else if(i == 2) par[dx][dy] = 'R';\n                else if(i == 3) par[dx][dy] = 'L';\n                dist[dx][dy] = dist[P.x][P.y]+1;\n                vis[dx][dy] = true;\n                Q.push({dx, dy});\n            }\n        }\n    }\n\n    if(!vis[ex][ey]){\n        printf(\"NO\\n\");\n        return 0;\n    }\n\n    printf(\"YES\\n%d\\n\", dist[ex][ey]);\n    pii P = {ex, ey};\n    for(int i = dist[ex][ey]; i > 0; i--){\n        ans[i] = par[P.x][P.y];\n        if(ans[i] == 'D')       P = {P.x-1, P.y};\n        else if(ans[i] == 'U')  P = {P.x+1, P.y};\n        else if(ans[i] == 'R')  P = {P.x, P.y-1};\n        else if(ans[i] == 'L')  P = {P.x, P.y+1};\n    }\n    for(int i = 1; i <= dist[ex][ey]; i++)\n        printf(\"%c\", ans[i]);\n    printf(\"\\n\");\n}\n",
//   "1194":
//     "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1000;\nconst int INF = 0x3f3f3f3f;\n\nint h[] = {1, -1, 0, 0};\nint v[] = {0, 0, 1, -1};\nstruct point { int x, y; };\n\nint N, M, sx, sy;\nbool vis[maxN][maxN];\nchar ans[maxN*maxN], c[maxN][maxN], p[maxN][maxN];\nint d1[maxN][maxN], d2[maxN][maxN];\nqueue<point> Q;\n\nbool inbounds(int x, int y){\n    return 0 <= x && x < N && 0 <= y && y < M;\n}\n\nvoid printsolution(int x, int y){\n    int D = d2[x][y];\n    printf(\"YES\\n%d\\n\", D);\n    for(int i = D-1; i >= 0; i--){\n        ans[i] = p[x][y];\n        if(ans[i] == 'D')       x--;\n        else if(ans[i] == 'U')  x++;\n        else if(ans[i] == 'R')  y--;\n        else if(ans[i] == 'L')  y++;\n    }\n    for(int i = 0; i < D; i++)\n        printf(\"%c\", ans[i]);\n    printf(\"\\n\");\n}\n\nint main(){\n    scanf(\"%d %d\", &N, &M);\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < M; j++){\n            scanf(\" %c\", &c[i][j]);\n            if(c[i][j] == '#')  vis[i][j] = true;\n            else if(c[i][j] == 'M'){\n                vis[i][j] = true;\n                Q.push({i, j});\n            } else if(c[i][j] == 'A'){\n                sx = i; sy = j;\n            }\n        }\n    }\n\n    while(!Q.empty()){\n        point P = Q.front(); Q.pop();\n        for(int i = 0; i < 4; i++){\n            int x = P.x + h[i];\n            int y = P.y + v[i];\n            if(inbounds(x, y) && !vis[x][y]){\n                d1[x][y] = d1[P.x][P.y] + 1;\n                vis[x][y] = true;\n                Q.push({x, y});\n            }\n        }\n    }\n\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < M; j++){\n            if(!vis[i][j])  d1[i][j] = INF;\n            vis[i][j] = (c[i][j] == '#');\n        }\n    }\n\n    vis[sx][sy] = true;\n    Q.push({sx, sy});\n    while(!Q.empty()){\n        point P = Q.front(); Q.pop();\n        for(int i = 0; i < 4; i++){\n            int x = P.x + h[i];\n            int y = P.y + v[i];\n            if(inbounds(x, y) && !vis[x][y] && d2[P.x][P.y]+1 < d1[x][y]){\n                if(i == 0)      p[x][y] = 'D';\n                else if(i == 1) p[x][y] = 'U';\n                else if(i == 2) p[x][y] = 'R';\n                else if(i == 3) p[x][y] = 'L';\n                d2[x][y] = d2[P.x][P.y] + 1;\n                vis[x][y] = true;\n                Q.push({x, y});\n            }\n        }\n    }\n\n    for(int i = 0; i < N; i++){\n        if(c[i][0] != '#' && c[i][0] != 'M' && vis[i][0]){\n            printsolution(i, 0);\n            return 0;\n        } else if(c[i][M-1] != '#' && c[i][M-1] != 'M' && vis[i][M-1]){\n            printsolution(i, M-1);\n            return 0;\n        }\n    }\n\n    for(int i = 0; i < M; i++){\n        if(c[0][i] != '#' && c[0][i] != 'M' && vis[0][i]){\n            printsolution(0, i);\n            return 0;\n        } else if(c[N-1][i] != '#' && c[N-1][i] != 'M' && vis[N-1][i]){\n            printsolution(N-1, i);\n            return 0;\n        }\n    }\n\n    printf(\"NO\\n\");\n}\n",
//   "1195":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,ll> edge;\ntypedef tuple<ll,int,int> node;\nconst int maxN = 2e5+1;\n\nint N, M, a, b;\nll c, dist[2][maxN];\nvector<edge> G[maxN];\npriority_queue<node, vector<node>, greater<node>> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    memset(dist, 0x3f, sizeof(dist));\n    for(int i = 0; i < M; i++){\n        scanf("%d %d %lld", &a, &b, &c);\n        G[a].push_back({b, c});\n    }\n\n    dist[0][1] = dist[1][1] = 0;\n    Q.push({0, 1, 1});\n    while(!Q.empty()){\n        ll d = get<0>(Q.top());\n        int u = get<1>(Q.top());\n        int coupon = get<2>(Q.top());\n        Q.pop();\n\n        if(dist[!coupon][u] < d)    continue;\n\n        for(edge e : G[u]){\n            int v = e.first;\n            ll w = e.second;\n\n            if(coupon){\n                if(dist[0][v] > d + w){\n                    dist[0][v] = d + w;\n                    Q.push({d+w, v, 1});\n                }\n                if(dist[1][v] > d + w/2){\n                    dist[1][v] = d + w/2;\n                    Q.push({d+w/2, v, 0});\n                }\n            } else {\n                if(dist[1][v] > d + w){\n                    dist[1][v] = d + w;\n                    Q.push({d+w, v, 0});\n                }\n            }\n        }\n    }\n\n    printf("%lld\\n", min(dist[0][N], dist[1][N]));\n}\n',
//   "1196":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,ll> edge;\ntypedef pair<ll,int> node;\nconst int maxN = 2e5+1;\n\nint N, M, K, cnt[maxN];\nvector<edge> G[maxN];\npriority_queue<node, vector<node>, greater<node>> Q;\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n    for(int i = 0, a, b, c; i < M; i++){\n        scanf("%d %d %d", &a, &b, &c);\n        G[a].push_back({b, c});\n    }\n\n    Q.push({0, 1});\n    while(!Q.empty()){\n        ll d = get<0>(Q.top());\n        int u = get<1>(Q.top());\n        Q.pop();\n\n        cnt[u]++;\n        if(u == N){\n            printf("%lld%c", d, (" \\n")[cnt[u]==K]);\n            if(cnt[u] == K) return 0;\n        }\n\n        if(cnt[u] <= K){\n            for(edge e : G[u]){\n                int v = e.first;\n                ll w = e.second;\n                Q.push({d+w, v});\n            }\n        }\n    }\n}\n',
//   "1197":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2501;\nconst int maxM = 5001;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nstruct Edge {\n    int a, b; ll c;\n} edges[maxM];\n\nint N, M, ptr, p[maxN];\nll dp[maxN];\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        ll c;\n        scanf("%d %d %lld", &a, &b, &c);\n        edges[i] = {a, b, c};\n    }\n\n    ptr = -1;\n    fill(dp+2, dp+N+1, INF);\n    for(int iter = 0; iter < N && ptr; iter++){\n        ptr = 0;\n        for(int i = 0; i < M; i++){\n            int u = edges[i].a;\n            int v = edges[i].b;\n            ll w = edges[i].c;\n\n            if(dp[v] > dp[u]+w){\n                dp[v] = dp[u]+w;\n                p[v] = u;\n                ptr = v;\n            }\n        }\n    }\n\n    if(!ptr){\n        printf("NO\\n");\n        return 0;\n    }\n\n    for(int i = 0; i < N; i++)\n        ptr = p[ptr];\n\n    vector<int> cycle;\n    for(int v = ptr;; v = p[v]){\n        cycle.push_back(v);\n        if(v == ptr && (int) cycle.size() > 1)\n            break;\n    }\n    reverse(cycle.begin(), cycle.end());\n\n    printf("YES\\n");\n    int K = (int) cycle.size();\n    for(int i = 0; i < K; i++)\n        printf("%d%c", cycle[i], (" \\n")[i==K-1]);\n}',
//   "1202":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,ll> edge;\ntypedef pair<ll,int> node;\nconst int maxN = 1e5+1;\nconst ll MOD = 1e9+7;\nconst ll INF = 0x3f3f3f3f3f3f;\n\nint N, M, a, b, minR[maxN], maxR[maxN];\nll c, dist[maxN], ways[maxN];\nvector<edge> G[maxN];\n\nstruct Comparator {\n    bool operator() (int x, int y) const {\n        return dist[x] == dist[y] ? x < y : dist[x] < dist[y];\n    }\n};\nset<int, Comparator> PQ;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    memset(dist, 0x3f, sizeof(dist));\n    for(int i = 0; i < M; i++){\n        scanf("%d %d %lld", &a, &b, &c);\n        G[a].push_back({b, c});\n    }\n\n    PQ.insert(1);\n    ways[1] = 1;\n    dist[1] = 0;\n    while(!PQ.empty()){\n        int u = *PQ.begin();\n        ll d = dist[u];\n        PQ.erase(PQ.begin());\n\n        for(edge e : G[u]){\n            int v = e.first;\n            ll w = e.second;\n            if(d + w <= dist[v]){\n                if(dist[v] != INF)  PQ.erase(v);\n                if(d + w == dist[v]){\n                    ways[v] = (ways[u] + ways[v]) % MOD;\n                    minR[v] = min(minR[v], minR[u]+1);\n                    maxR[v] = max(maxR[v], maxR[u]+1);\n                }\n                if(d + w < dist[v]){\n                    dist[v] = d+w;\n                    ways[v] = ways[u];\n                    minR[v] = minR[u]+1;\n                    maxR[v] = maxR[u]+1;\n                }\n                PQ.insert(v);\n            }\n        }\n    }\n\n    printf("%lld %lld %d %d\\n", dist[N], ways[N], minR[N], maxR[N]);\n}\n',
//   "1203":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,ll> edge;\ntypedef pair<ll,int> node;\nconst int maxN = 1e5+1;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nuniform_int_distribution<ll> distrib((ll) 1e9, (ll) 2e9);\nconst ll MOD1 = distrib(rng);\nconst ll MOD2 = distrib(rng);\n\nint N, M;\nll dist[2][maxN], ways[2][2][maxN];\nvector<edge> G[2][maxN];\nvector<int> ans;\n\nvoid init(){\n    for(int t = 0; t < 2; t++)\n        for(int i = 1; i <= N; i++)\n            dist[t][i] = INF;\n}\n\nvoid dijkstra(int type, int source){\n    priority_queue<node, vector<node>, greater<node>> Q;\n    dist[type][source] = 0;\n    ways[type][0][source] = 1;\n    ways[type][1][source] = 1;\n    Q.push({0, source});\n    while(!Q.empty()){\n        int u = Q.top().second;\n        ll d = Q.top().first;\n        Q.pop();\n\n        if(d > dist[type][u])   continue;\n        for(edge e : G[type][u]){\n            int v = e.first;\n            ll w = e.second;\n            if(dist[type][v] > d+w){\n                ways[type][0][v] = ways[type][0][u];\n                ways[type][1][v] = ways[type][1][u];\n                dist[type][v] = d+w;\n                Q.push({d+w, v});\n            } else if(dist[type][v] == d+w){\n                ways[type][0][v] += ways[type][0][u];\n                ways[type][0][v] %= MOD1;\n                ways[type][1][v] += ways[type][1][u];\n                ways[type][1][v] %= MOD2;\n            }\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b, c; i < M; i++){\n        scanf("%d %d %d", &a, &b, &c);\n        G[0][a].push_back({b, c});\n        G[1][b].push_back({a, c});\n    }\n    init();\n    dijkstra(0, 1);\n    dijkstra(1, N);\n\n    ll tot1 = ways[0][0][N], tot2 = ways[0][1][N];\n    for(int u = 1; u <= N; u++){\n        ll ways1 = ways[0][0][u] * ways[1][0][u] % MOD1;\n        ll ways2 = ways[0][1][u] * ways[1][1][u] % MOD2;\n        if(ways1 == tot1 && ways2 == tot2 && dist[0][u] + dist[1][u] == dist[0][N])\n            ans.push_back(u);\n    }\n\n    int K = (int) ans.size();\n    printf("%d\\n", K);\n    for(int i = 0; i < K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K-1]);\n}',
//   "1617":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nint N;\n\nll fastpow2(int x){\n    ll res = 1;\n    ll a = 2;\n    while(x > 0){\n        if(x&1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        x >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    scanf("%d", &N);\n    printf("%lld\\n", fastpow2(N));\n}\n',
//   "1618":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, ans;\n\nint main(){\n    scanf("%d", &N);\n    while(N > 0){\n        N /= 5;\n        ans += N;\n    }\n    printf("%d\\n", ans);\n}\n',
//   "1619":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 4e5;\n\nint N, a, b, cur, ans;\nstruct event {int time, type;} events[maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d %d", &a, &b);\n        events[2*i] = {a, 1};\n        events[2*i+1] = {b, -1};\n    }\n    sort(events, events+2*N, [](event A, event B){\n        return A.time == B.time ? A.type < B.type : A.time < B.time;\n    });\n\n    for(int i = 0; i < 2*N; i++){\n        cur += events[i].type;\n        ans = max(ans, cur);\n    }\n    printf("%d\\n", ans);\n}\n',
//   "1620":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N;\nll T, cnt, k[maxN];\n\nbool check(ll t){\n    cnt = 0;\n    for(int i = 0; i < N; i++){\n        cnt += t/k[i];\n        if(cnt >= T)\n            return true;\n    }\n    return false;\n}\n\nint main(){\n    scanf("%d %lld", &N, &T);\n    for(int i = 0; i < N; i++)\n        scanf("%lld", &k[i]);\n\n    ll lo = 0, hi = 1e18;\n    while(lo <= hi){\n        ll mid = lo + (hi-lo)/2;\n        if(check(mid))  hi = mid-1;\n        else            lo = mid+1;\n    }\n    printf("%lld\\n", lo);\n}\n',
//   "1621":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, x;\nset<int> S;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &x);\n        S.insert(x);\n    }\n    printf("%d\\n", (int) S.size());\n}\n',
//   "1623":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nint N, p[20];\nll a, b, best;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &p[i]);\n\n    best = INF;\n    for(int i = 0; i < (1<<N); i++){\n        a = 0; b = 0;\n        for(int j = 0; j < N; j++){\n            if(i&(1<<j))    a += p[j];\n            else            b += p[j];\n        }\n        best = min(best, abs(a-b));\n    }\n    printf("%lld\\n", best);\n}\n',
//   "1624":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 8;\n\nchar c;\nint ans;\nbool b[N][N], input[N][N];\n\nbool place(int x, int y){\n    bool yes = true;\n    for(int i = 0; i < N; i++)\n        if(b[x][i] || b[i][y])\n            yes = false;\n    for(int i = 0; x-i >= 0 && y-i >= 0; i++)\n        if(b[x-i][y-i])\n            yes = false;\n    for(int i = 0; x-i >= 0 && y+i < N; i++)\n        if(b[x-i][y+i])\n            yes = false;\n    return yes;\n}\n\nbool check(){\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            if(b[i][j] && input[i][j])\n                return false;\n    return true;\n}\n\nvoid dfs(int i){\n    if(i == N){\n        if(check())\n            ans++;\n        return;\n    }\n    for(int j = 0; j < N; j++){\n        if(place(i, j)){\n            b[i][j] = true;\n            dfs(i+1);\n            b[i][j] = false;\n        }\n    }\n}\n\nint main(){\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            scanf(" %c", &c);\n            input[i][j] = (c == \'*\');\n        }\n    }\n    dfs(0);\n    printf("%d\\n", ans);\n}\n',
//   "1628":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 40;\n\nint N, t[maxN];\nll x, sum, cnt;\nunordered_map<ll,int> freq;\n\nint main(){\n    scanf("%d %lld", &N, &x);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &t[i]);\n    sort(t, t+N);\n\n    if(N == 1){\n        printf("%d\\n", x == t[0]);\n        return 0;\n    }\n\n    freq.reserve(1<<(N/2-1));\n    for(int i = 0; i < (1<<(N/2-1)); i++){\n        sum = 0;\n        for(int j = 0; j < N/2-1; j++)\n            if(i&(1<<j))\n                sum += t[j];\n        freq[sum]++;\n    }\n\n    for(int i = 0; i < (1<<((N+1)/2+1)); i++){\n        sum = 0;\n        for(int j = 0; j < (N+1)/2+1; j++)\n            if(i&(1<<j))\n                sum += t[N/2-1+j];\n        if(freq.find(x-sum) != freq.end())\n            cnt += freq[x-sum];\n    }\n\n    printf("%lld\\n", cnt);\n}\n',
//   "1630":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5;\n\nint N, a, d;\nlong long timer, reward;\nstruct task {int a, d;} tasks[maxN];\n\nint main (){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d %d", &a, &d);\n        tasks[i] = {a, d};\n    }\n\n    sort(tasks, tasks+N, [](task x, task y){\n        return x.a == y.a ? x.d < y.d : x.a < y.a;\n    });\n\n    for(int i = 0; i < N; i++){\n        timer += tasks[i].a;\n        reward += (tasks[i].d - timer);\n    }\n    printf("%lld\\n", reward);\n}\n',
//   "1631":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll t, mx, sum;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%lld", &t);\n        mx = max(mx, t);\n        sum += t;\n    }\n    printf("%lld\\n", max(sum, 2*mx));\n}\n',
//   "1632":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5, SIZE = 5e6;\nconst int INF = 0x3f3f3f3f;\n\nint N, K, ans, A[maxN], B[maxN], lo[SIZE], hi[SIZE], d[SIZE], mx[SIZE];\nstruct Movie { int t, id, type; } movies[2*maxN];\nmap<int,int> mp;\n\nvoid push(int i){\n    if(d[i]){\n        d[2*i] += d[i];\n        d[2*i+1] += d[i];\n        d[i] = 0;\n    }\n}\n\nvoid pull(int i){\n    mx[i] = max(mx[2*i]+d[2*i], mx[2*i+1]+d[2*i+1]);\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r)  return;\n    int m = l+(r-l)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid increment(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        d[i]++; return;\n    }\n    push(i);\n    increment(2*i, l, r);\n    increment(2*i+1, l, r);\n    pull(i);\n}\n\nint maximum(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])      return -INF;\n    if(l <= lo[i] && hi[i] <= r)    return mx[i]+d[i];\n\n    push(i);\n    int lmax = maximum(2*i, l, r);\n    int rmax = maximum(2*i+1, l, r);\n    pull(i);\n\n    return max(lmax, rmax);\n}\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 0; i < N; i++){\n        scanf("%d %d", &A[i], &B[i]);\n        movies[2*i] = {A[i], i, 0};\n        movies[2*i+1] = {B[i], i, 1};\n    }\n    sort(movies, movies+2*N, [](Movie a, Movie b){\n        return a.t == b.t ? A[a.id] > A[b.id] : a.t < b.t;\n    });\n\n    for(int i = 0; i < 2*N; i++)\n        mp[movies[i].t] = i+1;\n\n    init(1, 1, 2*N);\n    for(int i = 0; i < 2*N; i++){\n        if(movies[i].type == 1){\n            int id = movies[i].id;\n            int a = mp[A[id]];\n            int b = mp[B[id]];\n\n            if(maximum(1, a+1, b) < K){\n                increment(1, a, b);\n                ans++;\n            }\n        }\n    }\n    printf("%d\\n", ans);\n}',
//   "1633":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6;\nconst int MOD = 1e9+7;\n\nint N, dp[maxN+1];\n\nint main(){\n    scanf("%d", &N);\n\n    dp[0] = 1;\n    for(int i = 1; i <= N; i++)\n        for(int j = 1; j <= 6 && i-j >= 0; j++)\n            dp[i] = (dp[i] + dp[i-j]) % MOD;\n\n    printf("%d\\n", dp[N]);\n}\n',
//   "1634":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxX = 1e6;\nconst int INF = 0x3f3f3f3f;\n\nint N, X, c, dp[maxX+1];\n\nint main(){\n    scanf("%d %d", &N, &X);\n    fill(dp+1, dp+X+1, INF);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &c);\n        for(int j = 0; j <= X-c; j++)\n            if(dp[j] != INF)\n                dp[j+c] = min(dp[j+c], dp[j]+1);\n    }\n    printf("%d\\n", dp[X] == INF ? -1 : dp[X]);\n}\n',
//   "1635":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 100;\nconst int maxX = 1e6;\nconst ll MOD = 1e9+7;\n\nint N, X, c[maxN];\nll dp[maxX+1];\n\nint main(){\n    scanf("%d %d", &N, &X);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &c[i]);\n\n    dp[0] = 1;\n    for(int i = 0; i < X; i++)\n        if(dp[i] != 0)\n            for(int j = 0; j < N; j++)\n                if(i+c[j] <= X)\n                    dp[i+c[j]] = (dp[i+c[j]] + dp[i]) % MOD;\n\n    printf("%lld\\n", dp[X]);\n}\n',
//   "1636":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxX = 1e6;\nconst ll MOD = 1e9+7;\n\nint N, X, c;\nll dp[maxX+1];\n\nint main(){\n    scanf("%d %d", &N, &X);\n\n    dp[0] = 1;\n    for(int i = 0; i < N; i++){\n        scanf("%d", &c);\n        for(int j = 0; j <= X-c; j++)\n            dp[j+c] = (dp[j+c] + dp[j]) % MOD;\n    }\n\n    printf("%lld\\n", dp[X]);\n}\n',
//   "1639":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 5e3+5;\n\nint N, M, dp[maxN][maxN];\nchar a[maxN], b[maxN];\n\nint main(){\n    scanf("%s %s", a, b);\n    N = (int) strlen(a);\n    M = (int) strlen(b);\n\n    memset(dp, 0x3f, sizeof(dp));\n    for(int i = 0; i <= N; i++){\n        for(int j = 0; j <= M; j++){\n            if(i == 0)      dp[i][j] = j;\n            else if(j == 0) dp[i][j] = i;\n            else if(a[i-1] == b[j-1])   dp[i][j] = dp[i-1][j-1];\n            else dp[i][j] = 1 + min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});\n        }\n    }\n\n    printf("%d\\n", dp[N][M]);\n}\n',
//   "1640":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5+1;\n\nint N, x, a;\npii p[maxN];\n\nint find(int val){\n    int l = 1, r = N;\n    while(l <= r){\n        int m = l+(r-l)/2;\n        if(p[m].first == val)       return p[m].second;\n        else if(p[m].first < val)   l = m+1;\n        else                        r = m-1;\n    }\n    return 0;\n}\n\nint main(){\n    scanf("%d %d", &N, &x);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &a);\n        p[i] = {a, i};\n    }\n    sort(p+1, p+N+1);\n\n    for(int i = 1; i <= N; i++){\n        int other = find(x-p[i].first);\n        if(other != 0 && other != p[i].second){\n            printf("%d %d\\n", p[i].second, other);\n            return 0;\n        }\n    }\n    printf("IMPOSSIBLE\\n");\n}\n',
//   "1641":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 5000;\n\nint N, X, v, r;\npii a[maxN];\n\nint main(){\n    scanf("%d %d", &N, &X);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &v);\n        a[i] = {v, i+1};\n    }\n\n    sort(a, a+N);\n    for(int i = 0; i < N; i++){\n        v = X - a[i].first;\n        r = N-1;\n        for(int l = i+1; l < r; l++){\n            while(l+1 < r && a[l].first + a[r].first > v)   r--;\n            if(a[l].first + a[r].first == v){\n                printf("%d %d %d\\n", a[i].second, a[l].second, a[r].second);\n                return 0;\n            }\n        }\n    }\n    printf("IMPOSSIBLE\\n");\n}\n',
//   "1642":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxN = 1001;\n\nint N;\nll X, a[maxN];\nunordered_map<ll,vector<pii>> mp;\n\nint main(){\n    scanf("%d %lld", &N, &X);\n    mp.reserve(maxN*maxN);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &a[i]);\n        for(int j = 1; j < i; j++){\n            ll psum = a[i] + a[j];\n            if(psum >= X)   continue;\n            if(mp.find(X-psum) != mp.end()){\n                for(pii P : mp[X-psum]){\n                    if(P.first != j && P.second != j && P.first != i && P.second != i){\n                        printf("%d %d %d %d\\n", P.first, P.second, j, i);\n                        return 0;\n                    }\n                }\n            } else mp[psum].push_back({j, i});\n        }\n    }\n    printf("IMPOSSIBLE\\n");\n}\n',
//   "1644":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, A, B;\nll pre[maxN];\nmultiset<ll> S;\n\nint main(){\n    scanf("%d %d %d", &N, &A, &B);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &pre[i]);\n        pre[i] += pre[i-1];\n    }\n\n    for(int i = A; i <= B; i++)\n        S.insert(pre[i]);\n\n    ll best = *S.rbegin();\n    for(int i = 1; i+A <= N; i++){\n        S.erase(pre[i+A-1]);\n        S.insert(pre[min(i+B, N)]);\n        best = max(best, *S.rbegin()-pre[i]);\n    }\n\n    printf("%lld\\n", best);\n}',
//   "1645":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, x[maxN], ds[maxN];\n\nint main(){\n    scanf("%d ", &N);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &x[i]);\n        int k = i-1;\n        while(x[k] >= x[i])\n            k = ds[k];\n        ds[i] = k;\n        printf("%d%c", ds[i], (" \\n")[i==N]);\n    }\n}\n',
//   "1646":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, Q, a, b;\nll x[maxN+1];\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &x[i]);\n        x[i] += x[i-1];\n    }\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &a, &b);\n        printf("%lld\\n", x[b]-x[a-1]);\n    }\n}\n',
//   "1647":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\nconst int logN = 19;\n\nint N, Q, a, b, l, k, x[maxN][logN];\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &x[i][0]);\n\n    for(int i = 1; i < logN; i++)\n        for(int j = 0; j <= N-(1<<i); j++)\n            x[j][i] = min(x[j][i-1], x[j+(1<<(i-1))][i-1]);\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &a, &b);\n        a--; b--;\n        l = b-a+1;\n        k = log2(l);\n        printf("%d\\n", min(x[a][k], x[b-(1<<k)+1][k]));\n    }\n}\n',
//   "1648":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, Q, t, a, b;\nll x[maxN+1], ds[maxN+1];\n\nvoid update(int idx, ll val){\n    ll diff = val - x[idx];\n    for(int i = idx; i <= N; i += -i&i)\n        ds[i] += diff;\n    x[idx] = val;\n}\n\nll query(int idx){\n    ll sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum += ds[i];\n    return sum;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &x[0]);\n        update(i, x[0]);\n    }\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d %d", &t, &a, &b);\n        if(t == 1)  update(a, b);\n        else        printf("%lld\\n", query(b)-query(a-1));\n    }\n}\n',
//   "1649":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5, SIZE = 4*maxN;\nconst int INF = 0x3f3f3f3f;\n\nint N, Q, t, a, b, lo[SIZE], hi[SIZE], mn[SIZE];\n\nvoid push(int i){\n\n}\n\nvoid pull(int i){\n    mn[i] = min(mn[2*i], mn[2*i+1]);\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        scanf("%d", &mn[i]);\n        return;\n    }\n    int m = l+(r-l)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid assign(int i, int l, int r, int v){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        mn[i] = v; return;\n    }\n\n    push(i);\n    assign(2*i, l, r, v);\n    assign(2*i+1, l, r, v);\n    pull(i);\n}\n\nint minimum(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])      return INF;\n    if(l <= lo[i] && hi[i] <= r)    return mn[i];\n\n    push(i);\n    int lmin = minimum(2*i, l, r);\n    int rmin = minimum(2*i+1, l, r);\n    pull(i);\n\n    return min(lmin, rmin);\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n\n    init(1, 1, N);\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d %d", &t, &a, &b);\n        if(t == 1)      assign(1, a, a, b);\n        else if(t == 2) printf("%d\\n", minimum(1, a, b));\n    }\n}\n',
//   "1650":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, Q, a, b;\nll x[maxN+1];\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &x[i]);\n        x[i] ^= x[i-1];\n    }\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &a, &b);\n        printf("%lld\\n", x[b]^x[a-1]);\n    }\n}\n',
//   "1651":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, Q, t, a, b, k;\nll x, ds[maxN];\n\nvoid update(int idx, ll val){\n    for(int i = idx; i <= N; i += -i&i)\n        ds[i] += val;\n}\n\nll query(int idx){\n    ll sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum += ds[i];\n    return sum;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &x);\n        update(i, x);\n        update(i+1, -x);\n    }\n    for(int q = 0; q < Q; q++){\n        scanf("%d", &t);\n        if(t == 1){\n            scanf("%d %d %lld", &a, &b, &x);\n            update(b+1, -x);\n            update(a, x);\n        } else if(t == 2){\n            scanf("%d", &k);\n            printf("%lld\\n", query(k));\n        }\n    }\n}\n',
//   "1653":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\nconst int maxN = 20;\nconst int INF = maxN+1;\n\nint N;\npii dp[1<<maxN];\nll X, w[maxN];\n\nint main(){\n    scanf("%d %lld", &N, &X);\n    for(int i = 0; i < N; i++)\n        scanf("%lld", &w[i]);\n\n    dp[0] = {1, 0};\n    for(int mask = 1; mask < (1<<N); mask++){\n        dp[mask] = {INF, 0};\n        for(int i = 0; i < N; i++){\n            if(mask&(1<<i)){\n                pii can = dp[mask^(1<<i)];\n                if(can.second + w[i] <= X){\n                    can.second += w[i];\n                } else {\n                    can.first++;\n                    can.second = w[i];\n                }\n                dp[mask] = min(dp[mask], can);\n            }\n        }\n    }\n\n    printf("%d\\n", dp[(1<<N)-1].first);\n}\n',
//   "1655":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    Node *c[2];\n};\n\nint N, xum, best;\nNode *root;\n\nvoid update(int x){\n    Node *cur = root;\n    for(int i = 30; i >= 0; i--){\n        if(x&(1<<i)){\n            if(!cur->c[1])  cur->c[1] = new Node();\n            cur = cur->c[1];\n        } else {\n            if(!cur->c[0])  cur->c[0] = new Node();\n            cur = cur->c[0];\n        }\n    }\n}\n\nint query(int x){\n    int res = 0;\n    Node *cur = root;\n    for(int i = 30; i >= 0; i--){\n        if(x&(1<<i)){\n            if(cur->c[0]){\n                res += (1<<i);\n                cur = cur->c[0];\n            } else cur = cur->c[1];\n        } else {\n            if(cur->c[1]){\n                res += (1<<i);\n                cur = cur->c[1];\n            } else cur = cur->c[0];\n        }\n    }\n    return res;\n}\n\nint main(){\n    scanf("%d", &N);\n    root = new Node();\n    update(0);\n    for(int i = 0, x; i < N; i++){\n        scanf("%d", &x);\n        xum ^= x;\n        update(xum);\n        best = max(best, query(xum));\n    }\n    printf("%d\\n", best);\n}\n',
//   "1660":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5;\n\nint N, x, l, sum, cnt, a[maxN+1];\n\nint main(){\n    scanf("%d %d", &N, &x);\n    for(int r = 1; r <= N; r++){\n        scanf("%d", &a[r]);\n        sum += a[r];\n        while(sum > x)\n            sum -= a[l++];\n        if(sum == x)    cnt++;\n    }\n    printf("%d\\n", cnt);\n}\n',
//   "1661":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll X, a, cnt, pre;\nmap<ll,int> freq;\n\nint main(){\n    scanf("%d %lld", &N, &X);\n    freq[0] = 1;\n    for(int i = 0; i < N; i++){\n        scanf("%lld", &a);\n        pre += a;\n        cnt += freq[pre-X];\n        freq[pre]++;\n    }\n    printf("%lld\\n", cnt);\n}\n',
//   "1662":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, pre, a, freq[maxN];\nll cnt;\n\nint mod(int x){\n    return (x % N + N) % N;\n}\n\nint main(){\n    scanf("%d", &N);\n    freq[0] = 1;\n    for(int i = 0; i < N; i++){\n        scanf("%d", &a);\n        pre = mod(pre+a);\n        cnt += freq[pre];\n        freq[pre]++;\n    }\n    printf("%lld\\n", cnt);\n}\n',
//   "1664":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int logN = 17, maxT = 1e6;\n\nint N, Q, dp[maxT+1][logN+1];\nvector<int> movies[maxT+1];\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 0, a, b; i < N; i++){\n        scanf("%d %d", &a, &b);\n        movies[a].push_back(b);\n    }\n\n    priority_queue<int, vector<int>, greater<int>> ends;\n    for(int t = maxT; t >= 0; t--){\n        for(int b : movies[t])\n            ends.push(b);\n\n        dp[t][0] = ends.empty() ? maxT+1 : ends.top();\n    }\n    for(int k = 1; k <= logN; k++)\n        for(int t = 0; t <= maxT; t++)\n            dp[t][k] = dp[t][k-1] > maxT ? maxT+1 : dp[dp[t][k-1]][k-1];\n\n    for(int q = 0, a, b; q < Q; q++){\n        scanf("%d %d", &a, &b);\n        int ans = 0;\n        for(int k = logN; k >= 0; k--){\n            if(dp[a][k] <= b){\n                a = dp[a][k];\n                ans += (1<<k);\n            }\n        }\n        printf("%d\\n", ans);\n    }\n}',
//   "1665":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 101, maxX = 5e3+1;\nconst ll MOD = 1e9+7;\n\nint N, X, t[maxN];\nll dp[maxN][maxN][maxX];\n\nint main(){\n    scanf("%d %d", &N, &X);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &t[i]);\n    sort(t+1, t+N+1);\n    t[0] = t[1];\n\n    dp[0][0][0] = 1;\n    for(int i = 1; i <= N; i++){\n        for(int j = N; j >= 0; j--){\n            for(int k = X; k >= 0; k--){\n                ll cnt = dp[i-1][j][k];\n                int newk = k + j * (t[i]-t[i-1]);\n                if(newk > X)    continue;\n\n                dp[i][j][newk] = (dp[i][j][newk] + (j+1) * cnt) % MOD;\n                if(j != N)  dp[i][j+1][newk] = (dp[i][j+1][newk] + cnt) % MOD;\n                if(j != 0)  dp[i][j-1][newk] = (dp[i][j-1][newk] + j * cnt) % MOD;\n            }\n        }\n    }\n\n    ll tot = 0;\n    for(int i = 0; i <= X; i++)\n        tot = (tot + dp[N][0][i]) % MOD;\n    printf("%lld\\n", tot);\n}',
//   "1666":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint N, M, a, b, ds[100001];\nvector<pii> ans;\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 1; i <= N; i++) ds[i] = -1;\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        merge(a, b);\n    }\n\n    for(int i = 1; i < N; i++)\n        if(merge(i, i+1))\n            ans.push_back({i, i+1});\n\n    printf("%d\\n", (int) ans.size());\n    for(pii P : ans)\n        printf("%d %d\\n", P.first, P.second);\n}\n',
//   "1667":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, M, K, a, b, p[maxN], dist[maxN];\nbool vis[maxN];\nvector<int> G[maxN];\nqueue<int> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    Q.push(1);\n    vis[1] = true;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        for(int v : G[u]){\n            if(!vis[v]){\n                dist[v] = dist[u]+1;\n                vis[v] = true;\n                p[v] = u;\n                Q.push(v);\n            }\n        }\n    }\n\n    if(!vis[N]){\n        printf("IMPOSSIBLE\\n");\n        return 0;\n    }\n\n    int u = N;\n    K = dist[N];\n    vector<int> ans(K+1);\n    for(int i = K; i >= 0; i--){\n        ans[i] = u;\n        u = p[u];\n    }\n\n    printf("%d\\n", K+1);\n    for(int i = 0; i <= K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K]);\n}\n',
//   "1668":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, M, a, b;\nbool possible, vis[maxN], team[maxN];\nvector<int> G[maxN];\n\nvoid dfs(int u, int p = 0){\n    for(int v : G[u]){\n        if(v != p){\n            if(!vis[v]){\n                team[v] = !team[u];\n                vis[v] = true;\n                dfs(v, u);\n            } else\n                if(team[v] == team[u])\n                    possible = false;\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    possible = true;\n    for(int i = 1; i <= N; i++){\n        if(!vis[i]){\n            vis[i] = true;\n            dfs(i);\n        }\n    }\n\n    if(!possible)\n        printf("IMPOSSIBLE\\n");\n    else\n        for(int i = 1; i <= N; i++)\n            printf("%d%c", (team[i] ? 1 : 2), (" \\n")[i==N]);\n}\n',
//   "1670":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 9;\nconst int x[] = {0, 1, 2, 3, 4, 5, 1, 2, 4, 5, 7, 8};\nconst int y[] = {3, 4, 5, 6, 7, 8, 0, 1, 3, 4, 6, 7};\n\nunordered_map<string,int> dist;\nqueue<string> Q;\nstring perm;\n\nvoid init(){\n    perm = "123456789";\n\n    dist[perm] = 1;\n    Q.push(perm);\n    while(!Q.empty()){\n        perm = Q.front(); Q.pop();\n        int d = dist[perm];\n        for(int i = 0; i < 12; i++){\n            swap(perm[x[i]], perm[y[i]]);\n            if(!dist[perm]){\n                dist[perm] = d+1;\n                Q.push(perm);\n            }\n            swap(perm[x[i]], perm[y[i]]);\n        }\n    }\n}\n\nint main(){\n    init();\n    for(int i = 0; i < N; i++)\n        scanf(" %c", &perm[i]);\n    printf("%d\\n", dist[perm]-1);\n}\n',
//   "1671":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5;\n\nstruct Edge { int v; ll w; };\nstruct Node {\n    int id; ll dist;\n    friend bool operator<(const Node &a, const Node &b){\n        return a.dist > b.dist;\n    }\n};\n\nint N, M, a, b;\nll dist[maxN+1], c;\nvector<Edge> G[maxN+1];\npriority_queue<Node> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d %lld", &a, &b, &c);\n        G[a].push_back({b, c});\n    }\n\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    Q.push({1, 0});\n    while(!Q.empty()){\n        ll d = Q.top().dist;\n        int u = Q.top().id;\n        Q.pop();\n\n        if(d > dist[u]) continue;\n\n        for(Edge e : G[u]){\n            if(dist[e.v] > d+e.w){\n                dist[e.v] = d+e.w;\n                Q.push({e.v, d+e.w});\n            }\n        }\n    }\n\n    for(int i = 1; i <= N; i++)\n        printf("%lld%c", dist[i], (" \\n")[i==N]);\n}\n',
//   "1672":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 500;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nint N, M, Q, a, b;\nll dist[maxN+1][maxN+1], c;\n\nint main(){\n    scanf("%d %d %d", &N, &M, &Q);\n    memset(dist, 0x3f, sizeof(dist));\n    for(int i = 0; i < M; i++){\n        scanf("%d %d %lld", &a, &b, &c);\n        dist[a][b] = min(dist[a][b], c);\n        dist[b][a] = min(dist[b][a], c);\n    }\n\n    for(int i = 1; i <= N; i++) dist[i][i] = 0;\n    for(int k = 1; k <= N; k++)\n        for(int i = 1; i <= N; i++)\n            for(int j = 1; j <= N; j++)\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &a, &b);\n        printf("%lld\\n", (dist[a][b] >= INF ? -1 : dist[a][b]));\n    }\n}\n',
//   "1673":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2501;\nconst int maxM = 5001;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nstruct Edge {\n    int a, b; ll c;\n} edges[maxM];\n\nint N, M;\nll dp[maxN];\nbool vis[maxN], visR[maxN];\nvector<int> G[maxN], GR[maxN];\n\nvoid dfs(int u){\n    vis[u] = true;\n    for(int v : G[u])\n        if(!vis[v])\n            dfs(v);\n}\n\nvoid dfsR(int u){\n    visR[u] = true;\n    for(int v : GR[u])\n        if(!visR[v])\n            dfsR(v);\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        ll c;\n        scanf("%d %d %lld", &a, &b, &c);\n        edges[i] = {a, b, -c};\n        G[a].push_back(b);\n        GR[b].push_back(a);\n    }\n    dfs(1); dfsR(N);\n\n    fill(dp+2, dp+N+1, INF);\n    bool improvement = true;\n    for(int iter = 0; iter < N && improvement; iter++){\n        improvement = false;\n        for(int i = 0; i < M; i++){\n            int u = edges[i].a;\n            int v = edges[i].b;\n            ll w = edges[i].c;\n\n            if(dp[v] > dp[u]+w){\n                dp[v] = dp[u]+w;\n                improvement = true;\n\n                if(iter == N-1 && vis[v] && visR[v]){\n                    printf("-1\\n");\n                    return 0;\n                }\n            }\n        }\n    }\n\n    printf("%lld\\n", -dp[N]);\n}',
//   "1674":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5;\n\nint N, p[maxN+1], sz[maxN+1];\nvector<int> G[maxN+1];\n\nvoid dfs(int u){\n    sz[u] = 1;\n    for(int v : G[u]){\n        dfs(v);\n        sz[u] += sz[v];\n    }\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 2; i <= N; i++){\n        scanf("%d", &p[i]);\n        G[p[i]].push_back(i);\n    }\n\n    dfs(1);\n\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", sz[i]-1, (" \\n")[i==N]);\n}\n',
//   "1675":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n#define f first\n#define s second\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> edge;\nconst int maxN = 1e5+1;\nconst int maxM = 2e5+1;\n\nint N, M, a, b, c, ds[maxN];\nlong long sum;\nedge edges[maxM];\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    fill(ds+1, ds+N+1, -1);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d %d", &a, &b, &c);\n        edges[i] = {c, {a, b}};\n    }\n    sort(edges, edges+M);\n\n    for(int i = 0; i < M; i++){\n        edge e = edges[i];\n        if(merge(e.s.f, e.s.s)){\n            sum += e.f;\n            N--;\n        }\n    }\n\n    if(N == 1)  printf("%lld\\n", sum);\n    else        printf("IMPOSSIBLE\\n");\n}\n',
//   "1676":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5;\n\nint N, M, a, b, components, largest, ds[maxN+1];\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    fill(ds+1, ds+N+1, -1);\n\n    components = N;\n    largest = 1;\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        if(merge(a, b)){\n            components--;\n            largest = max(largest, -ds[find(a)]);\n        }\n        printf("%d %d\\n", components, largest);\n    }\n}\n',
//   "1677":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\nconst int maxM = 2e5;\ntypedef pair<int,int> pii;\n\nint N, M, K, a, b, cnt, ds[maxN], ans[maxM];\npii edges[maxM], queries[maxM];\nset<pii> S;\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n    fill(ds+1, ds+N+1, -1);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        if(b > a)   swap(a, b);\n        edges[i] = {a, b};\n    }\n    for(int i = 0; i < K; i++){\n        scanf("%d %d", &a, &b);\n        if(b > a)   swap(a, b);\n        queries[i] = {a, b};\n        S.insert({a, b});\n    }\n\n    cnt = N;\n    for(int i = 0; i < M; i++)\n        if(S.find(edges[i]) == S.end())\n            if(merge(edges[i].first, edges[i].second))\n                cnt--;\n\n    for(int i = K-1; i >= 0; i--){\n        ans[i] = cnt;\n        if(merge(queries[i].first, queries[i].second))\n            cnt--;\n    }\n\n    for(int i = 0; i < K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K-1]);\n}\n',
//   "1678":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, M, start, finish, p[maxN], vis[maxN];\nvector<int> ans, G[maxN];\n\nvoid dfs(int u){\n    vis[u] = 1;\n    for(int v : G[u]){\n        if(vis[v] == 0){\n            p[v] = u;\n            dfs(v);\n            if(start)\n                return;\n        } else if(vis[v] == 1){\n            finish = u;\n            start = v;\n            return;\n        }\n    }\n    vis[u] = 2;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n    }\n\n    for(int i = 1; i <= N && !start; i++)\n        if(vis[i] == 0)\n            dfs(i);\n\n    if(!start){\n        printf("IMPOSSIBLE\\n");\n        return 0;\n    }\n\n    ans.push_back(start);\n    for(int u = finish; u != start; u = p[u])\n        ans.push_back(u);\n    ans.push_back(start);\n    reverse(ans.begin(), ans.end());\n\n    int K = (int) ans.size();\n    printf("%d\\n", K);\n    for(int i = 0; i < K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K-1]);\n}\n',
//   "1680":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nbool vis[maxN];\nint N, M, K, a, b, in[maxN], p[maxN], l[maxN], ans[maxN];\nvector<int> G[maxN];\nqueue<int> Q;\n\nvoid dfs(int u, int par = 0){\n    vis[u] = true;\n    for(int v : G[u])\n        if(v != par && !vis[v])\n            dfs(v, u);\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        in[b]++;\n    }\n\n    dfs(1);\n    if(!vis[N]){\n        printf("IMPOSSIBLE\\n");\n        return 0;\n    }\n\n    fill(l+2, l+maxN, -1);\n    for(int i = 1; i <= N; i++)\n        if(in[i] == 0)\n            Q.push(i);\n\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        for(int v : G[u]){\n            if(l[u] != -1 && l[v] < l[u]+1){\n                l[v] = l[u] + 1;\n                p[v] = u;\n            }\n            in[v]--;\n            if(in[v] == 0)\n                Q.push(v);\n        }\n    }\n\n    K = l[N] - l[1];\n    printf("%d\\n", K+1);\n    for(int i = K, u = N; i >= 0; i--){\n        ans[i] = u;\n        u = p[u];\n    }\n    for(int i = 0; i <= K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K]);\n}\n',
//   "1681":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+1;\nconst ll MOD = 1e9+7;\n\nint N, M, a, b, cnt, in[maxN];\nll dp[maxN];\nvector<int> G[maxN];\nqueue<int> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        in[b]++;\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(in[i] == 0)\n            Q.push(i);\n\n    dp[1] = 1;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        for(int v : G[u]){\n            dp[v] = (dp[v] + dp[u]) % MOD;\n            in[v]--;\n            if(in[v] == 0)\n                Q.push(v);\n        }\n    }\n\n    printf("%lld\\n", dp[N]);\n}\n',
//   "1682":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, M, a, b;\nbool vis1[maxN], vis2[maxN];\nvector<int> G1[maxN], G2[maxN];\n\nvoid dfs1(int u = 1, int p = 0){\n    vis1[u] = true;\n    for(int v : G1[u])\n        if(v != p && !vis1[v])\n            dfs1(v, u);\n}\n\nvoid dfs2(int u = 1, int p = 0){\n    vis2[u] = true;\n    for(int v : G2[u])\n        if(v != p && !vis2[v])\n            dfs2(v, u);\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G1[a].push_back(b);\n        G2[b].push_back(a);\n    }\n    dfs1();\n    dfs2();\n    for(int i = 1; i <= N; i++){\n        if(!vis1[i] || !vis2[i]){\n            printf("NO\\n");\n            if(!vis1[i])    printf("1 %d\\n", i);\n            else            printf("%d 1\\n", i);\n            return 0;\n        }\n    }\n    printf("YES\\n");\n}\n',
//   "1683":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nbool vis[maxN];\nint N, M, rt[maxN];\nvector<int> ord, comp, G[maxN], GR[maxN];\n\nvoid dfs1(int u){\n    vis[u] = true;\n    for(int v : G[u])\n        if(!vis[v])\n            dfs1(v);\n    ord.push_back(u);\n}\n\nvoid dfs2(int u){\n    vis[u] = true;\n    comp.push_back(u);\n    for(int v : GR[u])\n        if(!vis[v])\n            dfs2(v);\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        GR[b].push_back(a);\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(!vis[i])\n            dfs1(i);\n\n    int K = 0;\n    fill(vis+1, vis+N+1, false);\n    reverse(ord.begin(), ord.end());\n    for(int u : ord){\n        if(!vis[u]){\n            dfs2(u);\n            K++;\n            for(int v : comp)\n                rt[v] = K;\n            comp.clear();\n        }\n    }\n\n    printf("%d\\n", K);\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", rt[i], (" \\n")[i==N]);\n}',
//   "1684":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nbool vis[maxN];\nchar ans[maxN];\nint N, M, K, in[maxN], rt[maxN];\nvector<int> ord, comp, G[maxN], GR[maxN], C[maxN], SCC[maxN];\n\nint flip(int x){\n    return (x&1 ? x+1 : x-1);\n}\n\nvoid add_edge(char c1, int a, char c2, int b){\n    a = 2*a - (c1 == \'-\');\n    b = 2*b - (c2 == \'-\');\n    G[flip(a)].push_back(b);\n    G[flip(b)].push_back(a);\n    GR[a].push_back(flip(b));\n    GR[b].push_back(flip(a));\n}\n\nvoid dfs1(int u){\n    vis[u] = true;\n    for(int v : G[u])\n        if(!vis[v])\n            dfs1(v);\n    ord.push_back(u);\n}\n\nvoid dfs2(int u){\n    vis[u] = true;\n    comp.push_back(u);\n    for(int v : GR[u])\n        if(!vis[v])\n            dfs2(v);\n}\n\nint main(){\n    scanf("%d %d", &M, &N);\n    for(int i = 0, a, b; i < M; i++){\n        char c1, c2;\n        scanf(" %c %d %c %d", &c1, &a, &c2, &b);\n        add_edge(c1, a, c2, b);\n    }\n\n    for(int i = 1; i <= 2*N; i++)\n        if(!vis[i])\n            dfs1(i);\n\n    fill(vis+1, vis+2*N+1, false);\n    reverse(ord.begin(), ord.end());\n    for(int u : ord){\n        if(!vis[u]){\n            dfs2(u);\n            K++;\n            for(int v : comp){\n                rt[v] = K;\n                C[K].push_back(v);\n            }\n            comp.clear();\n        }\n    }\n\n    // Impossible iff x and not(x) belong to same SCC\n    for(int i = 1; i <= N; i++){\n        if(rt[2*i] == rt[2*i-1]){\n            printf("IMPOSSIBLE\\n");\n            return 0;\n        }\n    }\n\n    for(int u = 1; u <= 2*N; u++){\n        for(int v : G[u]){\n            if(rt[u] != rt[v]){\n                SCC[rt[u]].push_back(rt[v]);\n                in[rt[v]]++;\n            }\n        }\n    }\n\n    queue<int> Q;\n    ord.clear();\n    for(int u = 1; u <= K; u++){\n        if(in[u] == 0){\n            ord.push_back(u);\n            Q.push(u);\n        }\n    }\n\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        for(int v : SCC[u]){\n            in[v]--;\n            if(in[v] == 0){\n                ord.push_back(v);\n                Q.push(v);\n            }\n        }\n    }\n\n    fill(vis+1, vis+N+1, false);\n    reverse(ord.begin(), ord.end());\n    for(int k : ord){\n        for(int u : C[k]){\n            int i = (u+1)/2;\n            if(!vis[i]){\n                ans[i] = (u&1 ? \'-\' : \'+\');\n                vis[i] = true;\n            }\n        }\n    }\n\n    for(int i = 1; i <= N; i++)\n        printf("%c%c", ans[i], (" \\n")[i==N]);\n}',
//   "1686":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+1;\n\nbool vis[maxN];\nint N, M, K, rt[maxN];\nll k[maxN], ck[maxN], dp[maxN];\nvector<int> ord, comp, G[maxN], GR[maxN], SCC[maxN];\n\nvoid dfs1(int u){\n    vis[u] = true;\n    for(int v : G[u])\n        if(!vis[v])\n            dfs1(v);\n    ord.push_back(u);\n}\n\nvoid dfs2(int u){\n    vis[u] = true;\n    comp.push_back(u);\n    for(int v : GR[u])\n        if(!vis[v])\n            dfs2(v);\n}\n\nvoid dfs3(int u){\n    vis[u] = true;\n    dp[u] = ck[u];\n    for(int v : SCC[u]){\n        if(!vis[v])\n            dfs3(v);\n        dp[u] = max(dp[u], dp[v]+ck[u]);\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &k[i]);\n\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        GR[b].push_back(a);\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(!vis[i])\n            dfs1(i);\n\n    fill(vis+1, vis+N+1, false);\n    reverse(ord.begin(), ord.end());\n    for(int u : ord){\n        if(!vis[u]){\n            dfs2(u);\n            K++;\n            for(int v : comp){\n                ck[K] += k[v];\n                rt[v] = K;\n            }\n            comp.clear();\n        }\n    }\n\n    for(int u = 1; u <= N; u++)\n        for(int v : G[u])\n            if(rt[v] != rt[u])\n                SCC[rt[u]].push_back(rt[v]);\n\n    fill(vis+1, vis+K+1, false);\n    for(int i = 1; i <= K; i++)\n        if(!vis[i])\n            dfs3(i);\n\n    ll best = 0;\n    for(int i = 1; i <= K; i++)\n        best = max(best, dp[i]);\n    printf("%lld\\n", best);\n}',
//   "1687":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\nconst int logK = 20;\n\nint N, Q, x, k, p[maxN][logK];\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 2; i <= N; i++)\n        scanf("%d", &p[i][0]);\n    for(int j = 1; j < logK; j++)\n        for(int i = 1; i <= N; i++)\n            p[i][j] = p[p[i][j-1]][j-1];\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &x, &k);\n        for(int i = 0; i < logK; i++)\n            if(k&(1<<i))\n                x = p[x][i];\n        printf("%d\\n", x ? x : -1);\n    }\n}\n',
//   "1688":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\nconst int logN = 20;\n\nint N, Q, e, a, b, p[maxN][logN];\nint timer, in[maxN], out[maxN];\nvector<int> G[maxN];\n\nvoid dfs(int u = 1, int par = 1){\n    in[u] = ++timer;\n    p[u][0] = par;\n    for(int i = 1; i < logN; i++)\n        p[u][i] = p[p[u][i-1]][i-1];\n    for(int v : G[u])\n        if(v != par)\n            dfs(v, u);\n    out[u] = ++timer;\n}\n\nbool ancestor(int u, int v){\n    return in[u] <= in[v] && out[u] >= out[v];\n}\n\nint lca(int u, int v){\n    if(ancestor(u, v))  return u;\n    if(ancestor(v, u))  return v;\n    for(int i = logN-1; i >= 0; i--)\n        if(!ancestor(p[u][i], v))\n            u = p[u][i];\n    return p[u][0];\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 2; i <= N; i++){\n        scanf("%d", &e);\n        G[e].push_back(i);\n        G[i].push_back(e);\n    }\n\n    dfs();\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &a, &b);\n        printf("%d\\n", lca(a, b));\n    }\n}\n',
//   "1690":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxN = 20;\nconst int SIZE = 1<<maxN;\nconst ll MOD = 1e9+7;\n\nint N, M;\nbool inqueue[maxN][SIZE];\nll dp[maxN][SIZE];\nvector<int> G[maxN];\nqueue<pii> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a-1].push_back(b-1);\n    }\n\n    dp[0][1] = 1;\n    Q.push({0, 1});\n    inqueue[0][1] = true;\n    while(!Q.empty()){\n        int u = Q.front().first;\n        int mask = Q.front().second;\n        Q.pop();\n\n        if(u != N-1){\n            for(int v : G[u]){\n                int newMask = mask|(1<<v);\n                if((mask&(1<<v)) == 0){\n                    dp[v][newMask] += dp[u][mask];\n                    dp[v][newMask] %= MOD;\n                    if(!inqueue[v][newMask]){\n                        Q.push({v, newMask});\n                        inqueue[v][newMask] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    printf("%lld\\n", dp[N-1][(1<<N)-1]);\n}',
//   "1691":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 1e5+1;\nconst int maxM = 2e5+1;\n\nint N, M, deg[maxN];\nbool tour_exists, used[maxM];\nvector<pii> G[maxN];\nvector<int> tour;\nstack<int> S;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back({b, i});\n        G[b].push_back({a, i});\n        deg[a]++; deg[b]++;\n    }\n\n    tour_exists = true;\n    for(int i = 1; i <= N; i++)\n        if(deg[i]&1)\n            tour_exists = false;\n\n    if(!tour_exists){\n        printf("IMPOSSIBLE\\n");\n        return 0;\n    }\n\n    S.push(1);\n    while(!S.empty()){\n        int u = S.top();\n        if(deg[u]){\n            while(!G[u].empty()){\n                int v = G[u].back().first;\n                int id = G[u].back().second;\n                G[u].pop_back();\n\n                if(!used[id]){\n                    deg[u]--; deg[v]--;\n                    used[id] = true;\n                    S.push(v);\n                    break;\n                }\n            }\n        } else {\n            tour.push_back(u);\n            S.pop();\n        }\n    }\n\n    // Should be M+1 nodes in the Euler tour\n    // If not, it means the graph was not connected\n    if((int) tour.size() != M+1)\n        printf("IMPOSSIBLE\\n");\n    else\n        for(int i = 0; i <= M; i++)\n            printf("%d%c", tour[i], (" \\n")[i==M]);\n}\n',
//   "1692":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 15;\nconst int SIZE = (1<<maxN)+maxN;\n\nchar ans[SIZE];\nint N, ansptr;\nvector<int> G[SIZE];\nstack<int> S;\n\nvoid init(){\n    for(int u = 0; u < 1<<(N-1); u++){\n        int v = (u<<1)%(1<<(N-1));\n        G[u].push_back(v);\n        G[u].push_back(v|1);\n    }\n}\n\nvoid solve(){\n    S.push(0);\n    while(!S.empty()){\n        int u = S.top();\n        if(!G[u].empty()){\n            int v = G[u].back();\n            G[u].pop_back();\n            S.push(v);\n        } else {\n            ans[ansptr++] = (char) (u&1) + \'0\';\n            S.pop();\n        }\n    }\n    for(int i = 0; i < N-2; i++)\n        ans[ansptr++] = \'0\';\n}\n\nint main(){\n    scanf("%d", &N);\n    if(N == 1){\n        printf("01");\n        return 0;\n    }\n\n    init();\n    solve();\n    for(int i = 0; i < ansptr; i++)\n        printf("%c", ans[i]);\n}',
//   "1693":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nbool vis[maxN];\nint N, M, in[maxN];\nvector<int> tour, G[maxN];\nstack<int> S;\n\nvoid dfs(int u = 1, int p = -1){\n    vis[u] = true;\n    for(int v : G[u])\n        if(v != p && !vis[v])\n            dfs(v, u);\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        in[b]++;\n    }\n\n    dfs();\n    bool exists = vis[N];\n    exists &= (in[1]+1 == (int) G[1].size());\n    exists &= (in[N]-1 == (int) G[N].size());\n    for(int i = 2; i < N; i++){\n        exists &= (in[i] == (int) G[i].size());\n        if(!vis[i]) exists &= (in[i] == 0 && G[i].size() == 0);\n    }\n\n    if(!exists){\n        printf("IMPOSSIBLE\\n");\n        return 0;\n    }\n\n    S.push(1);\n    while(!S.empty()){\n        int u = S.top();\n        if(!G[u].empty()){\n            int v = G[u].back();\n            G[u].pop_back();\n            S.push(v);\n        } else {\n            tour.push_back(u);\n            S.pop();\n        }\n    }\n\n    reverse(tour.begin(), tour.end());\n    for(int i = 0; i < M+1; i++)\n        printf("%d%c", tour[i], (" \\n")[i==M]);\n}',
//   "1694":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,ll> pil;\nconst int maxN = 501;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nint N, M, p[maxN];\nll cap[maxN][maxN];\nvector<int> G[maxN];\n\nll bfs(int s = 1, int t = N){\n    fill(p+1, p+N+1, -1);\n    p[s] = -2;\n\n    queue<pil> Q;\n    Q.push({s, INF});\n    while(!Q.empty()){\n        int u = Q.front().first;\n        ll f = Q.front().second;\n        Q.pop();\n\n        for(int v : G[u]){\n            if(p[v] == -1 && cap[u][v]){\n                p[v] = u;\n                ll aug = min(f, cap[u][v]);\n                if(v == t)  return aug;\n                Q.push({v, aug});\n            }\n        }\n    }\n\n    return 0;\n}\n\nll maxflow(int s = 1, int t = N){\n    ll flow = 0, aug = 0;\n    while(aug = bfs()){\n        flow += aug;\n        int u = t;\n        while(u != s){\n            int v = p[u];\n            cap[v][u] -= aug;\n            cap[u][v] += aug;\n            u = v;\n        }\n    }\n    return flow;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        ll c;\n        scanf("%d %d %lld", &a, &b, &c);\n        G[a].push_back(b);\n        G[b].push_back(a);\n        cap[a][b] += c;\n    }\n    printf("%lld\\n", maxflow());\n}',
//   "1695":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 501;\nconst int INF = 0x3f3f3f3f;\n\nint N, M, p[maxN], cap[maxN][maxN];\nbool vis[maxN];\nvector<int> G[maxN];\n\nint bfs(int s = 1, int t = N){\n    fill(p+1, p+N+1, -1);\n    p[s] = -2;\n\n    queue<pii> Q;\n    Q.push({s, INF});\n    while(!Q.empty()){\n        int u = Q.front().first;\n        int f = Q.front().second;\n        Q.pop();\n\n        for(int v : G[u]){\n            if(p[v] == -1 && cap[u][v]){\n                p[v] = u;\n                int aug = min(f, cap[u][v]);\n                if(v == t)  return aug;\n                Q.push({v, aug});\n            }\n        }\n    }\n\n    return 0;\n}\n\nvoid dfs(int u = 1){\n    vis[u] = true;\n    for(int v : G[u])\n        if(!vis[v] && cap[u][v])\n            dfs(v);\n}\n\nint maxflow(int s = 1, int t = N){\n    int flow = 0, aug = 0;\n    while(aug = bfs()){\n        flow += aug;\n        int u = t;\n        while(u != s){\n            int v = p[u];\n            cap[v][u] -= aug;\n            cap[u][v] += aug;\n            u = v;\n        }\n    }\n    return flow;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n        cap[a][b]++;\n        cap[b][a]++;\n    }\n    printf("%d\\n", maxflow());\n\n    dfs();\n    for(int u = 1; u <= N; u++){\n        if(!vis[u]) continue;\n        for(int v : G[u])\n            if(!vis[v])\n                printf("%d %d\\n", u, v);\n    }\n}',
//   "1696":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 505;\n\nbool used[maxN];\nint N, M, K, cnt, mt[maxN];\nvector<int> G[maxN];\nvector<pii> pairs;\n\nbool kuhns(int u){\n    if(used[u]) return false;\n\n    used[u] = true;\n    for(int v : G[u]){\n        if(!mt[v] || kuhns(mt[v])){\n            mt[v] = u;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n    for(int i = 0, a, b; i < K; i++){\n        scanf("%d %d", &a, &b);\n        G[b].push_back(a);\n    }\n\n    for(int i = 1; i <= M; i++){\n        fill(used+1, used+N+1, false);\n        kuhns(i);\n    }\n\n    cnt = 0;\n    for(int i = 1; i <= N; i++){\n        if(mt[i]){\n            pairs.push_back({i, mt[i]});\n            cnt++;\n        }\n    }\n\n    printf("%d\\n", cnt);\n    for(pii P : pairs)\n        printf("%d %d\\n", P.first, P.second);\n}',
//   "1697":
//     '#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef pair<int,int> pii;\n\nint N, K;\nvector<pii> added, ans;\ntree<pii, null_type, less<pii>, rb_tree_tag,\ntree_order_statistics_node_update> T;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1, x; i <= N; i++){\n        scanf("%d", &x);\n        T.insert({x, i});\n    }\n\n    for(int i = N-1; i >= 0; i--){\n        pii P = *T.find_by_order(i);\n        T.erase(T.find_by_order(i));\n        int degu = P.first;\n        int u = P.second;\n\n        added.clear();\n        for(int j = 1; j <= degu; j++){\n            if(i-j < 0 || (*T.find_by_order(i-j)).first == 0){\n                printf("IMPOSSIBLE\\n");\n                return 0;\n            }\n\n            pii Q = *T.find_by_order(i-j);\n            T.erase(T.find_by_order(i-j));\n            int degv = Q.first;\n            int v = Q.second;\n\n            ans.push_back({min(u, v), max(u, v)});\n            added.push_back({degv-1, v});\n        }\n\n        for(pii Q : added)\n            T.insert({Q.first, Q.second});\n    }\n\n    sort(ans.begin(), ans.end());\n    K = (int) ans.size();\n    printf("%d\\n", K);\n    for(int i = 0; i < K; i++)\n        printf("%d %d\\n", ans[i].first, ans[i].second);\n}',
//   "1698":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5+1;\n\nbool vis[maxN];\nint N, a[maxN];\nvector<int> cycle;\nvector<pii> ans;\n\nbool zero_rounds(){\n    for(int i = 1; i <= N; i++)\n        if(a[i] != i)\n            return false;\n\n    printf("0\\n");\n    return true;\n}\n\nbool one_round(bool second = false){\n    for(int i = 1; i <= N; i++){\n        if(a[i] != i){\n            if(i != a[a[i]])    { ans.clear(); return false; }\n            else if(i < a[i])   ans.push_back({i, a[i]});\n        }\n    }\n\n    if(!second) printf("1\\n");\n    printf("%d\\n", (int) ans.size());\n    for(pii p : ans){\n        printf("%d %d\\n", p.first, p.second);\n        swap(a[p.first], a[p.second]);\n    }\n    return true;\n}\n\nvoid dfs(int u){\n    vis[u] = true;\n    cycle.push_back(u);\n    if(!vis[a[u]])  dfs(a[u]);\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &a[i]);\n\n    if(!zero_rounds() && !one_round()){\n        printf("2\\n");\n\n        for(int i = 1; i <= N; i++){\n            if(!vis[i]){\n                dfs(i);\n                int K = (int) cycle.size();\n                for(int u = 0; u < K/2; u++){\n                    ans.push_back({cycle[u], cycle[K-u-1]});\n                    swap(a[cycle[u]], a[cycle[K-u-1]]);\n                }\n                cycle.clear();\n            }\n        }\n\n        printf("%d\\n", (int) ans.size());\n        for(pii p : ans)\n            printf("%d %d\\n", p.first, p.second);\n\n        ans.clear();\n        one_round(true);\n    }\n}',
//   "1699":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, M, ds[maxN], vis[maxN];\nvector<int> G[maxN], CC[maxN];\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nbool dfs(int u){\n    vis[u] = -1;\n    bool hascycle = false;\n    for(int v : G[u]){\n        if(vis[v] == -1)        return true;\n        else if(vis[v] == 0)    hascycle |= dfs(v);\n    }\n    vis[u] = 1;\n    return hascycle;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n\n    fill(ds+1, ds+N+1, -1);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        merge(a, b);\n    }\n\n    int K = 0;\n    unordered_map<int,int> getID;\n    for(int u = 1; u <= N; u++){\n        int rep = find(u);\n        if(!getID[rep])\n            getID[rep] = ++K;\n        CC[getID[rep]].push_back(u);\n    }\n\n    int ans = 0;\n    for(int k = 1; k <= K; k++){\n        int sz = (int) CC[k].size();\n        bool hascycle = false;\n        for(int u : CC[k])\n            if(!hascycle && vis[u] == 0)\n                hascycle |= dfs(u);\n        ans += (hascycle ? sz : sz-1);\n    }\n    printf("%d\\n", ans);\n}',
//   "1700":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, treeID, name[2][maxN];\nvector<int> G[2][maxN];\nmap<vector<int>,int> mp;\n\nvoid reset(){\n    for(int t = 0; t < 2; t++)\n        for(int i = 1; i <= N; i++)\n            G[t][i].clear();\n}\n\nvoid dfs(int t, int u, int p){\n    vector<int> childNames;\n    for(int v : G[t][u]){\n        if(v != p){\n            dfs(t, v, u);\n            childNames.push_back(name[t][v]);\n        }\n    }\n    sort(childNames.begin(), childNames.end());\n    if(!mp[childNames]) mp[childNames] = ++treeID;\n    name[t][u] = mp[childNames];\n}\n\nvoid solve_case(){\n    scanf("%d", &N);\n    reset();\n    for(int t = 0; t < 2; t++){\n        for(int i = 0, a, b; i < N-1; i++){\n            scanf("%d %d", &a, &b);\n            G[t][a].push_back(b);\n            G[t][b].push_back(a);\n        }\n        dfs(t, 1, -1);\n    }\n    printf("%s\\n", name[0][1] == name[1][1] ? "YES" : "NO");\n}\n\nint main(){\n    int T;\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        solve_case();\n    }\n}',
//   "1701":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, treeID, sz[2][maxN], name[2][maxN];\nvector<int> centroids[2], G[2][maxN];\nmap<vector<int>,int> mp;\n\nvoid reset(){\n    mp.clear();\n    treeID = 0;\n    for(int t = 0; t < 2; t++){\n        centroids[t].clear();\n        for(int i = 1; i <= N; i++){\n            sz[t][i] = name[t][i] = 0;\n            G[t][i].clear();\n        }\n    }\n}\n\nvoid dfs1(int t, int u, int p){\n    sz[t][u] = 1;\n    bool is_centroid = true;\n    for(int v : G[t][u]){\n        if(v != p){\n            dfs1(t, v, u);\n            sz[t][u] += sz[t][v];\n            if(sz[t][v] > N/2)  is_centroid = false;\n        }\n    }\n    if(N-sz[t][u] > N/2)    is_centroid = false;\n    if(is_centroid)         centroids[t].push_back(u);\n}\n\nvoid dfs2(int t, int u, int p){\n    vector<int> childNames;\n    for(int v : G[t][u]){\n        if(v != p){\n            dfs2(t, v, u);\n            childNames.push_back(name[t][v]);\n        }\n    }\n    sort(childNames.begin(), childNames.end());\n    if(!mp[childNames]) mp[childNames] = ++treeID;\n    name[t][u] = mp[childNames];\n}\n\nvoid solve_case(){\n    scanf("%d", &N);\n    reset();\n\n    for(int t = 0; t < 2; t++){\n        for(int i = 0, a, b; i < N-1; i++){\n            scanf("%d %d", &a, &b);\n            G[t][a].push_back(b);\n            G[t][b].push_back(a);\n        }\n        dfs1(t, 1, -1);\n    }\n\n    for(int root1 : centroids[0]){\n        for(int root2 : centroids[1]){\n            dfs2(0, root1, -1);\n            dfs2(1, root2, -1);\n            if(name[0][root1] == name[1][root2]){\n                printf("YES\\n");\n                return;\n            }\n        }\n    }\n    printf("NO\\n");\n}\n\nint main(){\n    int T;\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        solve_case();\n    }\n}',
//   "1702":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+5;\n\nint N, timer, A[maxN], B[maxN], C[maxN], idx[maxN];\nint L[maxN], R[maxN];\n\nint solve(int l1 = 0, int r1 = N-1, int l2 = 0, int r2 = N-1){\n    if(l1 > r1 || l2 > r2)  return 0;\n    int root = A[l1];\n    int m2 = idx[root];\n    int len = m2-l2;\n    L[root] = solve(l1+1, l1+len, l2, m2-1);\n    R[root] = solve(l1+len+1, r1, m2+1, r2);\n    return root;\n}\n\nvoid dfs(int u){\n    if(L[u])    dfs(L[u]);\n    if(R[u])    dfs(R[u]);\n    C[timer++] = u;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)  scanf("%d", &A[i]);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &B[i]);\n        idx[B[i]] = i;\n    }\n\n    int root = solve();\n    dfs(root);\n    for(int i = 0; i < N; i++)\n        printf("%d%c", C[i], (" \\n")[i==N-1]);\n}',
//   "1703":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, M, p[maxN], sdom[maxN], idom[maxN], label[maxN];\nint timer, tin[maxN], inv[maxN], dsu[maxN];\nvector<int> ans, G[maxN], GR[maxN], DT[maxN], bucket[maxN];\n\nvoid dfs(int u = 1){\n    tin[u] = ++timer;\n    inv[timer] = u;\n    label[timer] = sdom[timer] = dsu[timer] = timer;\n    for(int v : G[u]){\n        if(!tin[v]){\n            dfs(v);\n            p[tin[v]] = tin[u];\n        }\n        GR[tin[v]].push_back(tin[u]);\n    }\n}\n\nint find(int u, bool x = false){\n    if(u == dsu[u]) return x ? -1 : u;\n    int v = find(dsu[u], true);\n    if(v < 0)   return u;\n\n    if(sdom[label[dsu[u]]] < sdom[label[u]])\n        label[u] = label[dsu[u]];\n\n    dsu[u] = v;\n    return x ? v : label[u];\n}\n\nvoid build_dominator_tree(){\n    dfs();\n\n    for(int u = N; u > 0; u--){\n        for(int v : GR[u])\n            sdom[u] = min(sdom[u], sdom[find(v)]);\n        if(u > 1)   bucket[sdom[u]].push_back(u);\n        for(int v : bucket[u])\n            idom[v] = (sdom[find(v)] == sdom[v] ? sdom[v] : find(v));\n        if(u > 1)   dsu[u] = p[u];\n    }\n\n    for(int u = 2; u <= N; u++){\n        if(idom[u] != sdom[u])\n            idom[u] = idom[idom[u]];\n        DT[inv[u]].push_back(inv[idom[u]]);\n        DT[inv[idom[u]]].push_back(inv[u]);\n    }\n}\n\nbool dfs_dominator_tree(int u = 1, int p = -1){\n    bool good = (u == N);\n    for(int v : DT[u])\n        if(v != p)\n            good |= dfs_dominator_tree(v, u);\n    if(good)    ans.push_back(u);\n    return good;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n    }\n\n    build_dominator_tree();\n    dfs_dominator_tree();\n\n    sort(ans.begin(), ans.end());\n    int K = (int) ans.size();\n    printf("%d\\n", K);\n    for(int i = 0; i < K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K-1]);\n}',
//   "1704":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, K;\nvector<int> leaves, G[maxN];\n\nvoid dfs(int u = 1, int p = -1){\n    if((int) G[u].size() == 1)  leaves.push_back(u);\n    for(int v : G[u])\n        if(v != p)\n            dfs(v, u);\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0, a, b; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs();\n\n    int K = (int) leaves.size();\n    printf("%d\\n", (K+1)/2);\n    for(int i = 0; i < (K+1)/2; i++)\n        printf("%d %d\\n", leaves[i], leaves[i+K/2]);\n}',
//   "1706":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, M, a, b, ds[maxN];\nmultiset<int> sizes;\nbitset<maxN> dp;\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    fill(ds+1, ds+N+1, -1);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        merge(a, b);\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(find(i) == i)\n            sizes.insert(-ds[i]);\n\n    dp[0] = 1;\n    for(int sz : sizes)\n        dp |= (dp<<sz);\n\n    for(int i = 1; i <= N; i++)\n        printf("%d", dp[i] ? 1 : 0);\n    printf("\\n");\n}\n',
//   "1707":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2501;\n\nbool vis[maxN];\nint N, M, best, p[maxN], dist[maxN];\nvector<int> G[maxN];\n\nvoid reset(){\n    fill(vis+1, vis+N+1, false);\n    fill(dist+1, dist+N+1, 0);\n    fill(p+1, p+N+1, 0);\n}\n\nvoid bfs(int start){\n    queue<int> Q;\n    Q.push(start);\n    vis[start] = true;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        for(int v : G[u]){\n            if(!vis[v]){\n                dist[v] = dist[u]+1;\n                vis[v] = true;\n                p[v] = u;\n                Q.push(v);\n            } else if(v != u[p]){\n                best = min(best, dist[u]+dist[v]+1);\n            }\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    best = N+1;\n    for(int start = 1; start <= N; start++){\n        reset();\n        bfs(start);\n    }\n\n    printf("%d\\n", best == N+1 ? -1 : best);\n}',
//   "1709":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 105;\n\nchar S[maxN];\nbool used[maxN], inZ[2][maxN];\nint N, cnt, mt[maxN];\nvector<int> G[maxN];\n\nbool kuhns(int u){\n    if(used[u]) return false;\n\n    used[u] = true;\n    for(int v : G[u]){\n        if(!mt[v] || kuhns(mt[v])){\n            mt[v] = u;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvoid dfs(int t, int u){\n    inZ[t][u] = true;\n    if(t == 0 && !inZ[1][mt[u]]){\n        dfs(1, mt[u]);\n    } else if(t == 1){\n        for(int v : G[u])\n            if(!inZ[0][v])\n                dfs(0, v);\n    }\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++){\n        scanf(" %s", S);\n        for(int j = 1; j <= N; j++)\n            if(S[j-1] == \'o\')\n                G[j].push_back(i);\n    }\n\n    for(int i = 1; i <= N; i++){\n        kuhns(i);\n        fill(used+1, used+N+1, false);\n    }\n\n    cnt = 0;\n    for(int i = 1; i <= N; i++){\n        if(mt[i]){\n            cnt++;\n            used[mt[i]] = true;\n        }\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(!used[i])\n            dfs(1, i);\n\n    printf("%d\\n", cnt);\n    for(int i = 1; i <= N; i++)\n        if(inZ[0][i])\n            printf("1 %d\\n", i);\n    for(int i = 1; i <= N; i++)\n        if(!inZ[1][i])\n            printf("2 %d\\n", i);\n}',
//   "1712":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nint N;\nll A, B, C;\n\nll fastpow(ll a, ll b, ll mod){\n    ll res = 1;\n    while(b > 0){\n        if(b&1)\n            res = (res * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%lld %lld %lld", &A, &B, &C);\n        printf("%lld\\n", fastpow(A, fastpow(B, C, MOD-1), MOD));\n    }\n}\n',
//   "1713":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxX = 1e6;\n\nint N, x, d[maxX+1];\n\nvoid init(){\n    for(int i = 1; i <= maxX; i++)\n        for(int j = i; j <= maxX; j += i)\n            d[j]++;\n}\n\nint main(){\n    scanf("%d", &N);\n\n    init();\n    for(int i = 0; i < N; i++){\n        scanf("%d", &x);\n        printf("%d\\n", d[x]);\n    }\n}\n',
//   "1715":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e6+5;\nconst ll MOD = 1e9+7;\n\nint N, freq[26];\nchar S[maxN];\nll fact[maxN], inv[maxN];\n\nll inverse(ll x){\n    ll res = 1;\n    ll expo = MOD-2;\n    while(expo > 0){\n        if(expo&1)\n            res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        expo >>= 1;\n    }\n    return res;\n}\n\nvoid init(){\n    fact[0] = inv[0] = 1;\n    for(int i = 1; i < maxN; i++){\n        fact[i] = i * fact[i-1] % MOD;\n        inv[i] = inverse(fact[i]);\n    }\n}\n\nint main(){\n    scanf("%s", S);\n    N = (int) strlen(S);\n    init();\n\n    for(int i = 0; i < N; i++)\n        freq[(int) (S[i]-\'a\')]++;\n\n    ll ans = fact[N];\n    for(int i = 0; i < 26; i++)\n        ans = ans * inv[freq[i]] % MOD;\n    printf("%lld\\n", ans);\n}\n',
//   "1716":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e6;\nconst ll MOD = 1e9+7;\n\nint N, M;\nll fact[maxN], inv[maxN];\n\nll inverse(ll x){\n    ll res = 1;\n    ll expo = MOD-2;\n    while(expo > 0){\n        if(expo&1)\n            res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        expo >>= 1;\n    }\n    return res;\n}\n\nvoid init(){\n    fact[0] = inv[0] = 1;\n    for(int i = 1; i < maxN; i++){\n        fact[i] = i * fact[i-1] % MOD;\n        inv[i] = inverse(fact[i]);\n    }\n}\n\nll choose(int n, int k){\n    return fact[n] * inv[k] % MOD * inv[n-k] % MOD;\n}\n\nint main(){\n    init();\n    scanf("%d %d", &N, &M);\n    printf("%lld\\n", choose(N+M-1, M));\n}\n',
//   "1717":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e6;\nconst ll MOD = 1e9+7;\n\nint N;\nll dp[maxN+1];\n\nvoid init(){\n    dp[2] = 1;\n    for(int i = 3; i <= maxN; i++)\n        dp[i] = (i-1) * (dp[i-1] + dp[i-2]) % MOD;\n}\n\nint main(){\n    init();\n    scanf("%d", &N);\n    printf("%lld\\n", dp[N]);\n}\n',
//   "1722":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nll N, x[2][2], y[2][2];\n\nvoid mult(ll A[2][2], ll B[2][2]){\n    ll C[2][2];\n    memset(C, 0, sizeof(C));\n    for(int i = 0; i < 2; i++){\n        for(int j = 0; j < 2; j++){\n            for(int k = 0; k < 2; k++){\n                C[i][j] += A[i][k] * B[k][j];\n                C[i][j] %= MOD;\n            }\n        }\n    }\n    for(int i = 0; i < 2; i++)\n        for(int j = 0; j < 2; j++)\n            A[i][j] = C[i][j];\n}\n\nint main(){\n    x[0][1] = x[1][0] = x[1][1] = y[0][0] = y[1][1] = 1;\n\n    scanf("%lld", &N);\n    while(N){\n        if(N&1)\n            mult(y, x);\n        mult(x, x);\n        N >>= 1;\n    }\n\n    printf("%lld\\n", y[0][1]);\n}\n',
//   "1723":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 100;\nconst ll MOD = 1e9+7;\n\nint N, M, K, a, b;\nll X[maxN][maxN], Y[maxN][maxN];\n\nvoid mult(ll A[maxN][maxN], ll B[maxN][maxN]){\n    ll C[N][N];\n    memset(C, 0, sizeof(C));\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            for(int k = 0; k < N; k++){\n                C[i][j] += A[i][k] * B[k][j];\n                C[i][j] %= MOD;\n            }\n        }\n    }\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            A[i][j] = C[i][j];\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        X[a-1][b-1]++;\n    }\n    for(int i = 0; i < N; i++)\n        Y[i][i] = 1;\n\n    while(K){\n        if(K&1)\n            mult(Y, X);\n        mult(X, X);\n        K >>= 1;\n    }\n\n    printf("%lld\\n", Y[0][N-1]);\n}\n',
//   "1724":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef unsigned long long ull;\nconst int maxN = 100;\nconst ull INF = 1e19;\n\nint N, M, K, a, b;\null c, X[maxN][maxN], Y[maxN][maxN];\n\nvoid combine(ull A[maxN][maxN], ull B[maxN][maxN]){\n    ull C[maxN][maxN];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            C[i][j] = INF;\n\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            for(int k = 0; k < N; k++)\n                if(A[i][k] != INF && B[k][j] != INF)\n                    C[i][j] = min(C[i][j], A[i][k] + B[k][j]);\n\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            A[i][j] = C[i][j];\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++)\n            X[i][j] = Y[i][j] = INF;\n        Y[i][i] = 0;\n    }\n\n    for(int i = 0; i < M; i++){\n        scanf("%d %d %llu", &a, &b, &c);\n        X[a-1][b-1] = min(X[a-1][b-1], c);\n    }\n\n    while(K){\n        if(K&1)\n            combine(Y, X);\n        combine(X, X);\n        K >>= 1;\n    }\n\n    if(Y[0][N-1] == INF)    printf("-1\\n");\n    else                    printf("%llu\\n", Y[0][N-1]);\n}\n',
//   "1725":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 100;\n\nint N, a, b;\ndouble sum, dp[maxN+1][6*maxN+1];\n\nint main(){\n    scanf("%d %d %d", &N, &a, &b);\n    dp[0][0] = 1;\n    for(int i = 1; i <= N; i++)\n        for(int j = 1; j <= 6*maxN; j++)\n            for(int k = 1; k <= 6; k++)\n                if(j-k >= 0)\n                    dp[i][j] += dp[i-1][j-k]/6;\n    for(int i = a; i <= b; i++)\n        sum += dp[N][i];\n    printf("%.6f\\n", sum);\n}\n',
//   "1726":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxK = 101;\nconst int N = 8, SZ = N*N;\n\nint K;\ndouble expected, ans[SZ], dp[maxK][SZ];\n\nint main(){\n    scanf("%d", &K);\n    for(int i = 0; i < SZ; i++)\n        ans[i] = 1.0;\n\n    for(int start = 0; start < SZ; start++){\n        memset(dp, 0, sizeof(dp));\n        dp[0][start] = 1.0;\n\n        for(int k = 0; k < K; k++){\n            for(int u = 0; u < SZ; u++){\n                vector<int> V;\n                if(N <= u)          V.push_back(u-N);\n                if(u < N*(N-1))     V.push_back(u+N);\n                if(u % N != 0)      V.push_back(u-1);\n                if(u % N != N-1)    V.push_back(u+1);\n\n                for(int v : V)\n                    dp[k+1][v] += (dp[k][u] / V.size());\n            }\n        }\n\n        for(int u = 0; u < SZ; u++)\n            ans[u] *= (1 - dp[K][u]);\n    }\n\n    for(int i = 0; i < SZ; i++)\n        expected += ans[i];\n    printf("%.6f\\n", expected);\n}',
//   "1727":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, K;\ndouble ans, a, b;\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 1; i <= K; i++){\n        a = b = 1.0;\n        for(int j = 1; j <= N; j++){\n            a *= (double) i / K;\n            b *= (double) (i-1) / K;\n        }\n        ans += (a-b) * i;\n    }\n    printf("%.6f\\n", ans);\n}\n',
//   "1728":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 101;\n\nint N, r[maxN];\nlong double ans;\n\nint f(int x){\n    return x * (x-1) / 2;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &r[i]);\n        for(int j = 0; j < i; j++){\n            int tot = (r[j] <= r[i]) ? f(r[j]) : (f(r[i]) + (r[j]-r[i]) * r[i]);\n            ans += (long double) tot / (r[i] * r[j]);\n        }\n    }\n    printf("%.6Lf\\n", ans);\n}',
//   "1729":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6;\nconst int maxK = 100;\n\nint N, K, p[maxK];\nbool dp[maxN+1];\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 0; i < K; i++)\n        scanf("%d", &p[i]);\n\n    for(int i = 1; i <= N; i++){\n        for(int j = 0; j < K; j++)\n            if(i-p[j] >= 0 && !dp[i-p[j]])\n                dp[i] = true;\n        printf("%c", ("LW")[dp[i]]);\n    }\n}\n',
//   "1730":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T, N, x, xum;\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        scanf("%d", &N);\n        xum = 0;\n        for(int i = 0; i < N; i++){\n            scanf("%d", &x);\n            xum ^= x;\n        }\n        printf("%s\\n", (xum ? "first" : "second"));\n    }\n}\n',
//   "1731":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 5005, K = 26;\nconst ll MOD = 1e9+7;\n\nstruct Node {\n    int next[K];\n    bool leaf = false;\n    Node(){ fill(next, next+K, -1); }\n};\n\nint N, M;\nll dp[maxN];\nchar S[maxN], word[maxN];\nvector<Node> trie(1);\n\nvoid add_word(){\n    scanf(" %s", word);\n    int v = 0;\n    M = (int) strlen(word);\n    for(int i = 0; i < M; i++){\n        int c = (int) (word[i] - \'a\');\n        if(trie[v].next[c] == -1){\n            trie[v].next[c] = trie.size();\n            trie.emplace_back();\n        }\n        v = trie[v].next[c];\n    }\n    trie[v].leaf = true;\n}\n\nint main(){\n    scanf(" %s %d", S, &N);\n    for(int i = 0; i < N; i++)\n        add_word();\n\n    M = (int) strlen(S);\n    dp[M] = 1;\n    for(int i = M-1; i >= 0; i--){\n        int v = 0;\n        for(int j = i; j < M; j++){\n            int c = (int) (S[j] - \'a\');\n            if(trie[v].next[c] == -1)   break;\n            v = trie[v].next[c];\n\n            if(trie[v].leaf)\n                dp[i] = (dp[i] + dp[j+1]) % MOD;\n        }\n    }\n    printf("%lld\\n", dp[0]);\n}',
//   "1732":
//     "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\nconst ll p1 = 31;\nconst ll p2 = 37;\nconst int maxN = 1e6+5;\n\nint N;\nll pow1[maxN], pow2[maxN], ph1, ph2, sh1, sh2;\nchar S[maxN];\n\nint main(){\n    scanf(\"%s\", S);\n    N = (int) strlen(S);\n\n    pow1[0] = pow2[0] = 1;\n    for(int i = 1; i < N; i++){\n        pow1[i] = (pow1[i-1] * p1) % MOD;\n        pow2[i] = (pow2[i-1] * p2) % MOD;\n    }\n\n    for(int i = 0; i < N-1; i++){\n        int l = (S[i] - 'a' + 1);\n        int r = (S[N-i-1] - 'a' + 1);\n\n        ph1 = (ph1 + l * pow1[i]) % MOD;\n        ph2 = (ph2 + l * pow2[i]) % MOD;\n        sh1 = (sh1 * p1 + r) % MOD;\n        sh2 = (sh2 * p2 + r) % MOD;\n\n        if(ph1 == sh1 && ph2 == sh2)\n            printf(\"%d \", i+1);\n    }\n}",
//   "1733":
//     "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\nconst ll p1 = 31, p2 = 37;\nconst int maxN = 1e6+5;\n\nint N;\nchar S[maxN];\nll pow1[maxN], pow2[maxN], h1[maxN], h2[maxN];\n\nvoid init(){\n    pow1[0] = pow2[0] = 1;\n    h1[0] = h2[0] = (int) (S[0] - 'a' + 1);\n    for(int i = 1; i < maxN; i++){\n        int c = (int) (S[i] - 'a' + 1);\n        pow1[i] = (pow1[i-1] * p1) % MOD;\n        pow2[i] = (pow2[i-1] * p2) % MOD;\n        h1[i] = (h1[i-1] * p1 + c) % MOD;\n        h2[i] = (h2[i-1] * p2 + c) % MOD;\n    }\n}\n\nint main(){\n    scanf(\" %s\", S);\n    N = (int) strlen(S);\n    init();\n\n    for(int len = 1; len <= N; len++){\n        ll hash1 = h1[len-1], hash2 = h2[len-1];\n        for(int i = 0; i < (N/len)-1; i++){\n            hash1 = (hash1 * pow1[len] + h1[len-1]) % MOD;\n            hash2 = (hash2 * pow2[len] + h2[len-1]) % MOD;\n        }\n        hash1 = (hash1 * pow1[N%len] + h1[N%len-1]) % MOD;\n        hash2 = (hash2 * pow2[N%len] + h2[N%len-1]) % MOD;\n        if(hash1 == h1[N-1] && hash2 == h2[N-1])    printf(\"%d \", len);\n    }\n}",
//   "1734":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef array<int,3> triple;\nconst int maxN = 2e5+1;\n\nint N, Q, a, b, x[maxN], ptr[maxN], ds[maxN], ans[maxN];\ntriple queries[maxN];\nmap<int,int> mp;\nset<int> S;\n\nvoid update(int idx, int val){\n    for(int i = idx; i <= N; i += -i&i)\n        ds[i] += val;\n}\n\nint query(int idx){\n    int sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum += ds[i];\n    return sum;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &x[i]);\n\n    for(int i = N; i > 0; i--){\n        if(mp[x[i]])\n            ptr[i] = mp[x[i]];\n        mp[x[i]] = i;\n    }\n\n    for(int i = 1; i <= N; i++){\n        if(S.count(x[i]) == 0)\n            update(i, 1);\n        S.insert(x[i]);\n    }\n\n    for(int i = 0; i < Q; i++){\n        scanf("%d %d", &a, &b);\n        queries[i] = {a, b, i};\n    }\n    sort(queries, queries+Q);\n\n    int l = 1;\n    for(int q = 0; q < Q; q++){\n        while(l < queries[q][0]){\n            if(ptr[l])\n                update(ptr[l], 1);\n            l++;\n        }\n        ans[queries[q][2]] = query(queries[q][1]) - query(queries[q][0]-1);\n    }\n\n    for(int q = 0; q < Q; q++)\n        printf("%d\\n", ans[q]);\n}\n',
//   "1735":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, Q, t, a, b, lo[4*maxN], hi[4*maxN];\nll x, del[4*maxN], ass[4*maxN], sum[4*maxN];\n\nint len(int i){\n    return hi[i]-lo[i]+1;\n}\n\nvoid increment(int i, ll v){\n    del[i] += v;\n    sum[i] += len(i) * v;\n}\n\nvoid assign(int i, ll v){\n    ass[i] = v;\n    del[i] = 0;\n    sum[i] = len(i) * v;\n}\n\nvoid push(int i){\n    if(ass[i]){\n        assign(2*i, ass[i]);\n        assign(2*i+1, ass[i]);\n        ass[i] = 0;\n    }\n    if(del[i]){\n        increment(2*i, del[i]);\n        increment(2*i+1, del[i]);\n        del[i] = 0;\n    }\n}\n\nvoid pull(int i){\n    sum[i] = sum[2*i] + sum[2*i+1];\n}\n\nvoid build(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        scanf("%lld", &sum[i]);\n        return;\n    }\n    int m = l+(r-l)/2;\n    build(2*i, l, m);\n    build(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid increment(int i, int l, int r, ll v){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        increment(i, v); return;\n    }\n\n    push(i);\n    increment(2*i, l, r, v);\n    increment(2*i+1, l, r, v);\n    pull(i);\n}\n\nvoid assign(int i, int l, int r, ll v){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        assign(i, v); return;\n    }\n\n    push(i);\n    assign(2*i, l, r, v);\n    assign(2*i+1, l, r, v);\n    pull(i);\n}\n\nll query(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])  return 0;\n    if(l <= lo[i] && hi[i] <= r){\n        return sum[i];\n    }\n\n    push(i);\n    ll lsum = query(2*i, l, r);\n    ll rsum = query(2*i+1, l, r);\n    pull(i);\n\n    return lsum + rsum;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n\n    build(1, 1, N);\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d %d", &t, &a, &b);\n        if(t == 1){\n            scanf("%lld", &x);\n            increment(1, a, b, x);\n        } else if(t == 2){\n            scanf("%lld", &x);\n            assign(1, a, b, x);\n        } else if(t == 3){\n            printf("%lld\\n", query(1, a, b));\n        }\n    }\n}\n',
//   "1736":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int SIZE = 8e5;\n\nint N, Q, t, a, b, lo[SIZE], hi[SIZE];\nll d1[SIZE], d2[SIZE], s1[SIZE], s2[SIZE];\n\nint len(int i){\n    return hi[i]-lo[i]+1;\n}\n\nll sigma(int i){\n    return ((ll) hi[i] * (hi[i]+1))/2 - ((ll) lo[i] * (lo[i]-1))/2;\n}\n\nvoid push(int i){\n    if(d1[i]){\n        d1[2*i] += d1[i];\n        d1[2*i+1] += d1[i];\n        d1[i] = 0;\n    }\n    if(d2[i]){\n        d2[2*i] += d2[i];\n        d2[2*i+1] += d2[i];\n        d2[i] = 0;\n    }\n}\n\nvoid pull(int i){\n    ll l1 = s1[2*i] + (d1[2*i] * len(2*i));\n    ll r1 = s1[2*i+1] + (d1[2*i+1] * len(2*i+1));\n    s1[i] = l1 + r1;\n    ll l2 = s2[2*i] + (d2[2*i] * sigma(2*i));\n    ll r2 = s2[2*i+1] + (d2[2*i+1] * sigma(2*i+1));\n    s2[i] = l2 + r2;\n}\n\nvoid build(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        scanf("%lld", &s1[i]);\n        return;\n    }\n    int m = l+(r-l)/2;\n    build(2*i, l, m);\n    build(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid increment(int type, int i, int l, int r, ll v){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        if(type == 1)   d1[i] += v;\n        if(type == 2)   d2[i] += v;\n        return;\n    }\n\n    push(i);\n    increment(type, 2*i, l, r, v);\n    increment(type, 2*i+1, l, r, v);\n    pull(i);\n}\n\nll sum(int type, int i, int l, int r){\n    if(l > hi[i] || r < lo[i])  return 0;\n    if(l <= lo[i] && hi[i] <= r){\n        if(type == 1)   return s1[i] + (d1[i] * len(i));\n        if(type == 2)   return s2[i] + (d2[i] * sigma(i));\n        return 0;\n    }\n\n    push(i);\n    ll lsum = sum(type, 2*i, l, r);\n    ll rsum = sum(type, 2*i+1, l, r);\n    pull(i);\n\n    return lsum + rsum;\n}\n\nvoid update(int l, int r){\n    increment(1, 1, l, r, -l+1);\n    increment(2, 1, l, r, 1);\n}\n\nll query(int l, int r){\n    return sum(1, 1, l, r) + sum(2, 1, l, r);\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n\n    build(1, 1, N);\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d %d", &t, &a, &b);\n        if(t == 1)      update(a, b);\n        else if(t == 2) printf("%lld\\n", query(a, b));\n    }\n}\n',
//   "1737":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nstruct Node {\n    Node *l, *r;\n    int lo, hi;\n    ll sum;\n    Node(int low, int high, int val) : l(nullptr), r(nullptr), lo(low), hi(high), sum(val) {}\n    Node(Node *left, Node *right) : l(left), r(right), sum(0) {\n        if(left){\n            sum += left->sum;\n            lo = left->lo;\n        }\n        if(right){\n            sum += right->sum;\n            hi = right->hi;\n        }\n    }\n};\n\nint N, Q, type, k, a, b, x, cnt, t[maxN];\nNode* seg[maxN];\n\nNode* build(int l, int r){\n    if(l == r)  return new Node(l, r, t[l]);\n    int m = (l+r)/2;\n    return new Node(build(l, m), build(m+1, r));\n}\n\nNode* update(Node* node, int idx, int val){\n    if(node->lo == node->hi)    return new Node(idx, idx, val);\n    int m = (node->lo+node->hi)/2;\n    if(idx <= m)    return new Node(update(node->l, idx, val), node->r);\n    else            return new Node(node->l, update(node->r, idx, val));\n}\n\nll query(Node* node, int l, int r){\n    if(l > node->hi || r < node->lo)    return 0;\n    if(l <= node->lo && node->hi <= r)  return node->sum;\n    return query(node->l, l, r) + query(node->r, l, r);\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &t[i]);\n\n    cnt = 1;\n    seg[cnt++] = build(1, N);\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &type, &k);\n        if(type == 1){\n            scanf("%d %d", &a, &x);\n            seg[k] = update(seg[k], a, x);\n        } else if(type == 2){\n            scanf("%d %d", &a, &b);\n            printf("%lld\\n", query(seg[k], a, b));\n        } else if(type == 3){\n            seg[cnt++] = new Node(seg[k]->l, seg[k]->r);\n        }\n    }\n}\n',
//   "1739":
//     "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1000;\n\nint N, Q;\nchar c[maxN+1][maxN+1];\nll ds[maxN+1][maxN+1];\n\nvoid update(int x, int y, ll val){\n    for(int i = x; i <= N; i += -i&i)\n        for(int j = y; j <= N; j += -j&j)\n            ds[i][j] += val;\n}\n\nll query(int x, int y){\n    ll sum = 0;\n    for(int i = x; i > 0; i -= -i&i)\n        for(int j = y; j > 0; j -= -j&j)\n            sum += ds[i][j];\n    return sum;\n}\n\nint main(){\n    scanf(\"%d %d\", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        for(int j = 1; j <= N; j++){\n            scanf(\" %c\", &c[i][j]);\n            if(c[i][j] == '*')\n                update(i, j, 1);\n        }\n    }\n    for(int q = 0, t, x1, y1, x2, y2; q < Q; q++){\n        scanf(\"%d %d %d\", &t, &x1, &y1);\n        if(t == 1){\n            if(c[x1][y1] == '*'){\n                update(x1, y1, -1);\n                c[x1][y1] = '.';\n            } else if(c[x1][y1] == '.'){\n                update(x1, y1, 1);\n                c[x1][y1] = '*';\n            }\n        } else if(t == 2){\n            scanf(\"%d %d\", &x2, &y2);\n            printf(\"%lld\\n\", query(x2, y2)-query(x2,y1-1)-query(x1-1,y2)+query(x1-1,y1-1));\n        }\n    }\n}\n",
//   "1740":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+1;\nconst int maxX = 1e6+5;\nconst int SIZE = 2*maxX;\n\nstruct Operation {\n    int type, y, a, b;\n};\n\nint N, ds[SIZE];\nvector<Operation> ops;\n\nvoid update(int idx, int val){\n    for(int i = idx; i < SIZE; i += -i&i)\n        ds[i] += val;\n}\n\nint query(int idx){\n    int sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum += ds[i];\n    return sum;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0, a, b, c, d; i < N; i++){\n        scanf("%d %d %d %d", &a, &b, &c, &d);\n        if(a == c){\n            // Vertical\n            ops.push_back({2, b, a+maxX, -1});\n            ops.push_back({3, d, a+maxX, -1});\n        } else {\n            // Horizontal\n            ops.push_back({1, b, a+maxX, c+maxX});\n        }\n    }\n    sort(ops.begin(), ops.end(), [](Operation A, Operation B){\n        return A.y < B.y;\n    });\n\n    ll ans = 0;\n    for(Operation O : ops){\n        if(O.type == 1)         ans += query(O.b) - query(O.a-1);\n        else if(O.type == 2)    update(O.a, 1);\n        else if(O.type == 3)    update(O.a, -1);\n    }\n    printf("%lld\\n", ans);\n}',
//   "1741":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef array<int,4> Operation;\nconst int maxN = 1e5;\nconst int SZ = 9e6;\n\nint N, lo[SZ], hi[SZ];\nll area, delta[SZ], score[SZ];\nOperation op[2*maxN];\n\nint len(int i){\n    return hi[i]-lo[i]+1;\n}\n\nvoid pull(int i){\n    if(lo[i] == hi[i])  score[i] = (delta[i] > 0 ? 1 : 0);\n    else                score[i] = (delta[i] > 0 ? len(i) : score[2*i] + score[2*i+1]);\n}\n\nvoid build(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r)  return;\n    int m = l+(r-l)/2;\n    build(2*i, l, m);\n    build(2*i+1, m+1, r);\n}\n\nvoid increment(int i, int l, int r, ll val){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        delta[i] += val;\n        pull(i);\n        return;\n    }\n    increment(2*i, l, r, val);\n    increment(2*i+1, l, r, val);\n    pull(i);\n}\n\nll query(){\n    return score[1];\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0, a, b, c, d; i < N; i++){\n        scanf("%d %d %d %d", &a, &b, &c, &d);\n        op[2*i] = {1, b, a+1, c};\n        op[2*i+1] = {-1, d, a+1, c};\n    }\n    sort(op, op+2*N, [](Operation A, Operation B){\n       return (A[1] == B[1] ? A[0] < B[0] : A[1] < B[1]);\n    });\n\n    build(1, -1e6-5, 1e6+5);\n    int lst = -1e6;\n    for(int i = 0; i < 2*N; i++){\n        int t = op[i][0], y = op[i][1], x1 = op[i][2], x2 = op[i][3];\n        area += (y-lst) * query();\n        increment(1, x1, x2, t);\n        lst = y;\n    }\n\n    printf("%lld\\n", area);\n}',
//   "1743":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6+5;\n\nint freq[26];\nchar S[maxN], ans[maxN];\n\nbool possible(int current){\n    int mode = 0, total = 0;\n    for(int c = 0; c < 26; c++){\n        if(freq[mode] < freq[c])\n            mode = c;\n        total += freq[c];\n    }\n    return (freq[mode] <= (total+1)/2) && (freq[current] <= total/2);\n}\n\nint main(){\n    scanf(" %s", S);\n    const int N = (int) strlen(S);\n    for(int i = 0; i < N; i++)\n        freq[(int) (S[i] - \'A\')]++;\n\n    int lastchar = -1;\n    for(int i = 0; i < N; i++){\n        bool filled = false;\n        for(int c = 0; c < 26 && !filled; c++){\n            if(freq[c] > 0 && c != lastchar){\n                freq[c]--;\n                if(possible(c)){\n                    ans[i] = (char) (c + \'A\');\n                    lastchar = c;\n                    filled = true;\n                } else freq[c]++;\n            }\n        }\n\n        if(!filled){\n            printf("-1\\n");\n            return 0;\n        }\n    }\n\n    for(int i = 0; i < N; i++)\n        printf("%c", ans[i]);\n    printf("\\n");\n}',
//   "1744":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\n\nint A, B, dp[501][501];\n\nint solve(int a, int b){\n    if(a > b)   swap(a, b);\n    if(dp[a][b] != INF)     return dp[a][b];\n    if(a == b)              return dp[a][b] = 0;\n    if(a == 1 || b == 1)    return dp[a][b] = (a == 1 ? b-1 : a-1);\n    for(int i = 1; i < a; i++)\n        dp[a][b] = min(dp[a][b], solve(i, b) + solve(a-i, b) + 1);\n    for(int i = 1; i < b; i++)\n        dp[a][b] = min(dp[a][b], solve(a, i) + solve(a, b-i) + 1);\n    return dp[a][b];\n}\n\nint main(){\n    memset(dp, 0x3f, sizeof(dp));\n    scanf("%d %d", &A, &B);\n    printf("%d\\n", solve(A, B));\n}\n',
//   "1745":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxX = 1e5;\n\nint N, x, cnt, largest;\nbool dp[maxX+1];\n\nint main(){\n    scanf("%d", &N);\n\n    dp[0] = true;\n    for(int i = 0; i < N; i++){\n        scanf("%d", &x);\n        for(int j = maxX-x; j >= 0; j--)\n            if(dp[j])\n                dp[j+x] = true;\n    }\n\n    for(int i = 1; i <= maxX; i++){\n        if(dp[i]){\n            largest = i;\n            cnt++;\n        }\n    }\n\n    printf("%d\\n", cnt++);\n    for(int i = 1; i <= maxX; i++)\n        if(dp[i])\n            printf("%d%c", i, (" \\n")[i==largest]);\n}\n',
//   "1746":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5;\nconst int maxM = 100;\nconst ll MOD = 1e9+7;\n\nint N, M, x[maxN+1];\nll ans, dp[maxN+1][maxM+1];\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &x[i]);\n\n    if(x[1])\n        dp[1][x[1]] = 1;\n    else\n        for(int i = 1; i <= M; i++)\n            dp[1][i] = 1;\n\n    for(int i = 2; i <= N; i++){\n        for(int j = 1; j <= M; j++){\n            dp[i][j] = dp[i-1][j];\n            if(j != 1)  dp[i][j] += dp[i-1][j-1];\n            if(j != M)  dp[i][j] += dp[i-1][j+1];\n            dp[i][j] %= MOD;\n        }\n\n        if(x[i])\n            for(int j = 0; j <= M; j++)\n                if(j != x[i])\n                    dp[i][j] = 0;\n    }\n\n    for(int i= 1; i <= M; i++)\n        ans = (ans + dp[N][i]) % MOD;\n    printf("%lld\\n", ans);\n}\n',
//   "1747":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5+1;\n\nint N, ds[maxN];\npii X[maxN];\n\nvoid update(int idx){\n    for(int i = idx; i <= N; i += -i&i) ds[i]++;\n}\n\nint query(int idx){\n    int cnt = 0;\n    for(int i = idx; i; i -= -i&i)\n        cnt += ds[i];\n    return cnt;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0, x; i < N; i++){\n        scanf("%d", &x);\n        X[i] = {x, i+1};\n    }\n    sort(X, X+N, [](pii a, pii b){\n        return a.first > b.first;\n    });\n\n    long long ans = 0;\n    for(int k = 0; k < N; k++){\n        int idx = X[k].second;\n        int l = query(idx);\n        ans += min(l, k-l);\n        update(idx);\n    }\n    printf("%lld\\n", ans);\n}',
//   "1748":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+5;\nconst ll MOD = 1e9+7;\n\nint N;\nll ans, ds[maxN];\nstruct Operation { int x, idx; } ops[maxN];\n\nvoid update(int idx, ll val){\n    for(int i = idx; i < maxN; i += -i&i)\n        ds[i] = (ds[i] + val) % MOD;\n}\n\nll query(int idx){\n    ll sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum = (sum + ds[i]) % MOD;\n    return sum;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0, x; i < N; i++){\n        scanf("%d", &x);\n        ops[i] = {x, i+1};\n    }\n    sort(ops, ops+N, [](Operation A, Operation B){\n        return A.x == B.x ? B.idx < A.idx : A.x < B.x;\n    });\n\n    for(int i = 0; i < N; i++){\n        int idx = ops[i].idx;\n        ll amnt = query(idx)+1;\n        ans = (ans + amnt) % MOD;\n        update(idx, amnt);\n    }\n    printf("%lld\\n", ans);\n}',
//   "1749":
//     '#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nconst int maxN = 2e5;\n\nint N, p, x[maxN+1];\ntree<int, null_type, less<int>, rb_tree_tag,\ntree_order_statistics_node_update> T;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &x[i]);\n        T.insert(i);\n    }\n\n    for(int i = 0; i < N; i++){\n        scanf("%d", &p);\n        printf("%d%c", x[*T.find_by_order(p-1)], (" \\n")[i==N-1]);\n        T.erase(T.find_by_order(p-1));\n    }\n}\n',
//   "1750":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\nconst int logK = 31;\n\nint N, Q, x, k, p[maxN][logK];\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &p[i][0]);\n    for(int j = 1; j < logK; j++)\n        for(int i = 1; i <= N; i++)\n            p[i][j] = p[p[i][j-1]][j-1];\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &x, &k);\n        for(int i = 0; i < logK; i++)\n            if(k&(1<<i))\n                x = p[x][i];\n        printf("%d\\n", x);\n    }\n}\n',
//   "1751":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nbool vis[maxN];\nint N, t[maxN], in[maxN], ans[maxN];\nvector<int> G[maxN];\nqueue<int> Q;\n\nvoid dfs1(int u){\n    for(int v : G[u]){\n        if(!vis[v]){\n            ans[v] = ans[u]+1;\n            vis[v] = true;\n            dfs1(v);\n        }\n    }\n}\n\nvoid dfs2(int u, int d = 1){\n    vis[u] = true;\n    int v = t[u];\n    if(vis[v]){\n        ans[u] = d;\n    } else {\n        dfs2(v, d+1);\n        ans[u] = ans[v];\n    }\n    dfs1(u);\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &t[i]);\n        G[t[i]].push_back(i);\n        in[t[i]]++;\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(in[i] == 0)\n            Q.push(i);\n\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        int v = t[u];\n        in[v]--;\n        if(in[v] == 0)\n            Q.push(v);\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(in[i] && !vis[i])\n            dfs2(i);\n\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", ans[i], (" \\n")[i==N]);\n}',
//   "1752":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1, logN = 20;\nconst int INF = 0x3f3f3f3f;\n\nint N, D, ct[maxN], sz[maxN], best[maxN];\nint timer, p[maxN][logN], d[maxN], in[maxN], out[maxN];\nbool vis[maxN];\nvector<int> G[maxN];\n\nvoid dfs(int u = 1, int par = 1){\n    in[u] = ++timer;\n    d[u] = d[par]+1;\n    p[u][0] = par;\n    for(int i = 1; i < logN; i++)\n        p[u][i] = p[p[u][i-1]][i-1];\n    for(int v : G[u])\n        if(v != par)\n            dfs(v, u);\n    out[u] = ++timer;\n}\n\nbool ancestor(int u, int v){\n    return in[u] <= in[v] && out[u] >= out[v];\n}\n\nint lca(int u, int v){\n    if(ancestor(u, v))  return u;\n    if(ancestor(v, u))  return v;\n    for(int i = logN-1; i >= 0; i--)\n        if(!ancestor(p[u][i], v))\n            u = p[u][i];\n    return p[u][0];\n}\n\nint dist(int u, int v){\n    return d[u] + d[v] - 2*d[lca(u, v)];\n}\n\nint find_size(int u, int p = -1){\n    if(vis[u])  return 0;\n\n    sz[u] = 1;\n    for(int v : G[u])\n        if(v != p)\n            sz[u] += find_size(v, u);\n\n    return sz[u];\n}\n\nint find_centroid(int u, int p, int n){\n    for(int v : G[u])\n        if(v != p)\n            if(!vis[v] && sz[v] > n/2)\n                return find_centroid(v, u, n);\n\n    return u;\n}\n\nvoid build_centroid_tree(int u = 1, int p = -1){\n    find_size(u);\n\n    int c = find_centroid(u, -1, sz[u]);\n    vis[c] = true;\n    ct[c] = p;\n\n    for(int v : G[c])\n        if(!vis[v])\n            build_centroid_tree(v, c);\n}\n\nvoid update(int u){\n    best[u] = 0;\n    int v = u;\n    while(ct[v] != -1){\n        v = ct[v];\n        best[v] = min(best[v], dist(u, v));\n    }\n}\n\nint query(int u){\n    int ans = best[u];\n    int v = u;\n    while(ct[v] != -1){\n        v = ct[v];\n        ans = min(ans, best[v] + dist(u, v));\n    }\n    return ans;\n}\n\nint main(){\n    scanf("%d %d", &N, &D);\n    for(int i = 0, a, b; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs();\n    build_centroid_tree();\n    fill(best+1, best+N+1, INF);\n\n    vector<int> order(N);\n    for(int i = 0; i < N; i++)\n        order[i] = i+1;\n    sort(order.begin(), order.end(), [](int a, int b){\n        return d[a] == d[b] ? a < b : d[a] > d[b];\n    });\n\n    vector<int> ans;\n    for(int u : order){\n        int dist_to_office = query(u);\n        if(dist_to_office >= D){\n            ans.push_back(u);\n            update(u);\n        }\n    }\n\n    sort(ans.begin(), ans.end());\n    int K = (int) ans.size();\n    printf("%d\\n", K);\n    for(int i = 0; i < K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K-1]);\n}',
//   "1753":
//     "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e6+5, numP = 3;\nconst ll MOD = 1e9+7;\nconst ll prime[numP] = {31, 37, 43};\n\nint N, M, cnt;\nll sh[numP], th[numP], pw[numP][maxN];\nchar S[maxN], T[maxN];\n\nbool hashes_equal(){\n    for(int p = 0; p < numP; p++)\n        if(sh[p] != th[p])\n            return false;\n    return true;\n}\n\nint main(){\n    scanf(\"%s %s\", S, T);\n    N = (int) strlen(S); M = (int) strlen(T);\n\n    if(M > N){\n        printf(\"0\\n\");\n        return 0;\n    }\n\n    for(int p = 0; p < numP; p++){\n        pw[p][0] = 1;\n        for(int i = 1; i < maxN; i++)\n            pw[p][i] = (pw[p][i-1] * prime[p]) % MOD;\n    }\n\n    for(int i = 0; i < M; i++){\n        for(int p = 0; p < numP; p++){\n            sh[p] = (sh[p] + (S[i] - 'a' + 1) * pw[p][M-i-1]) % MOD;\n            th[p] = (th[p] + (T[i] - 'a' + 1) * pw[p][M-i-1]) % MOD;\n        }\n    }\n\n    if(hashes_equal())  cnt++;\n    for(int i = M; i < N; i++){\n        for(int p = 0; p < numP; p++){\n            sh[p] = (sh[p] * prime[p] - (S[i-M] - 'a' + 1) * pw[p][M]) % MOD;\n            sh[p] = (sh[p] + (S[i] - 'a' + 1) + MOD) % MOD;\n        }\n        if(hashes_equal())  cnt++;\n    }\n    printf(\"%d\\n\", cnt);\n}\n",
//   "1754":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T, a, b;\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        scanf("%d %d", &a, &b);\n        printf(((a+b)%3 != 0 || a > 2*b || b > 2*a) ? "NO\\n" : "YES\\n");\n    }\n}\n',
//   "1755":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar S[1000001];\nint N, odd, freq[26];\n\nint main(){\n    scanf("%s", S);\n    N = (int) strlen(S);\n    for(int i = 0; i < N; i++)\n        freq[(int) (S[i]-\'A\')]++;\n\n    odd = -1;\n    for(int i = 0; i < 26; i++){\n        if(freq[i]&1){\n            if(odd != -1){\n                printf("NO SOLUTION\\n");\n                return 0;\n            } else {\n                odd = i;\n            }\n        }\n    }\n\n    for(int i = 0; i < 26; i++)\n        for(int j = 0; j < freq[i]/2; j++)\n            printf("%c", (char) (i+\'A\'));\n    if(odd != -1)\n        printf("%c", (char) (odd+\'A\'));\n    for(int i = 25; i >= 0; i--)\n        for(int j = 0; j < freq[i]/2; j++)\n            printf("%c", (char) (i+\'A\'));\n}\n',
//   "1756":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nint N, M, a, b;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        printf("%d %d\\n", min(a, b), max(a, b));\n    }\n}\n',
//   "1757":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5;\n\nint N, M, a, b, idx, in[maxN], ans[maxN];\nvector<int> G[maxN];\npriority_queue<int> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[b].push_back(a);\n        in[a]++;\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(in[i] == 0)\n            Q.push(i);\n\n    idx = N;\n    while(!Q.empty()){\n        int u = Q.top(); Q.pop();\n        ans[idx--] = u;\n        for(int v : G[u]){\n            in[v]--;\n            if(in[v] == 0)\n                Q.push(v);\n        }\n    }\n\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", ans[i], (" \\n")[i==N]);\n}\n',
//   "2064":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nll N, numerator, denominator;\n\nll fastpow(ll a, ll b){\n    ll res = 1;\n    while(b > 0){\n        if(b&1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll inverse(ll a){\n    return fastpow(a, MOD-2);\n}\n\nint main(){\n    scanf("%lld", &N);\n    if(N&1) printf("0\\n");\n    else {\n        numerator = 1;\n        for(int i = 1; i <= N; i++)\n            numerator = (numerator * i) % MOD;\n\n        denominator = 1;\n        for(int i = 1; i <= N/2; i++)\n            denominator = (denominator * i) % MOD;\n        denominator = (denominator * denominator) % MOD;\n        denominator = (denominator * (N/2+1)) % MOD;\n\n        printf("%lld\\n", (numerator*inverse(denominator))%MOD);\n    }\n}\n',
//   "2072":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nuniform_int_distribution<int> dist(1, (int) 2e9);\n\nstruct Node {\n    char ch;\n    int prior, sz;\n    Node *l, *r;\n\n    Node(){}\n    Node(char c, int p){\n        prior = p;\n        ch = c;\n        sz = 1;\n        l = r = nullptr;\n    }\n};\n\nint N, M, a, b;\nchar S[maxN];\nNode *root;\n\nint sz(Node *t){ return t ? t->sz : 0; }\n\nvoid pull(Node *t){\n    if(!t)  return;\n    t->sz = sz(t->l) + sz(t->r) + 1;\n}\n\nvoid push(Node *t){\n    if(!t)  return;\n}\n\nNode* merge(Node *x, Node *y){\n    if(!x || !y)    return x ? x : y;\n\n    push(x); push(y);\n    if(x->prior < y->prior){\n        x->r = merge(x->r, y);\n        pull(x);\n        return x;\n    } else {\n        y->l = merge(x, y->l);\n        pull(y);\n        return y;\n    }\n}\n\npair<Node*,Node*> split(Node *x, int k){\n    if(!x)  return {nullptr, nullptr};\n\n    pair<Node*,Node*> y = {nullptr, nullptr};\n    push(x);\n    if(k <= sz(x->l)){\n        y = split(x->l, k);\n        x->l = y.second;\n        pull(x);\n        y.second = x;\n    } else {\n        y = split(x->r, k-sz(x->l)-1);\n        x->r = y.first;\n        pull(x);\n        y.first = x;\n    }\n    return y;\n}\n\nvoid heapify(Node *t){\n    if(!t)  return;\n\n    Node *mx = t;\n    if(t->l && t->l->prior > mx->prior) mx = t->l;\n    if(t->r && t->r->prior > mx->prior) mx = t->r;\n    if(mx != t){\n        swap(t->prior, mx->prior);\n        heapify(mx);\n    }\n}\n\nNode* build(int x, int k){\n    if(k == 0)  return nullptr;\n\n    int mid = k/2;\n    Node *t = new Node(S[x+mid], dist(rng));\n    t->l = build(x, mid);\n    t->r = build(x+mid+1, k-mid-1);\n    heapify(t);\n    pull(t);\n    return t;\n}\n\nvoid cut(int x, int k){\n    pair<Node*,Node*> y, z;\n    y = split(root, x-1);\n    z = split(y.second, k);\n    y.second = merge(z.second, z.first);\n    root = merge(y.first, y.second);\n}\n\nvoid print(Node *t){\n    if(!t)  return;\n    push(t);\n    print(t->l);\n    printf("%c", t->ch);\n    print(t->r);\n}\n\nint main(){\n    scanf("%d %d %s", &N, &M, S);\n    root = build(0, N);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        int len = (b-a+1);\n        cut(a, len);\n    }\n    print(root);\n}\n',
//   "2073":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nuniform_int_distribution<int> dist(1, (int) 2e9);\n\nstruct Node {\n    bool rev;\n    char ch;\n    int prior, sz;\n    Node *l, *r;\n\n    Node(){}\n    Node(char c, int p){\n        prior = p;\n        ch = c;\n        sz = 1;\n        l = r = nullptr;\n    }\n};\n\nint N, M, a, b;\nchar S[maxN];\nNode *root;\n\nint sz(Node *t){ return t ? t->sz : 0; }\n\nvoid flip(Node *t){\n    if(!t)  return;\n    t->rev ^= true;\n}\n\nvoid pull(Node *t){\n    if(!t)  return;\n    t->sz = sz(t->l) + sz(t->r) + 1;\n}\n\nvoid push(Node *t){\n    if(!t)  return;\n    if(t->rev){\n        swap(t->l, t->r);\n        flip(t->l); flip(t->r);\n        t->rev = false;\n    }\n}\n\nNode* merge(Node *x, Node *y){\n    if(!x || !y)    return x ? x : y;\n\n    push(x); push(y);\n    if(x->prior < y->prior){\n        x->r = merge(x->r, y);\n        pull(x);\n        return x;\n    } else {\n        y->l = merge(x, y->l);\n        pull(y);\n        return y;\n    }\n}\n\npair<Node*,Node*> split(Node *x, int k){\n    if(!x)  return {nullptr, nullptr};\n\n    pair<Node*,Node*> y = {nullptr, nullptr};\n    push(x);\n    if(k <= sz(x->l)){\n        y = split(x->l, k);\n        x->l = y.second;\n        pull(x);\n        y.second = x;\n    } else {\n        y = split(x->r, k-sz(x->l)-1);\n        x->r = y.first;\n        pull(x);\n        y.first = x;\n    }\n    return y;\n}\n\nvoid heapify(Node *t){\n    if(!t)  return;\n\n    Node *mx = t;\n    if(t->l && t->l->prior > mx->prior) mx = t->l;\n    if(t->r && t->r->prior > mx->prior) mx = t->r;\n    if(mx != t){\n        swap(t->prior, mx->prior);\n        heapify(mx);\n    }\n}\n\nNode* build(int x, int k){\n    if(k == 0)  return nullptr;\n\n    int mid = k/2;\n    Node *t = new Node(S[x+mid], dist(rng));\n    t->l = build(x, mid);\n    t->r = build(x+mid+1, k-mid-1);\n    heapify(t);\n    pull(t);\n    return t;\n}\n\nvoid reverse(int x, int k){\n    pair<Node*,Node*> y, z;\n    y = split(root, x-1);\n    z = split(y.second, k);\n    flip(z.first);\n    y.second = merge(z.first, z.second);\n    root = merge(y.first, y.second);\n}\n\nvoid print(Node *t){\n    if(!t)  return;\n    push(t);\n    print(t->l);\n    printf("%c", t->ch);\n    print(t->r);\n}\n\nint main(){\n    scanf("%d %d %s", &N, &M, S);\n    root = build(0, N);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        int len = (b-a+1);\n        reverse(a, len);\n    }\n    print(root);\n}\n',
//   "2074":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nuniform_int_distribution<int> dist(1, (int) 2e9);\n\nstruct Node {\n    bool rev;\n    int prior, sz;\n    ll val, sum;\n    Node *l, *r;\n\n    Node(){}\n    Node(ll v, int p){\n        prior = p;\n        sum = val = v;\n        sz = 1;\n        l = r = nullptr;\n    }\n};\n\nint N, M, type, a, b;\nll val[maxN];\nNode *root;\n\nint sz(Node *t){ return t ? t->sz : 0; }\nll sum(Node *t){ return t ? t->sum : 0; }\n\nvoid flip(Node *t){\n    if(!t)  return;\n    t->rev ^= true;\n}\n\nvoid pull(Node *t){\n    if(!t)  return;\n    t->sz = sz(t->l) + sz(t->r) + 1;\n    t->sum = sum(t->l) + sum(t->r) + t->val;\n}\n\nvoid push(Node *t){\n    if(!t)  return;\n    if(t->rev){\n        swap(t->l, t->r);\n        flip(t->l); flip(t->r);\n        t->rev = false;\n    }\n}\n\nNode* merge(Node *x, Node *y){\n    if(!x || !y)    return x ? x : y;\n\n    push(x); push(y);\n    if(x->prior < y->prior){\n        x->r = merge(x->r, y);\n        pull(x);\n        return x;\n    } else {\n        y->l = merge(x, y->l);\n        pull(y);\n        return y;\n    }\n}\n\npair<Node*,Node*> split(Node *x, int k){\n    if(!x)  return {nullptr, nullptr};\n\n    pair<Node*,Node*> y = {nullptr, nullptr};\n    push(x);\n    if(k <= sz(x->l)){\n        y = split(x->l, k);\n        x->l = y.second;\n        pull(x);\n        y.second = x;\n    } else {\n        y = split(x->r, k-sz(x->l)-1);\n        x->r = y.first;\n        pull(x);\n        y.first = x;\n    }\n    return y;\n}\n\nvoid heapify(Node *t){\n    if(!t)  return;\n\n    Node *mx = t;\n    if(t->l && t->l->prior > mx->prior) mx = t->l;\n    if(t->r && t->r->prior > mx->prior) mx = t->r;\n    if(mx != t){\n        swap(t->prior, mx->prior);\n        heapify(mx);\n    }\n}\n\nNode* build(int x, int k){\n    if(k == 0)  return nullptr;\n\n    int mid = k/2;\n    Node *t = new Node(val[x+mid], dist(rng));\n    t->l = build(x, mid);\n    t->r = build(x+mid+1, k-mid-1);\n    heapify(t);\n    pull(t);\n    return t;\n}\n\nvoid reverse(int x, int k){\n    pair<Node*,Node*> y, z;\n    y = split(root, x-1);\n    z = split(y.second, k);\n    flip(z.first);\n    y.second = merge(z.first, z.second);\n    root = merge(y.first, y.second);\n}\n\nll getSum(int x, int k){\n    pair<Node*,Node*> y, z;\n    y = split(root, x-1);\n    z = split(y.second, k);\n    ll ans = sum(z.first);\n    y.second = merge(z.first, z.second);\n    root = merge(y.first, y.second);\n    return ans;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < N; i++)\n        scanf("%lld", &val[i]);\n    root = build(0, N);\n\n    for(int i = 0; i < M; i++){\n        scanf("%d %d %d", &type, &a, &b);\n        int len = (b-a+1);\n        if(type == 1)\n            reverse(a, len);\n        else if(type == 2)\n            printf("%lld\\n", getSum(a, len));\n    }\n}\n',
//   "2075":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nuniform_int_distribution<int> dist(1, (int) 2e9);\n\nstruct Node {\n    bool rev;\n    int value, prior, sz;\n    Node *p, *l, *r;\n\n    Node(){}\n    Node(int val, int pri){\n        prior = pri;\n        value = val;\n        sz = 1;\n        p = l = r = nullptr;\n    }\n};\n\nint N, X[maxN];\nNode *root, *ndptr[maxN];\n\nint sz(Node *t){    return t ? t->sz : 0;       }\nint val(Node *t){   return t ? t->value : -1;   }\n\nvoid flip(Node *t){\n    if(!t)\treturn;\n    t->rev ^= true;\n}\n\nvoid pull(Node *t){\n    if(!t)\treturn;\n    if(t->l)    t->l->p = t;\n    if(t->r)    t->r->p = t;\n    t->sz = sz(t->l) + sz(t->r) + 1;\n}\n\nvoid push(Node *t){\n    if(!t)\treturn;\n    if(t->rev){\n        swap(t->l, t->r);\n        flip(t->l); flip(t->r);\n        t->rev = false;\n    }\n}\n\nNode* merge(Node *x, Node *y){\n    if(!x || !y)\treturn x ? x : y;\n\n    push(x); push(y);\n    if(x->prior < y->prior){\n        x->r = merge(x->r, y);\n        pull(x);\n        return x;\n    } else {\n        y->l = merge(x, y->l);\n        pull(y);\n        return y;\n    }\n}\n\npair<Node*,Node*> split(Node *x, int k){\n    if(!x)\treturn {nullptr, nullptr};\n\n    pair<Node*,Node*> y = {nullptr, nullptr};\n    push(x);\n    if(k <= sz(x->l)){\n        y = split(x->l, k);\n        x->l = y.second;\n        pull(x);\n        y.second = x;\n    } else {\n        y = split(x->r, k-sz(x->l)-1);\n        x->r = y.first;\n        pull(x);\n        y.first = x;\n    }\n    return y;\n}\n\nvoid heapify(Node *t){\n    if(!t)\treturn;\n\n    Node *mx = t;\n    if(t->l && t->l->prior > mx->prior)\tmx = t->l;\n    if(t->r && t->r->prior > mx->prior)\tmx = t->r;\n    if(mx != t){\n        swap(t->prior, mx->prior);\n        heapify(mx);\n    }\n}\n\nNode* build(int x, int k){\n    if(k == 0)\treturn nullptr;\n\n    int mid = k/2;\n    Node *t = new Node(X[x+mid], dist(rng));\n    ndptr[X[x+mid]] = t;\n    t->l = build(x, mid);\n    t->r = build(x+mid+1, k-mid-1);\n    heapify(t);\n    pull(t);\n    return t;\n}\n\nvoid reverse(int x, int k){\n    pair<Node*,Node*> y, z;\n    y = split(root, x-1);\n    z = split(y.second, k);\n    flip(z.first);\n    y.second = merge(z.first, z.second);\n    root = merge(y.first, y.second);\n    root->p = nullptr;\n}\n\nint orderOf(int v){\n    Node* t = ndptr[v];\n\n    vector<Node*> walk;\n    while(t){\n        walk.push_back(t);\n        t = t->p;\n    }\n    reverse(walk.begin(), walk.end());\n    for(Node* nd : walk){\n        push(nd);\n        pull(nd);\n    }\n\n    t = ndptr[v];\n    int idx = sz(t->l);\n    while(t){\n        if(t->p && t == t->p->r)\n            idx += sz(t->p->l) + 1;\n        t = t->p;\n    }\n    return idx;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &X[i]);\n\n    root = build(0, N);\n\n    printf("%d\\n", N);\n    for(int l = 1; l <= N; l++){\n        int r = orderOf(l)+1;\n        reverse(l, r-l+1);\n        printf("%d %d\\n", l, r);\n    }\n}',
//   "2076":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 1e5+1;\n\nint N, M, timer, tin[maxN], low[maxN];\nbool vis[maxN];\nvector<int> G[maxN];\nvector<pii> bridges;\n\nvoid dfs(int u = 1, int p = 0){\n    vis[u] = true;\n    tin[u] = low[u] = ++timer;\n    for(int v : G[u]){\n        if(v != p){\n            if(vis[v])  low[u] = min(low[u], tin[v]);\n            else {\n                dfs(v, u);\n                low[u] = min(low[u], low[v]);\n                if(low[v] > tin[u])\n                    bridges.push_back({u, v});\n            }\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs();\n\n    printf("%d\\n", (int) bridges.size());\n    for(pii P : bridges)\n        printf("%d %d\\n", P.first, P.second);\n}\n',
//   "2077":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 1e5+1;\n\nbool vis[maxN], is_artic[maxN];\nint N, M, timer, tin[maxN], low[maxN];\nvector<int> ans, G[maxN];\n\nvoid dfs(int u = 1, int p = -1){\n    vis[u] = true;\n    tin[u] = low[u] = ++timer;\n\n    int children = 0;\n    for(int v : G[u]){\n        if(v != p){\n            if(vis[v])  low[u] = min(low[u], tin[v]);\n            else {\n                dfs(v, u);\n                low[u] = min(low[u], low[v]);\n                if(low[v] >= tin[u] && p != -1){\n                    if(!is_artic[u]){\n                        ans.push_back(u);\n                        is_artic[u] = true;\n                    }\n                }\n                children++;\n            }\n        }\n    }\n\n    if(p == -1 && children > 1){\n        if(!is_artic[u]){\n            ans.push_back(u);\n            is_artic[u] = true;\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs();\n\n    int K = (int) ans.size();\n    printf("%d\\n", K);\n    for(int i = 0; i < K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K-1]);\n}',
//   "2078":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\nconst int MOD = 1e9+7;\n\nint N, M, ans, ds[maxN];\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    fill(ds+1, ds+N+1, -1);\n    ans = 1;\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        if(!merge(a, b))\n            ans = (2 * ans) % MOD;\n    }\n    printf("%d\\n", ans);\n}',
//   "2079":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\n\nint N, a, b, p[maxN], sz[maxN];\nvector<int> G[maxN];\n\nvoid dfs(int u = 1){\n    sz[u] = 1;\n    for(int v : G[u]){\n        if(v != p[u]){\n            p[v] = u;\n            dfs(v);\n            sz[u] += sz[v];\n        }\n    }\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs();\n\n    for(int i = 1; i <= N; i++){\n        bool centroid = true;\n\n        if(p[i] != 0 && N-sz[i] > N/2)\n            centroid = false;\n\n        for(int v : G[i])\n            if(v != p[i] && sz[v] > N/2)\n                centroid = false;\n\n        if(centroid){\n            printf("%d\\n", i);\n            return 0;\n        }\n    }\n}\n',
//   "2084":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\nconst int SIZE = 4e6;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nstruct Line {\n    ll m, b;\n    ll operator()(const ll x) const {\n        return m * x + b;\n    }\n} seg[SIZE];\n\nint N, lo[SIZE], hi[SIZE];\nll X, s[maxN], f[maxN];\n\nvoid build(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    seg[i] = {0, INF};\n    if(l == r)  return;\n    int m = (l+r)/2;\n    build(2*i, l, m);\n    build(2*i+1, m+1, r);\n}\n\nvoid insert(int i, Line L){\n    int l = lo[i], r = hi[i];\n    if(l == r){\n        if(L(l) < seg[i](l))\n            seg[i] = L;\n        return;\n    }\n\n    int m = (l+r)/2;\n    if(seg[i].m < L.m)  swap(seg[i], L);\n    if(seg[i](m) > L(m)){\n        swap(seg[i], L);\n        insert(2*i, L);\n    } else insert(2*i+1, L);\n}\n\nll query(int i, ll x){\n    int l = lo[i], r = hi[i];\n    if(l == r)  return seg[i](x);\n\n    int m = (l+r)/2;\n    if(x < m)   return min(seg[i](x), query(2*i, x));\n    else        return min(seg[i](x), query(2*i+1, x));\n}\n\nint main(){\n    scanf("%d %lld", &N, &X);\n    for(int i = 0; i < N; i++)  scanf("%lld", &s[i]);\n    for(int i = 0; i < N; i++)  scanf("%lld", &f[i]);\n\n    build(1, 1, 1e6);\n    insert(1, {X, 0});\n    for(int i = 0; i < N-1; i++){\n        ll best = query(1, s[i]);\n        insert(1, {f[i], best});\n    }\n    printf("%lld\\n", query(1, s[N-1]));\n}',
//   "2085":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\nconst int SIZE = 4e6;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nstruct Line {\n    ll m, b;\n    ll operator()(const ll x) const {\n        return m * x + b;\n    }\n} seg[SIZE];\n\nint N, lo[SIZE], hi[SIZE];\nll X, s[maxN], f[maxN];\n\nvoid build(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    seg[i] = {0, INF};\n    if(l == r)  return;\n    int m = (l+r)/2;\n    build(2*i, l, m);\n    build(2*i+1, m+1, r);\n}\n\nvoid insert(int i, Line L){\n    int l = lo[i], r = hi[i];\n    if(l == r){\n        if(L(l) < seg[i](l))\n            seg[i] = L;\n        return;\n    }\n\n    int m = (l+r)/2;\n    if(seg[i].m < L.m)  swap(seg[i], L);\n    if(seg[i](m) > L(m)){\n        swap(seg[i], L);\n        insert(2*i, L);\n    } else insert(2*i+1, L);\n}\n\nll query(int i, ll x){\n    int l = lo[i], r = hi[i];\n    if(l == r)  return seg[i](x);\n\n    int m = (l+r)/2;\n    if(x < m)   return min(seg[i](x), query(2*i, x));\n    else        return min(seg[i](x), query(2*i+1, x));\n}\n\nint main(){\n    scanf("%d %lld", &N, &X);\n    for(int i = 0; i < N; i++)  scanf("%lld", &s[i]);\n    for(int i = 0; i < N; i++)  scanf("%lld", &f[i]);\n\n    build(1, 1, 1e6);\n    insert(1, {X, 0});\n    for(int i = 0; i < N-1; i++){\n        ll best = query(1, s[i]);\n        insert(1, {f[i], best});\n    }\n    printf("%lld\\n", query(1, s[N-1]));\n}',
//   "2086":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst int maxN = 3005;\n\nstruct Line {\n    ll m, b, c;\n    ll operator()(ll x){\n        return m * x + b;\n    }\n};\n\nstruct CHT {\n    Line dq[2*maxN];\n    int fptr, bptr;\n\n    void clear(){\n        dq[0] = {0, 0, 0};\n        fptr = 0; bptr = 1;\n    }\n\n    bool pop_back(Line& L, Line& L1, Line& L2){\n        ll v1 = (L.b - L2.b) * (L2.m - L1.m);\n        ll v2 = (L2.m - L.m) * (L1.b - L2.b);\n        return (v1 == v2 ? L.c > L1.c : v1 < v2);\n    }\n\n    bool pop_front(Line& L1, Line& L2, ll x){\n        ll v1 = L1(x);\n        ll v2 = L2(x);\n        return (v1 == v2 ? L1.c < L2.c : v1 > v2);\n    }\n\n    void insert(Line L){\n        while(bptr-fptr >= 2 && pop_back(L, dq[bptr-1], dq[bptr-2]))    bptr--;\n        dq[bptr++] = L;\n    }\n\n    pll query(ll x){\n        while(bptr-fptr >= 2 && pop_front(dq[fptr], dq[fptr+1], x))     fptr++;\n        return {dq[fptr](x), dq[fptr].c};\n    }\n};\n\nCHT cht;\nint N, K, cnt[maxN];\nll pre[maxN], dp[maxN];\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &pre[i]);\n        pre[i] += pre[i-1];\n        dp[i] = pre[i]*pre[i];\n    }\n\n    for(int k = 1; k <= K-1; k++){\n        cht.clear();\n        for(int i = 1; i <= k; i++)\n            cht.insert({-2*pre[i], dp[i]+pre[i]*pre[i], cnt[i]});\n        for(int i = k+1; i <= N; i++){\n            pll P = cht.query(pre[i]);\n            cht.insert({-2*pre[i], dp[i]+pre[i]*pre[i], cnt[i]});\n            dp[i] = pre[i]*pre[i] + P.first;\n            cnt[i] = P.second + 1;\n        }\n    }\n\n    printf("%lld\\n", dp[N]);\n}',
//   "2087":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 3001;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nint N, K;\nll best, p[3][maxN], dp[maxN][maxN];\n\nll travel(int d, int a, int b){\n    return (p[d][b] - p[d][a-1]) - (p[0][b] - p[0][a-1]) * (d == 1 ? a : N-b+1);\n}\n\nll C(int a, int b){\n    int m = (a+b)/2;\n    return travel(1, a, m) + travel(2, m+1, b);\n}\n\nvoid solve(int k, int a = 1, int b = N, int optl = 1, int optr = N){\n    if(a > b)   return;\n    int m = (a+b)/2;\n    int opt = -1;\n    dp[k][m] = INF;\n    for(int i = optl; i <= m; i++){\n        if(dp[k-1][i] + C(i, m) < dp[k][m]){\n            dp[k][m] = dp[k-1][i] + C(i, m);\n            opt = i;\n        }\n    }\n    solve(k, a, m-1, optl, opt);\n    solve(k, m+1, b, opt, optr);\n}\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 1; i <= N; i++){\n        ll x;\n        scanf("%lld", &x);\n        p[0][i] = p[0][i-1] + x;\n        p[1][i] = p[1][i-1] + i * x;\n        p[2][i] = p[2][i-1] + (N-i+1) * x;\n    }\n\n    for(int i = 1; i <= N; i++)\n        dp[1][i] = travel(2, 1, i);\n    for(int k = 2; k <= K; k++)\n        solve(k);\n\n    best = INF;\n    for(int i = 1; i <= N; i++)\n        best = min(best, dp[K][i] + travel(1, i, N));\n    printf("%lld\\n", best);\n}',
//   "2088":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int maxN = 5005;\n\nint N, split[maxN][maxN];\nll pre[maxN], dp[maxN][maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &pre[i]);\n        pre[i] += pre[i-1];\n    }\n\n    for(int len = 0; len <= N; len++){\n        for(int l = 0; l+len <= N; l++){\n            int r = l+len;\n            if(len < 2){\n                dp[l][r] = 0;\n                split[l][r] = l;\n                continue;\n            }\n\n            dp[l][r] = INF;\n            for(int m = split[l][r-1]; m <= split[l+1][r]; m++){\n                ll possible = dp[l][m] + dp[m][r] + pre[r] - pre[l];\n                if(possible < dp[l][r]){\n                    dp[l][r] = possible;\n                    split[l][r] = m;\n                }\n            }\n        }\n    }\n\n    printf("%lld\\n", dp[0][N]);\n}',
//   "2101":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 4e5+1;\n\nint N, M, Q, x, y, root, idcounter;\n\nstruct Node {\n    bool rev = false;\n    Node *c[2] = {nullptr, nullptr}, *p = nullptr;\n    int val, mx, id = ++idcounter;\n\n    Node(int v){\n        val = mx = v;\n    }\n\n    void push(){\n        if(rev){\n            swap(c[0], c[1]);\n            if(c[0])    c[0]->rev ^= true;\n            if(c[1])    c[1]->rev ^= true;\n            rev = false;\n        }\n    }\n\n    void pull(){\n        mx = val;\n        for(int i = 0; i < 2; i++)\n            if(c[i])\n                mx = max(mx, c[i]->mx);\n    }\n} *LCT[maxN];\n\nbool notRoot(Node *t){\n    return t->p && (t->p->c[0] == t || t->p->c[1] == t);\n}\n\nvoid rotate(Node *t){\n    Node *p = t->p;\n    bool b = (p->c[0] == t);\n    if((t->p = p->p) && notRoot(p)) t->p->c[(t->p->c[1] == p)] = t;\n    if((p->c[!b]=t->c[b]))          p->c[!b]->p = p;\n    t->c[b] = p;\n    p->p = t;\n    p->pull();\n}\n\n\nvoid splay(Node *t){\n    while(notRoot(t)){\n        Node *p = t->p;\n        p->push();\n        t->push();\n        rotate(t);\n    }\n    t->push();\n    t->pull();\n}\n\nNode* access(Node *t){\n    Node *last = nullptr;\n    for(Node *u = t; u; u = u->p){\n        splay(u);\n        u->c[1] = last;\n        last = u;\n    }\n    splay(t);\n    return last;\n}\n\nvoid evert(Node *t){\n    access(t);\n    t->rev = true;\n}\n\nvoid link(Node *u, Node *v){\n    evert(u);\n    u->p = v;\n}\n\nvoid cut(Node *u, Node *v){\n    evert(u);\n    access(v);\n    if(v->c[0]) v->c[0]->p = 0;\n    v->c[0] = 0;\n    v->pull();\n}\n\nNode* path(Node *u, Node *v){\n    evert(u);\n    access(v);\n    return v;\n}\n\nNode* LCA(Node *u, Node *v){\n    evert(LCT[root]);\n    access(u);\n    return access(v);\n}\n\nbool connected(Node *u, Node *v){\n    path(u, v);\n    while(v->c[0])\n        v = v->c[0];\n    return u == v;\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &Q);\n    for(int i = 1; i <= N; i++)\n        LCT[i] = new Node(0);\n    for(int i = 1; i <= M; i++){\n        scanf("%d %d", &x, &y);\n        LCT[N+i] = new Node(i);\n        if(!connected(LCT[x], LCT[y])){\n            link(LCT[x], LCT[N+i]);\n            link(LCT[y], LCT[N+i]);\n        }\n    }\n\n    root = 1;\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &x, &y);\n        if(connected(LCT[x], LCT[y])){\n            Node *p = path(LCT[x], LCT[y]);\n            printf("%d\\n", p->mx);\n        } else printf("-1\\n");\n    }\n}\n',
//   "2102":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    int len, link, cnt, firstpos;\n    map<char,int> nxt;\n} node[2*maxN];\n\nchar S[maxN], T[5*maxN];\nint N, M, K, sz, last;\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nbool query(){\n    int u = 0;\n    for(int i = 0; i < M; i++){\n        char c = T[i];\n        if(!node[u].nxt.count(c))   return false;\n        else                        u = node[u].nxt[c];\n    }\n    return true;\n}\n\nint main(){\n    scanf(" %s %d", S, &K);\n    N = (int) strlen(S);\n    init();\n\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n\n    for(int i =  0; i < K; i++){\n        scanf(" %s", T);\n        M = (int) strlen(T);\n        printf("%s\\n", query() ? "YES" : "NO");\n    }\n}',
//   "2103":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    int len, link, cnt;\n    map<char,int> nxt;\n} node[2*maxN];\n\nchar S[maxN], T[5*maxN];\nint N, M, K, sz, last;\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].cnt = 1;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nvoid update_cnts(){\n    vector<int> states_by_len[sz];\n    for(int i = 0; i < sz; i++)\n        states_by_len[node[i].len].push_back(i);\n    for(int i = sz-1; i >= 0; i--)\n        for(int u : states_by_len[i])\n            if(node[u].link != -1)\n                node[node[u].link].cnt += node[u].cnt;\n}\n\nint query(){\n    int u = 0;\n    for(int i = 0; i < M; i++){\n        char c = T[i];\n        if(!node[u].nxt.count(c))   return 0;\n        else                        u = node[u].nxt[c];\n    }\n    return node[u].cnt;\n}\n\nint main(){\n    scanf(" %s %d", S, &K);\n    N = (int) strlen(S);\n\n    init();\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n    update_cnts();\n\n    for(int i =  0; i < K; i++){\n        scanf(" %s", T);\n        M = (int) strlen(T);\n        printf("%d\\n", query());\n    }\n}',
//   "2104":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    int len, link, cnt, firstpos;\n    map<char,int> nxt;\n} node[2*maxN];\n\nchar S[maxN], T[5*maxN];\nint N, M, K, sz, last;\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].cnt = 1;\n    node[cur].firstpos = node[last].len;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            node[clone].firstpos = node[q].firstpos;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nvoid update_cnts(){\n    vector<int> states_by_len[sz];\n    for(int i = 0; i < sz; i++)\n        states_by_len[node[i].len].push_back(i);\n    for(int i = sz-1; i >= 0; i--)\n        for(int u : states_by_len[i])\n            if(node[u].link != -1)\n                node[node[u].link].cnt += node[u].cnt;\n}\n\nint query_cnt(){\n    int u = 0;\n    for(int i = 0; i < M; i++){\n        char c = T[i];\n        if(!node[u].nxt.count(c))   return 0;\n        else                        u = node[u].nxt[c];\n    }\n    return node[u].cnt;\n}\n\nint query_idx(){\n    int u = 0;\n    for(int i = 0; i < M; i++){\n        char c = T[i];\n        if(!node[u].nxt.count(c))   return -1;\n        else                        u = node[u].nxt[c];\n    }\n    return node[u].firstpos-M+2;\n}\n\nint main(){\n    scanf(" %s %d", S, &K);\n    N = (int) strlen(S);\n\n    init();\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n    update_cnts();\n\n    for(int i =  0; i < K; i++){\n        scanf(" %s", T);\n        M = (int) strlen(T);\n        printf("%d\\n", query_idx());\n    }\n}',
//   "2105":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    ll dp;\n    int len, link;\n    map<char,int> nxt;\n} node[2*maxN];\n\nchar S[maxN];\nint N, sz, last;\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid calc(int u = 0){\n    node[u].dp = 1;\n    for(const auto& [c, v] : node[u].nxt){\n        if(!node[v].dp) calc(v);\n        node[u].dp += node[v].dp;\n    }\n}\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n\n    init();\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n    calc();\n\n    printf("%lld\\n", node[0].dp-1);\n}',
//   "2106":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    int len, link, cnt, firstpos;\n    map<char,int> nxt;\n} node[2*maxN];\n\nchar S[maxN];\nbool vis[2*maxN];\nint N, sz, last, bestidx, bestlen;\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].cnt = 1;\n    node[cur].firstpos = node[last].len;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            node[clone].firstpos = node[q].firstpos;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nvoid update_cnts(){\n    vector<int> states_by_len[sz];\n    for(int i = 0; i < sz; i++)\n        states_by_len[node[i].len].push_back(i);\n    for(int i = sz-1; i >= 0; i--)\n        for(int u : states_by_len[i])\n            if(node[u].link != -1)\n                node[node[u].link].cnt += node[u].cnt;\n}\n\nvoid dfs(int u = 0){\n    vis[u] = true;\n    if(node[u].len > bestlen && node[u].cnt > 1 && u != 0){\n        bestidx = node[u].firstpos - node[u].len + 1;\n        bestlen = node[u].len;\n    }\n    for(const auto& [c, v] : node[u].nxt)\n        if(!vis[v])\n            dfs(v);\n}\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n\n    init();\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n    update_cnts();\n\n    bestlen = -1;\n    dfs();\n\n    if(bestlen == -1)   printf("-1\\n");\n    else {\n        for(int i = 0; i < bestlen; i++)\n            printf("%c", S[bestidx+i]);\n    }\n}',
//   "2107":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6+5;\n\nchar S[maxN];\nint N, z[maxN], pi[maxN];\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n\n    for(int i = 1, l = 0, r = 0; i < N; i++){\n        if(i <= r)  z[i] = min(r-i+1, z[i-l]);\n        while(i+z[i] < N && S[z[i]] == S[i+z[i]])   z[i]++;\n        if(i+z[i]-1 > r)    l = i, r = i+z[i]-1;\n    }\n    for(int i = 0; i < N; i++)\n        printf("%d%c", z[i], (" \\n")[i==N-1]);\n\n    for(int i = 1; i < N; i++){\n        int j = pi[i-1];\n        while(j > 0 && S[i] != S[j])    j = pi[j-1];\n        if(S[i] == S[j])    j++;\n        pi[i] = j;\n    }\n    for(int i = 0; i < N; i++)\n        printf("%d%c", pi[i], (" \\n")[i==N-1]);\n}',
//   "2108":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    ll dp;\n    int len, link;\n    map<char,int> nxt;\n} node[2*maxN];\n\nvector<char> ans;\nchar S[maxN];\nint N, sz, last;\nll K;\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid calc(int u = 0){\n    node[u].dp = 1;\n    for(const auto& [c, v] : node[u].nxt){\n        if(!node[v].dp) calc(v);\n        node[u].dp += node[v].dp;\n    }\n}\n\nvoid dfs(int u, ll k){\n    if(k < 0)   return;\n    for(const auto& [c, v] : node[u].nxt){\n        if(node[v].dp <= k) k -= node[v].dp;\n        else {\n            ans.push_back(c);\n            dfs(v, k-1);\n            return;\n        }\n    }\n}\n\nint main(){\n    scanf(" %s %lld", S, &K);\n    N = (int) strlen(S);\n\n    init();\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n    calc();\n\n    dfs(0, K-1);\n    int M = (int) ans.size();\n    for(int i = 0; i < M; i++)\n        printf("%c", ans[i]);\n    printf("\\n");\n}',
//   "2109":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    ll dp;\n    int len, cnt, link;\n    map<char,int> nxt;\n} node[2*maxN];\n\nvector<char> ans;\nchar S[maxN];\nint N, sz, last;\nll K;\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].cnt = 1;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid update_cnts(){\n    vector<int> states_by_len[sz];\n    for(int i = 0; i < sz; i++)\n        states_by_len[node[i].len].push_back(i);\n    for(int i = sz-1; i >= 0; i--)\n        for(int u : states_by_len[i])\n            if(node[u].link != -1)\n                node[node[u].link].cnt += node[u].cnt;\n}\n\nvoid calc(int u = 0){\n    node[u].dp = node[u].cnt;\n    for(const auto& [c, v] : node[u].nxt){\n        if(!node[v].dp) calc(v);\n        node[u].dp += node[v].dp;\n    }\n}\n\nvoid dfs(int u, ll k){\n    if(k < 0)   return;\n    for(const auto& [c, v] : node[u].nxt){\n        if(node[v].dp <= k) k -= node[v].dp;\n        else {\n            ans.push_back(c);\n            dfs(v, k-node[v].cnt);\n            return;\n        }\n    }\n}\n\nint main(){\n    scanf(" %s %lld", S, &K);\n    N = (int) strlen(S);\n\n    init();\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n    update_cnts();\n    calc();\n\n    dfs(0, K-1);\n    int M = (int) ans.size();\n    for(int i = 0; i < M; i++)\n        printf("%c", ans[i]);\n    printf("\\n");\n}',
//   "2110":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    int len, link;\n    map<char,int> nxt;\n} node[2*maxN];\n\nchar S[maxN];\nbool vis[2*maxN];\nint N, sz, last, dist[2*maxN];\nll ans[maxN];\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nvoid bfs(int s = 0){\n    queue<int> Q;\n    vis[s] = true;\n    dist[s] = 0;\n    Q.push(s);\n    while(!Q.empty()){\n        int u = Q.front();\n        Q.pop();\n        ans[dist[u]]++;\n        ans[node[u].len+1]--;\n        for(const auto& [c, v] : node[u].nxt){\n            if(!vis[v]){\n                dist[v] = dist[u]+1;\n                vis[v] = true;\n                Q.push(v);\n            }\n        }\n    }\n}\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n    init();\n\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n\n    bfs();\n    for(int i = 1; i <= N; i++){\n        ans[i] += ans[i-1];\n        printf("%lld%c", ans[i], (" \\n")[i==N]);\n    }\n}',
//   "2111":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef double ld;\ntypedef complex<ld> cd;\nconst int SIZE = 1<<19;\nconst ld PI = acos(-1);\n\nint N, M, K;\nvector<cd> A(SIZE), B(SIZE);\n\nvoid fft(vector<cd> &a, bool inv){\n    int N = (int) a.size();\n\n    for(int i = 1, j = 0; i < N; i++){\n        int bit = N>>1;\n        for(; j&bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if(i < j)\n            swap(a[i], a[j]);\n    }\n\n    for(int len = 2; len <= N; len <<= 1){\n        ld theta = 2*PI / len * (inv ? -1 : 1);\n        cd wlen(cos(theta), sin(theta));\n        for(int i = 0; i < N; i += len){\n            cd w(1);\n            for(int j = 0; j < len / 2; j++){\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if(inv)\n        for(cd &z : a)\n            z /= N;\n}\n\nint main(){\n    scanf("%d %d %d", &K, &N, &M);\n    for(int i = 0, x; i < N; i++){\n        scanf("%d", &x);\n        A[x] += 1;\n    }\n    for(int i = 0, x; i < M; i++){\n        scanf("%d", &x);\n        B[x] += 1;\n    }\n\n    fft(A, false);\n    fft(B, false);\n    for(int i = 0; i < SIZE; i++)\n        A[i] *= B[i];\n    fft(A, true);\n\n    for(int i = 2; i <= 2*K; i++)\n        printf("%lld%c", llround(A[i].real()), (" \\n")[i==2*K]);\n}',
//   "2112":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef double ld;\ntypedef complex<ld> cd;\nconst int maxN = 2e5+5;\nconst int SIZE = 1<<19;\nconst ld PI = acos(-1);\n\nchar S[maxN];\nvector<cd> A(SIZE), B(SIZE);\n\nvoid fft(vector<cd> &a, bool inv){\n    int N = (int) a.size();\n\n    for(int i = 1, j = 0; i < N; i++){\n        int bit = N>>1;\n        for(; j&bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if(i < j)\n            swap(a[i], a[j]);\n    }\n\n    for(int len = 2; len <= N; len <<= 1){\n        ld theta = 2*PI / len * (inv ? -1 : 1);\n        cd wlen(cos(theta), sin(theta));\n        for(int i = 0; i < N; i += len){\n            cd w(1);\n            for(int j = 0; j < len / 2; j++){\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if(inv)\n        for(cd &z : a)\n            z /= N;\n}\n\nint main(){\n    scanf(" %s", S);\n    int N = (int) strlen(S);\n    for(int i = 0; i < N; i++){\n        if(S[i] == \'1\'){\n            A[i] += 1;\n            B[N-i-1] += 1;\n        }\n    }\n\n    fft(A, false);\n    fft(B, false);\n    for(int i = 0; i < SIZE; i++)\n        A[i] *= B[i];\n    fft(A, true);\n\n    for(int i = N; i < 2*N-1; i++)\n        printf("%lld%c", llround(A[i].real()), (" \\n")[i==2*N-2]);\n}',
//   "2113":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef double ld;\ntypedef complex<ld> cd;\nconst int maxN = 2e5+5;\nconst int SIZE = 1<<19;\nconst ld PI = acos(-1);\n\nint N, M;\nvector<cd> A(SIZE), B(SIZE);\n\nvoid fft(vector<cd> &a, bool inv){\n    int n = (int) a.size();\n\n    for(int i = 1, j = 0; i < n; i++){\n        int bit = n>>1;\n        for(; j&bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if(i < j)\n            swap(a[i], a[j]);\n    }\n\n    for(int len = 2; len <= n; len <<= 1){\n        ld theta = 2*PI / len * (inv ? -1 : 1);\n        cd wlen(cos(theta), sin(theta));\n        for(int i = 0; i < n; i += len){\n            cd w(1);\n            for(int j = 0; j < len / 2; j++){\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if(inv)\n        for(cd &z : a)\n            z /= n;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a; i < N; i++){\n        scanf("%d", &a);\n        A[i] = a;\n    }\n    for(int i = 0, b; i < M; i++){\n        scanf("%d", &b);\n        B[M-i-1] = b;\n    }\n\n    fft(A, false);\n    fft(B, false);\n    for(int i = 0; i < SIZE; i++)\n        A[i] *= B[i];\n    fft(A, true);\n\n    for(int i = 0; i < N+M-1; i++)\n        printf("%lld%c", llround(A[i].real()), (" \\n")[i==N+M-2]);\n}',
//   "2115":
//     "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef complex<ld> cd;\nconst int maxN = 2e5+5;\nconst ld PI = acos(-1);\n\nll ans[maxN];\nchar S[maxN];\n\nvoid fft(vector<cd> &a, bool inv){\n    int N = (int) a.size();\n\n    for(int i = 1, j = 0; i < N; i++){\n        int bit = N>>1;\n        for(; j&bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if(i < j)\n            swap(a[i], a[j]);\n    }\n\n    for(int len = 2; len <= N; len <<= 1){\n        ld theta = 2*PI / len * (inv ? -1 : 1);\n        cd wlen(cos(theta), sin(theta));\n        for(int i = 0; i < N; i += len){\n            cd w(1);\n            for(int j = 0; j < len / 2; j++){\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if(inv)\n        for(cd &z : a)\n            z /= N;\n}\n\nint next_two_pow(int x){\n    return 1<<(32 - __builtin_clz(x));\n}\n\nvoid solve(int l, int r){\n    if(l+1 == r){\n        ans[(int) (S[l] - '0')]++;\n        return;\n    }\n\n    int m = (l+r)/2;\n    int sz = next_two_pow(r-l);\n    vector<cd> A(sz), B(sz);\n    for(int i = m-1, cnt = 0; i >= l; i--){\n        if(S[i] == '1') cnt++;\n        A[cnt] += 1;\n    }\n    for(int i = m, cnt = 0; i < r; i++){\n        if(S[i] == '1') cnt++;\n        B[cnt] += 1;\n    }\n\n    fft(A, false);\n    fft(B, false);\n    for(int i = 0; i < sz; i++)\n        A[i] *= B[i];\n    fft(A, true);\n\n    for(int i = 0; i < sz && i < maxN; i++)\n        ans[i] += llround(A[i].real());\n\n    solve(l, m);\n    solve(m, r);\n}\n\nint main(){\n    scanf(\" %s\", S);\n    int N = (int) strlen(S);\n    solve(0, N);\n    for(int i = 0; i <= N; i++)\n        printf(\"%lld%c\", ans[i], (\" \\n\")[i==N]);\n}",
//   "2121":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 501, maxM = 1001;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nint N, M, K, p[maxN];\nll d[maxN], cap[maxN][maxN], cost[maxN][maxN];\nbool inq[maxN];\nvector<int> G[maxN];\n\nstruct Edge {\n    int u, v;\n    ll r, c;\n} edges[maxM], redges[maxM];\n\nvoid bellman_ford(){\n    fill(inq+1, inq+N+1, false);\n    fill(d+1, d+N+1, INF);\n    fill(p+1, p+N+1, 0);\n\n    queue<int> Q;\n    Q.push(1);\n    d[1] = 0;\n    inq[1] = true;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        inq[u] = false;\n\n        for(int i : G[u]){\n            Edge e = (i < 0 ? redges[-i] : edges[i]);\n            if(e.r > 0 && d[e.v] > d[u] + e.c){\n                d[e.v] = d[u] + e.c;\n                p[e.v] = i;\n                if(!inq[e.v]){\n                    inq[e.v] = true;\n                    Q.push(e.v);\n                }\n            }\n        }\n    }\n}\n\nll minimum_cost_flow(){\n    ll flow = 0, cost = 0;\n    while(flow < K){\n        bellman_ford();\n        if(d[N] == INF) break;\n\n        ll aug = K-flow;\n        int u = N;\n        while(u != 1){\n            Edge e = (p[u] < 0 ? redges[-p[u]] : edges[p[u]]);\n            aug = min(aug, e.r);\n            u = e.u;\n        }\n\n        flow += aug;\n        cost += aug * d[N];\n        u = N;\n        while(u != 1){\n            if(p[u] < 0){\n                redges[-p[u]].r -= aug;\n                edges[-p[u]].r += aug;\n            } else {\n                redges[p[u]].r += aug;\n                edges[p[u]].r -= aug;\n            }\n            u = (p[u] < 0 ? redges[-p[u]].u : edges[p[u]].u);\n        }\n    }\n    return (flow < K ? -1 : cost);\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n    for(int i = 1, u, v, r, c; i <= M; i++){\n        scanf("%d %d %d %d", &u, &v, &r, &c);\n        G[u].push_back(i);\n        G[v].push_back(-i);\n        edges[i] = {u, v, r, c};\n        redges[i] = {v, u, 0, -c};\n    }\n    printf("%lld\\n", minimum_cost_flow());\n}',
//   "2129":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 402, maxM = 40401;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nint N, p[maxN];\nll d[maxN], cap[maxN][maxN], cost[maxN][maxN];\nbool inq[maxN], vis[maxM];\nvector<int> path, G[maxN];\n\nstruct Edge {\n    int u, v;\n    ll r, c;\n} edges[maxM], redges[maxM];\n\nvoid bellman_ford(int start = 0){\n    fill(inq, inq+maxN, false);\n    fill(d, d+maxN, INF);\n    fill(p, p+maxN, 0);\n\n    queue<int> Q;\n    Q.push(start);\n    d[start] = 0;\n    inq[start] = true;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        inq[u] = false;\n\n        for(int i : G[u]){\n            Edge e = (i < 0 ? redges[-i] : edges[i]);\n            if(e.r > 0 && d[e.v] > d[u] + e.c){\n                d[e.v] = d[u] + e.c;\n                p[e.v] = i;\n                if(!inq[e.v]){\n                    inq[e.v] = true;\n                    Q.push(e.v);\n                }\n            }\n        }\n    }\n}\n\nll minimum_cost_flow(){\n    ll flow = 0, cost = 0;\n    while(flow < N){\n        bellman_ford();\n        if(d[2*N+1] == INF) break;\n\n        ll aug = N-flow;\n        int u = 2*N+1;\n        while(u != 0){\n            Edge e = (p[u] < 0 ? redges[-p[u]] : edges[p[u]]);\n            aug = min(aug, e.r);\n            u = e.u;\n        }\n\n        flow += aug;\n        cost += aug * d[2*N+1];\n        u = 2*N+1;\n        while(u != 0){\n            if(p[u] < 0){\n                redges[-p[u]].r -= aug;\n                edges[-p[u]].r += aug;\n            } else {\n                redges[p[u]].r += aug;\n                edges[p[u]].r -= aug;\n            }\n            u = (p[u] < 0 ? redges[-p[u]].u : edges[p[u]].u);\n        }\n    }\n    return (flow < N ? -1 : cost);\n}\n\nvoid dfs(int u = 0){\n    if(u == 2*N+1)  return;\n    if(u != 0)      path.push_back(u);\n    for(int i : G[u]){\n        if(i > 0 && edges[i].r == 0 && !vis[i]){\n            vis[i] = true;\n            dfs(edges[i].v);\n            return;\n        }\n    }\n}\n\nint main(){\n    scanf("%d", &N);\n    int edgeID = 1;\n    for(int u = 1; u <= N; u++){\n        for(int v = N+1, c; v <= 2*N; v++){\n            scanf("%d", &c);\n            G[u].push_back(edgeID);\n            G[v].push_back(-edgeID);\n            edges[edgeID] = {u, v, 1, c};\n            redges[edgeID] = {v, u, 0, -c};\n            edgeID++;\n        }\n    }\n    for(int v = 1; v <= N; v++){\n        G[0].push_back(edgeID);\n        G[v].push_back(-edgeID);\n        edges[edgeID] = {0, v, 1, 0};\n        redges[edgeID] = {v, 0, 0, 0};\n        edgeID++;\n    }\n    for(int u = N+1; u <= 2*N; u++){\n        G[u].push_back(edgeID);\n        G[2*N+1].push_back(-edgeID);\n        edges[edgeID] = {u, 2*N+1, 1, 0};\n        redges[edgeID] = {2*N+1, u, 0, 0};\n        edgeID++;\n    }\n\n    printf("%lld\\n", minimum_cost_flow());\n    for(int i = 0; i < N; i++){\n        path.clear();\n        dfs();\n        printf("%d %d\\n", path[0], path[1]-N);\n    }\n}',
//   "2130":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 501, maxM = 1001;\nconst int INF = 0x3f3f3f3f;\n\nint N, M, K, p[maxN], d[maxN];\nbool inq[maxN], vis[maxM];\nvector<int> path, G[maxN];\n\nstruct Edge {\n    int u, v, r, c;\n} edges[maxM], redges[maxM];\n\nvoid bellman_ford(){\n    fill(inq+1, inq+N+1, false);\n    fill(d+1, d+N+1, INF);\n    fill(p+1, p+N+1, 0);\n\n    queue<int> Q;\n    Q.push(1);\n    d[1] = 0;\n    inq[1] = true;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        inq[u] = false;\n\n        for(int i : G[u]){\n            Edge e = (i < 0 ? redges[-i] : edges[i]);\n            if(e.r > 0 && d[e.v] > d[u] + e.c){\n                d[e.v] = d[u] + e.c;\n                p[e.v] = i;\n                if(!inq[e.v]){\n                    inq[e.v] = true;\n                    Q.push(e.v);\n                }\n            }\n        }\n    }\n}\n\nint minimum_cost_flow(){\n    int flow = 0, cost = 0;\n    while(flow < K){\n        bellman_ford();\n        if(d[N] == INF) break;\n\n        int aug = K-flow;\n        int u = N;\n        while(u != 1){\n            Edge e = (p[u] < 0 ? redges[-p[u]] : edges[p[u]]);\n            aug = min(aug, e.r);\n            u = e.u;\n        }\n\n        flow += aug;\n        cost += aug * d[N];\n        u = N;\n        while(u != 1){\n            if(p[u] < 0){\n                redges[-p[u]].r -= aug;\n                edges[-p[u]].r += aug;\n            } else {\n                redges[p[u]].r += aug;\n                edges[p[u]].r -= aug;\n            }\n            u = (p[u] < 0 ? redges[-p[u]].u : edges[p[u]].u);\n        }\n    }\n    return (flow < K ? -1 : cost);\n}\n\nvoid dfs(int u = 1){\n    path.push_back(u);\n    if(u == N)  return;\n    for(int i : G[u]){\n        if(i > 0 && edges[i].r == 0 && !vis[i]){\n            vis[i] = true;\n            dfs(edges[i].v);\n            return;\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n    for(int i = 1, u, v; i <= M; i++){\n        scanf("%d %d", &u, &v);\n        G[u].push_back(i);\n        G[v].push_back(-i);\n        edges[i] = {u, v, 1, 1};\n        redges[i] = {v, u, 0, -1};\n    }\n\n    int minCoins = minimum_cost_flow();\n    if(minCoins == -1){\n        printf("-1\\n");\n        return 0;\n    }\n\n    printf("%d\\n", minCoins);\n    for(int i = 0; i < K; i++){\n        path.clear();\n        dfs();\n\n        int sz = (int) path.size();\n        printf("%d\\n", sz);\n        for(int j = 0; j < sz; j++)\n            printf("%d%c", path[j], (" \\n")[j==sz-1]);\n    }\n}',
//   "2131":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 105, maxM = 2605;\nconst int INF = 0x3f3f3f3f;\n\nint N, K, rowtot, coltot, edgecnt, p[maxN], d[maxN];\nbool inq[maxN], vis[maxM];\nvector<int> path, G[maxN];\n\nstruct Edge {\n    int u, v, r, c;\n} edges[maxM], redges[maxM];\n\nvoid read_input(){\n    scanf("%d", &N);\n    for(int v = 1, cap; v <= N; v++){\n        scanf("%d", &cap);\n        rowtot += cap;\n        edgecnt++;\n        G[0].push_back(edgecnt);\n        G[v].push_back(-edgecnt);\n        edges[edgecnt] = {0, v, cap, 0};\n        redges[edgecnt] = {v, 0, 0, 0};\n    }\n    for(int u = N+1, cap; u <= 2*N; u++){\n        scanf("%d", &cap);\n        coltot += cap;\n        edgecnt++;\n        G[u].push_back(edgecnt);\n        G[2*N+1].push_back(-edgecnt);\n        edges[edgecnt] = {u, 2*N+1, cap, 0};\n        redges[edgecnt] = {2*N+1, u, 0, 0};\n    }\n    for(int u = 1; u <= N; u++){\n        for(int v = N+1, cost; v <= 2*N; v++){\n            scanf("%d", &cost);\n            edgecnt++;\n            G[u].push_back(edgecnt);\n            G[v].push_back(-edgecnt);\n            edges[edgecnt] = {u, v, 1, -cost};\n            redges[edgecnt] = {v, u, 0, cost};\n        }\n    }\n}\n\nvoid bellman_ford(int s = 0){\n    fill(inq, inq+2*N+2, false);\n    fill(d, d+2*N+2, INF);\n    fill(p, p+2*N+2, 0);\n\n    queue<int> Q;\n    Q.push(s);\n    d[s] = 0;\n    inq[s] = true;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        inq[u] = false;\n\n        for(int i : G[u]){\n            Edge e = (i < 0 ? redges[-i] : edges[i]);\n            if(e.r > 0 && d[e.v] > d[u] + e.c){\n                d[e.v] = d[u] + e.c;\n                p[e.v] = i;\n                if(!inq[e.v]){\n                    inq[e.v] = true;\n                    Q.push(e.v);\n                }\n            }\n        }\n    }\n}\n\nint minimum_cost_flow(int s = 0, int t = 2*N+1){\n    int flow = 0, cost = 0;\n    while(flow < K){\n        bellman_ford(s);\n        if(d[t] == INF) break;\n\n        int aug = K-flow;\n        int u = t;\n        while(u != s){\n            Edge e = (p[u] < 0 ? redges[-p[u]] : edges[p[u]]);\n            aug = min(aug, e.r);\n            u = e.u;\n        }\n\n        flow += aug;\n        cost += aug * d[t];\n        u = t;\n        while(u != s){\n            if(p[u] < 0){\n                redges[-p[u]].r -= aug;\n                edges[-p[u]].r += aug;\n            } else {\n                redges[p[u]].r += aug;\n                edges[p[u]].r -= aug;\n            }\n            u = (p[u] < 0 ? redges[-p[u]].u : edges[p[u]].u);\n        }\n    }\n    return (flow < K ? INF : cost);\n}\n\nint main(){\n    read_input();\n\n    K = rowtot;\n    int max_reward = -minimum_cost_flow();\n    if(rowtot != coltot || max_reward == -INF){\n        printf("-1\\n");\n        return 0;\n    }\n\n    printf("%d\\n", max_reward);\n    for(Edge e : edges){\n        if(e.u != 0 && e.v != 2*N+1){\n            printf("%c", (e.r == 0 ? \'X\' : \'.\'));\n            if(e.v == 2*N)  printf("\\n");\n        }\n    }\n}',
//   "2132":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N, x;\npriority_queue<int> Q;\n\nint main(){\n    scanf("%d", &N);\n    ll ans = 0;\n    for(int i = 0; i < N; i++){\n        scanf("%d", &x);\n        Q.push(x);\n        ans += Q.top() - x;\n        Q.pop();\n        Q.push(x);\n    }\n    printf("%lld\\n", ans);\n}',
//   "2133":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef array<int,3> triple;\nconst int maxN = 1e5+1;\nconst int SIZE = 3e5+1;\nconst int INF = 0x3f3f3f3f;\n\nint N, M, K, root, components, del_time[SIZE];\nbool used[SIZE];\npii edges[SIZE];\ntriple ops[maxN];\nmap<pii,deque<int>> edge_id_map;\n\nstruct Node {\n    bool rev = false;\n    Node *c[2] = {nullptr, nullptr}, *p = nullptr;\n    int mn, id;\n\n    Node(int i){\n        mn = id = i;\n    }\n\n    void push(){\n        if(rev){\n            swap(c[0], c[1]);\n            if(c[0])    c[0]->rev ^= true;\n            if(c[1])    c[1]->rev ^= true;\n            rev = false;\n        }\n    }\n\n    void pull(){\n        mn = id;\n        for(int i = 0; i < 2; i++)\n            if(c[i] && del_time[c[i]->mn] < del_time[mn])\n                mn = c[i]->mn;\n    }\n} *LCT[SIZE];\n\nbool notRoot(Node *t){\n    return t->p && (t->p->c[0] == t || t->p->c[1] == t);\n}\n\nvoid rotate(Node *t){\n    Node *p = t->p;\n    bool b = (p->c[0] == t);\n    if((t->p = p->p) && notRoot(p)) t->p->c[(t->p->c[1] == p)] = t;\n    if((p->c[!b]=t->c[b]))          p->c[!b]->p = p;\n    t->c[b] = p;\n    p->p = t;\n    p->pull();\n}\n\n\nvoid splay(Node *t){\n    while(notRoot(t)){\n        Node *p = t->p;\n        p->push();\n        t->push();\n        rotate(t);\n    }\n    t->push();\n    t->pull();\n}\n\nNode* access(Node *t){\n    Node *last = nullptr;\n    for(Node *u = t; u; u = u->p){\n        splay(u);\n        u->c[1] = last;\n        last = u;\n    }\n    splay(t);\n    return last;\n}\n\nvoid evert(Node *t){\n    access(t);\n    t->rev = true;\n}\n\nvoid link(Node *u, Node *v){\n    evert(u);\n    u->p = v;\n}\n\nvoid cut(Node *u, Node *v){\n    evert(u);\n    access(v);\n    if(v->c[0]) v->c[0]->p = 0;\n    v->c[0] = 0;\n    v->pull();\n}\n\nNode* path(Node *u, Node *v){\n    evert(u);\n    access(v);\n    return v;\n}\n\nbool connected(Node *u, Node *v){\n    path(u, v);\n    while(v->c[0])\n        v = v->c[0];\n    return u == v;\n}\n\nvoid create_edge(int u, int v){\n    int id = edge_id_map[{u, v}].front();\n    if(!connected(LCT[u], LCT[v])){\n        components--;\n        link(LCT[id], LCT[u]);\n        link(LCT[id], LCT[v]);\n        used[id] = true;\n    } else {\n        int mn = path(LCT[u], LCT[v])->mn;\n        if(del_time[mn] < del_time[id]){\n            int cu = edges[mn].first;\n            int cv = edges[mn].second;\n            cut(LCT[mn], LCT[cu]);\n            cut(LCT[mn], LCT[cv]);\n            used[mn] = false;\n            link(LCT[id], LCT[u]);\n            link(LCT[id], LCT[v]);\n            used[id] = true;\n        }\n    }\n}\n\nvoid destroy_edge(int u, int v){\n    int id = edge_id_map[{u, v}].front();\n    edge_id_map[{u, v}].pop_front();\n    if(!used[id])   return;\n    cut(LCT[id], LCT[u]);\n    cut(LCT[id], LCT[v]);\n    used[id] = false;\n    components++;\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n\n    root = 1;\n    for(int i = 1; i <= N; i++){\n        LCT[i] = new Node(i);\n        del_time[i] = INF;\n    }\n\n    for(int i = 1, a, b; i <= M; i++){\n        scanf("%d %d", &a, &b);\n        if(a > b)   swap(a, b);\n        edges[N+i] = {a, b};\n        del_time[N+i] = INF;\n        LCT[N+i] = new Node(N+i);\n        edge_id_map[{a, b}].push_back(N+i);\n    }\n\n    for(int i = 1, t, a, b; i <= K; i++){\n        scanf("%d %d %d", &t, &a, &b);\n        if(a > b)   swap(a, b);\n        ops[i] = {t, a, b};\n        edges[N+M+i] = {a, b};\n\n        if(t == 2){\n            int id = edge_id_map[{a, b}].back();\n            del_time[id] = i;\n        } else {\n            del_time[N+M+i] = INF;\n            LCT[N+M+i] = new Node(N+M+i);\n            edge_id_map[{a, b}].push_back(N+M+i);\n        }\n    }\n\n    components = N;\n    for(int i = N+1; i <= N+M; i++){\n        int u = edges[i].first;\n        int v = edges[i].second;\n        create_edge(u, v);\n    }\n    printf("%d ", components);\n\n    for(int i = 1; i <= K; i++){\n        int t = ops[i][0];\n        int u = ops[i][1];\n        int v = ops[i][2];\n        if(t == 1)  create_edge(u, v);\n        else        destroy_edge(u, v);\n        printf("%d%c", components, (" \\n")[i==K]);\n    }\n}',
//   "2134":
//     '#include <bits/stdc++.h>\n\n/**\n * Link Cut Tree\n */\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, Q, k, x, y, root, idcounter;\n\nstruct Lazy {\n    int a = 1, b = 0;\n    bool empty(){\n        return (a == 1 && b == 0);\n    }\n};\n\nstruct Node {\n    Lazy tag;\n    bool rev = false;\n    Node *c[2] = {nullptr, nullptr}, *p = nullptr;\n    int sz, val, sum, mn, mx, id = ++idcounter;\n\n    Node(int v){\n        sz = 1;\n        val = sum = mn = mx = v;\n    }\n\n    void apply(Lazy other){\n        mn = mn*other.a + other.b;\n        mx = mx*other.a + other.b;\n        val = val*other.a + other.b;\n        sum = sum*other.a + sz*other.b;\n        tag = {tag.a*other.a, tag.b*other.a+other.b};\n    }\n\n    void push(){\n        if(rev){\n            swap(c[0], c[1]);\n            if(c[0])    c[0]->rev ^= true;\n            if(c[1])    c[1]->rev ^= true;\n            rev = false;\n        }\n        if(!tag.empty()){\n            if(c[0])    c[0]->apply(tag);\n            if(c[1])    c[1]->apply(tag);\n            tag = Lazy();\n        }\n    }\n\n    void pull(){\n        sum = mn = mx = val;\n        sz = 1;\n        for(int i = 0; i < 2; i++){\n            if(c[i]){\n                mn = min(mn, c[i]->mn);\n                mx = max(mx, c[i]->mx);\n                sum += c[i]->sum;\n                sz += c[i]->sz;\n            }\n        }\n    }\n} *LCT[maxN];\n\nbool notRoot(Node *t){\n    return t->p && (t->p->c[0] == t || t->p->c[1] == t);\n}\n\nvoid rotate(Node *t){\n    Node *p = t->p;\n    bool b = (p->c[0] == t);\n    if((t->p = p->p) && notRoot(p)) t->p->c[(t->p->c[1] == p)] = t;\n    if((p->c[!b]=t->c[b]))          p->c[!b]->p = p;\n    t->c[b] = p;\n    p->p = t;\n    p->pull();\n}\n\n\nvoid splay(Node *t){\n    while(notRoot(t)){\n        Node *p = t->p;\n        p->push();\n        t->push();\n        rotate(t);\n    }\n    t->push();\n    t->pull();\n}\n\nNode* access(Node *t){\n    Node *last = nullptr;\n    for(Node *u = t; u; u = u->p){\n        splay(u);\n        u->c[1] = last;\n        last = u;\n    }\n    splay(t);\n    return last;\n}\n\nvoid evert(Node *t){\n    access(t);\n    t->rev = true;\n}\n\nvoid link(Node *u, Node *v){\n    evert(u);\n    u->p = v;\n}\n\nvoid cut(Node *u, Node *v){\n    evert(u);\n    access(v);\n    if(v->c[0]) v->c[0]->p = 0;\n    v->c[0] = 0;\n    v->pull();\n}\n\nNode* path(Node *u, Node *v){\n    evert(u);\n    access(v);\n    return v;\n}\n\nNode* LCA(Node *u, Node *v){\n    evert(LCT[root]);\n    access(u);\n    return access(v);\n}\n\nbool connected(Node *u, Node *v){\n    path(u, v);\n    while(v->c[0])\n        v = v->c[0];\n    return u == v;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &x);\n        LCT[i] = new Node(x);\n    }\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &x, &y);\n        link(LCT[x], LCT[y]);\n    }\n\n    root = 1;\n    for(int i = 0; i < Q; i++){\n        scanf("%d", &k);\n        if(k == 1){\n            scanf("%d %d", &x, &y);\n            Node *p = path(LCT[x], LCT[x]);\n            p->apply({0, y});\n        } else if(k == 2){\n            scanf("%d %d", &x, &y);\n            Node *p = path(LCT[x], LCT[y]);\n            printf("%d ", p->mx);\n        }\n    }\n}\n',
//   "2136":
//     "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e4;\n\nint N, ans, b[maxN];\n\nint scanBinary(){\n    char c;\n    int res = 0;\n    while((c = getchar()) != '\\n'){\n        res <<= 1;\n        res += (c-'0')&1;\n    }\n    return res;\n}\n\nint main(){\n    scanf(\"%d %d \", &N, &ans);\n    for(int i = 0; i < N; i++)\n        b[i] = scanBinary();\n\n    for(int i = 0; i < N; i++)\n        for(int j = i+1; j < N; j++)\n            ans = min(ans, __builtin_popcount(b[i]^b[j]));\n\n    printf(\"%d\\n\", ans);\n}\n",
//   "2137":
//     '#include <bits/stdc++.h>\n#pragma GCC target("popcnt")\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 3005;\n\nint N;\nll ans;\nbitset<maxN> B[maxN];\n\nint f(int X){\n    return X*(X-1);\n}\n\nint main(){\n    cin.sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> N;\n    for(int i = 0; i < N; i++)\n        cin >> B[i];\n\n    for(int i = 0; i < N; i++)\n        for(int j = i+1; j < N; j++)\n            ans += f((B[i]&B[j]).count());\n\n    cout << (ans>>1);\n}\n',
//   "2138":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 5e4+1;\n\nint N, M, a, b, in[maxN];\nbitset<maxN> ans[maxN];\nvector<int> G[maxN];\nqueue<int> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[b].push_back(a);\n        in[a]++;\n    }\n\n    for(int i = 1; i <= N; i++){\n        if(in[i] == 0){\n            ans[i].set(i);\n            Q.push(i);\n        }\n    }\n\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        for(int v : G[u]){\n            ans[v] |= ans[u];\n            in[v]--;\n            if(in[v] == 0){\n                ans[v].set(v);\n                Q.push(v);\n            }\n        }\n    }\n\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", (int) ans[i].count(), (" \\n")[i==N]);\n}\n',
//   "2143":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 5e4+5;\n\nbool vis[maxN];\nint N, M, Q, ds[maxN];\nvector<int> order, component;\nvector<int> G[maxN], H[maxN], SCC[maxN];\nbitset<maxN> reachable[maxN];\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v]){\n        ds[u] += ds[v];\n        ds[v] = u;\n    } else {\n        ds[v] += ds[u];\n        ds[u] = v;\n    }\n    return true;\n}\n\nvoid dfs1(int u){\n    vis[u] = true;\n    for(int v : G[u])\n        if(!vis[v])\n            dfs1(v);\n    order.push_back(u);\n}\n\nvoid dfs2(int u){\n    vis[u] = true;\n    component.push_back(u);\n    for(int v : H[u])\n        if(!vis[v])\n            dfs2(v);\n}\n\nvoid dfs3(int u){\n    vis[u] = true;\n    for(int v : SCC[u]){\n        if(!vis[v])\n            dfs3(v);\n        reachable[u] |= reachable[v];\n    }\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &Q);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        H[b].push_back(a);\n    }\n\n    fill(vis+1, vis+N+1, false);\n    for(int i = 1; i <= N; i++)\n        if(!vis[i])\n            dfs1(i);\n\n    fill(ds+1, ds+N+1, -1);\n    fill(vis+1, vis+N+1, false);\n    for(int i = 1; i <= N; i++){\n        int u = order[N-i];\n        if(!vis[u]){\n            dfs2(u);\n            for(int j = 0; j+1 < (int) component.size(); j++)\n                merge(component[j], component[j+1]);\n            component.clear();\n        }\n    }\n\n    for(int i = 1; i <= N; i++){\n        int rep = find(i);\n        reachable[rep].set(i);\n        for(int v : G[i])\n            SCC[rep].push_back(find(v));\n    }\n\n    fill(vis+1, vis+N+1, false);\n    for(int i = 1; i <= N; i++)\n        if(!vis[i])\n            dfs3(i);\n\n    for(int i = 0, a, b; i < Q; i++){\n        scanf("%d %d", &a, &b);\n        a = find(a); b = find(b);\n        printf(reachable[a][b] ? "YES\\n" : "NO\\n");\n    }\n}\n',
//   "2162":
//     '#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nint N, idx;\ntree<int, null_type, less<int>, rb_tree_tag,\ntree_order_statistics_node_update> T;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++)\n        T.insert(i);\n\n    idx = 1;\n    while(T.size()){\n        idx %= T.size();\n        int x = *T.find_by_order(idx);\n        T.erase(x);\n        printf("%d%c", x, (" \\n")[T.size() == 0]);\n        idx++;\n    }\n}\n',
//   "2163":
//     '#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nint N, K, idx;\ntree<int, null_type, less<int>, rb_tree_tag,\ntree_order_statistics_node_update> T;\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 1; i <= N; i++)\n        T.insert(i);\n\n    idx = K;\n    while(T.size()){\n        idx %= T.size();\n        int x = *T.find_by_order(idx);\n        T.erase(x);\n        printf("%d%c", x, (" \\n")[T.size() == 0]);\n        idx += K;\n    }\n}\n',
//   "2164":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint Q;\nmap<pii,int> f;\n\nint solve(int N, int K){\n    if(f[{N, K}])   return f[{N, K}];\n\n    if(N == 1)      return f[{N, K}] = 1;\n    if(2*K <= N)    return f[{N, K}] = 2*K;\n\n    int newN = (N/2)+(N&1);\n    int newK = K-N/2;\n\n    if(N&1){\n        int ans = solve(newN, newK);\n        return f[{N, K}] = ((2*ans-3)+(N+1)) % (N+1);\n    } else {\n        return f[{N, K}] = 2*solve(newN, newK)-1;\n    }\n}\n\nint main(){\n    scanf("%d", &Q);\n    for(int q = 0, N, K; q < Q; q++){\n        scanf("%d %d", &N, &K);\n        printf("%d\\n", solve(N, K));\n    }\n}',
//   "2165":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\n\nvoid move(int from, int to, int depth){\n    if(depth == 1){\n        printf("%d %d\\n", from, to);\n        return;\n    }\n\n    int other = 6 - from - to;\n    move(from, other, depth-1);\n    printf("%d %d\\n", from, to);\n    move(other, to, depth-1);\n}\n\nint main(){\n    scanf("%d", &N);\n    printf("%d\\n", (1<<N)-1);\n    move(1, 3, N);\n}\n',
//   "2166":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst int maxN = 2e5+1;\nconst int SIZE = 4*maxN;\n\nint N, Q, lo[SIZE], hi[SIZE], mp[maxN];\nll sum[SIZE], pre[SIZE];\n\nvoid pull(int i){\n    pre[i] = max(pre[2*i], sum[2*i]+pre[2*i+1]);\n    sum[i] = sum[2*i] + sum[2*i+1];\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        scanf("%lld", &sum[i]);\n        pre[i] = max(0LL, sum[i]);\n        mp[l] = i;\n        return;\n    }\n    int m = (l+r)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid update(int idx, int val){\n    int i = mp[idx];\n    sum[i] = val;\n    pre[i] = max(0LL, sum[i]);\n\n    i >>= 1;\n    while(i){\n        pull(i);\n        i >>= 1;\n    }\n}\n\npll query(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])      return {0, 0};\n    if(l <= lo[i] && hi[i] <= r)    return {pre[i], sum[i]};\n\n    pll left = query(2*i, l, r);\n    pll right = query(2*i+1, l, r);\n    return {max(left.first, left.second+right.first), left.second+right.second};\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    init(1, 1, N);\n    for(int q = 0, t, a, b; q < Q; q++){\n        scanf("%d %d %d", &t, &a, &b);\n        if(t == 1)\n            update(a, b);\n        else if(t == 2)\n            printf("%lld\\n", query(1, a, b).first);\n    }\n}\n',
//   "2168":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef array<int,3> triple;\nconst int maxN = 2e5+1;\nconst int SIZE = 2*maxN;\n\nint N, ans[2][maxN], ds[SIZE];\ntriple intervals[maxN];\nset<int> unique_vals;\nmap<int,int> mp;\n\nvoid update(int idx, int val){\n    for(int i = idx; i < SIZE; i += -i&i)   ds[i] += val;\n}\n\nint query(int idx){\n    int cnt = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        cnt += ds[i];\n    return cnt;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0, x, y; i < N; i++){\n        scanf("%d %d", &x, &y);\n        intervals[i] = {x, y, i};\n        unique_vals.insert(x);\n        unique_vals.insert(y);\n    }\n    sort(intervals, intervals+N, [](triple A, triple B){\n        return (A[0] == B[0] ? A[1] > B[1] : A[0] < B[0]);\n    });\n\n    int val_id = 1;\n    for(int x : unique_vals)\n        mp[x] = val_id++;\n\n    for(int i = N-1; i >= 0; i--){\n        int y = mp[intervals[i][1]];\n        int id = intervals[i][2];\n\n        ans[0][id] = query(y);\n        update(y, 1);\n    }\n\n    fill(ds, ds+SIZE, 0);\n    for(int i = 0; i < N; i++){\n        int y = mp[intervals[i][1]];\n        int id = intervals[i][2];\n\n        ans[1][id] = i-query(y-1);\n        update(y, 1);\n    }\n\n    for(int i = 0; i < 2; i++)\n        for(int j = 0; j < N; j++)\n            printf("%d%c", (ans[i][j] ? 1 : 0), (" \\n")[j==N-1]);\n}',
//   "2169":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef array<int,3> triple;\nconst int maxN = 2e5+1;\nconst int SIZE = 2*maxN;\n\nint N, ans[2][maxN], ds[SIZE];\ntriple intervals[maxN];\nset<int> unique_vals;\nmap<int,int> mp;\n\nvoid update(int idx, int val){\n    for(int i = idx; i < SIZE; i += -i&i)   ds[i] += val;\n}\n\nint query(int idx){\n    int cnt = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        cnt += ds[i];\n    return cnt;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0, x, y; i < N; i++){\n        scanf("%d %d", &x, &y);\n        intervals[i] = {x, y, i};\n        unique_vals.insert(x);\n        unique_vals.insert(y);\n    }\n    sort(intervals, intervals+N, [](triple A, triple B){\n        return (A[0] == B[0] ? A[1] > B[1] : A[0] < B[0]);\n    });\n\n    int val_id = 1;\n    for(int x : unique_vals)\n        mp[x] = val_id++;\n\n    for(int i = N-1; i >= 0; i--){\n        int y = mp[intervals[i][1]];\n        int id = intervals[i][2];\n\n        ans[0][id] = query(y);\n        update(y, 1);\n    }\n\n    fill(ds, ds+SIZE, 0);\n    for(int i = 0; i < N; i++){\n        int y = mp[intervals[i][1]];\n        int id = intervals[i][2];\n\n        ans[1][id] = i-query(y-1);\n        update(y, 1);\n    }\n\n    for(int i = 0; i < 2; i++)\n        for(int j = 0; j < N; j++)\n            printf("%d%c", ans[i][j], (" \\n")[j==N-1]);\n}',
//   "2176":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 501;\nconst ll MOD = 1e9+7;\n\nint N, K;\nll fac[maxN], inv[maxN];\nll T[maxN], B[2*maxN], W[2*maxN];\n\nll fastpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n        if(b&1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll choose(int n, int k){\n    if(k < 0 || n < k)  return 0;\n    return fac[n] * inv[k] % MOD * inv[n-k] % MOD;\n}\n\nll stirling2(int n, int k){\n    ll sum = 0;\n    for(int i = 0; i <= k; i++){\n        ll a = (i&1 ? -1 : 1);\n        ll b = choose(k, i);\n        ll c = fastpow(k-i, n);\n        ll term = a * b % MOD * c % MOD;\n        sum = (sum + term + MOD) % MOD;\n    }\n    return sum * inv[k] % MOD;\n}\n\nvoid compute_T(int n){\n    for(int k = 0; k <= n; k++)\n        T[k] = stirling2(n+1, n+1-k);\n}\n\nvoid init_choose(){\n    fac[0] = inv[0] = 1;\n    for(int i = 1; i < maxN; i++){\n        fac[i] = (fac[i-1] * i) % MOD;\n        inv[i] = fastpow(fac[i], MOD-2);\n    }\n}\n\nll calculate(int n, int k){\n    if(n == 1)      return 1;\n    if(k >= 2*n)    return 0;\n    memset(B, 0, sizeof(B));\n    memset(W, 0, sizeof(W));\n\n    int m = n/2, odd = n&1;\n    for(int k = 0; k <= m+odd; k++){\n        compute_T(2*m-1-k+odd);\n        ll a = choose(m+odd, k);\n        ll b = choose(m, k);\n        for(int i = 0; i+k < n; i++){\n            B[i+k] += (a * T[i]) % MOD;\n            B[i+k] %= MOD;\n            W[i+k] += (b * T[i]) % MOD;\n            W[i+k] %= MOD;\n        }\n    }\n\n    ll sum = 0;\n    for(int b = 0; b <= min(N-1, K); b++){\n        int w = K-b;\n        sum += (B[b] * W[w]) % MOD;\n        sum %= MOD;\n    }\n    return sum;\n}\n\nint main(){\n    init_choose();\n    scanf("%d %d", &N, &K);\n    printf("%lld\\n", calculate(N, K));\n}',
//   "2177":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 1e5+1;\nconst int maxM = 2e5+1;\n\nint N, M, timer, tin[maxN], low[maxN];\nbool bridge_exists, vis[maxN], used[maxM];\nvector<pii> G[maxN];\npii edges[maxM];\n\nvoid dfs(int u = 1, int p = 0){\n    vis[u] = true;\n    tin[u] = low[u] = ++timer;\n    for(pii P : G[u]){\n        int v = P.first;\n        int id = P.second;\n        if(used[id])    continue;\n\n        used[id] = true;\n        edges[id] = {u, v};\n\n        if(vis[v]){\n            low[u] = min(low[u], tin[v]);\n        } else {\n            dfs(v, u);\n            low[u] = min(low[u], low[v]);\n            if(low[v] > tin[u])\n                bridge_exists = true;\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back({b, i});\n        G[b].push_back({a, i});\n    }\n\n    dfs();\n    if(timer == N && !bridge_exists){\n        for(int i  = 0; i < M; i++)\n            printf("%d %d\\n", edges[i].first, edges[i].second);\n    } else printf("IMPOSSIBLE\\n");\n}\n',
//   "2179":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 1e5+5, maxM = 2e5+5;\n\nint N, M, timer, in[maxN];\nbool even[maxN];\nvector<pii> G[maxN];\npii ans[maxM];\n\nvoid dfs(int u, int p = -1){\n    in[u] = ++timer;\n    for(pii e : G[u]){\n        int v = e.first, id = e.second;\n        if(v != p){\n            if(!in[v]){\n                dfs(v, u);\n                if(even[v]){\n                    ans[id] = {u, v};\n                    even[u] ^= true;\n                } else {\n                    ans[id] = {v, u};\n                    even[v] ^= true;\n                }\n            } else if(in[v] < in[u]){\n                even[u] ^= true;\n                ans[id] = {u, v};\n            }\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back({b, i});\n        G[b].push_back({a, i});\n    }\n\n    fill(even+1, even+N+1, true);\n    for(int i = 1; i <= N; i++)\n        if(!in[i])\n            dfs(i);\n\n    bool good = true;\n    for(int i = 1; i <= N; i++)\n        good &= even[i];\n\n    if(good){\n        for(int i = 0; i < M; i++)\n            printf("%d %d\\n", ans[i].first, ans[i].second);\n    } else printf("IMPOSSIBLE\\n");\n}',
//   "2180":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5;\n\nint N, a[2][maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int r = 0; r < 2; r++){\n        for(int i = 0; i < N; i++){\n            scanf("%d", &a[r][i]);\n            a[r][i]--;\n        }\n    }\n\n    ll ans = 0;\n    int top = 0, bot = 0;\n    for(int i = 0; i < N; i++){\n        top += a[0][i];\n        bot += a[1][i];\n\n        if((top < 0 && bot > 0) || (top > 0 && bot < 0)){\n            if(abs(top) < abs(bot)){\n                ans += abs(top);\n                bot += top;\n                top = 0;\n            } else {\n                ans += abs(bot);\n                top += bot;\n                bot = 0;\n            }\n        }\n\n        ans += abs(top + bot);\n    }\n    printf("%lld\\n", ans);\n}',
//   "2181":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 11;\nconst int maxM = 1001;\nconst ll MOD = 1e9+7;\n\nint N, M;\nll dp[maxN][maxM][1<<maxN];\n\nint main(){\n    scanf("%d %d", &N, &M);\n    dp[N][0][0] = 1;\n    for(int i = 1; i <= M; i++){\n        for(int j = 0; j < (1<<N); j++)\n            dp[0][i][j<<1] = dp[N][i-1][j];\n\n        for(int j = 1; j <= N; j++){\n            int x = 1<<(j-1);\n            int y = 1<<j;\n            for(int mask = 0; mask < (1<<(N+1)); mask++){\n                dp[j-1][i][mask] %= MOD;\n                if((mask&x) && (mask&y))    continue;\n                if(mask&x)                  dp[j][i][mask^x] += dp[j-1][i][mask];\n                else if(mask&y)             dp[j][i][mask^y] += dp[j-1][i][mask];\n                else {\n                    dp[j][i][mask^x] += dp[j-1][i][mask];\n                    dp[j][i][mask^y] += dp[j-1][i][mask];\n                }\n            }\n        }\n    }\n    printf("%lld\\n", dp[N][M][0] % MOD);\n}\n',
//   "2182":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5;\nconst ll MOD = 1e9+7;\n\nint N;\nll x[maxN], k[maxN];\nll tau, sigma, pi, mu;\n\nll fastpow(ll a, ll b){\n    ll res = 1;\n    while(b > 0){\n        if(b&1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        scanf("%lld %lld", &x[i], &k[i]);\n\n    tau = 1;\n    for(int i = 0; i < N; i++)\n        tau = (tau * (k[i]+1)) % MOD;\n\n    sigma = 1;\n    for(int i = 0; i < N; i++){\n        ll numerator = (fastpow(x[i], k[i]+1)-1+MOD) % MOD;\n        ll denominator = fastpow(x[i]-1, MOD-2);\n        ll geoSum = numerator * denominator % MOD;\n        sigma = (sigma * geoSum) % MOD;\n    }\n\n    pi = 1;\n    mu = 1;\n    for(int i = 0; i < N; i++){\n        ll p = fastpow(x[i], k[i]*(k[i]+1)/2);\n        mu = fastpow(mu, k[i]+1) * fastpow(p, pi) % MOD;\n        pi = (pi * (k[i]+1)) % (MOD-1);\n    }\n\n    printf("%lld %lld %lld\\n", tau, sigma, mu);\n}\n',
//   "2183":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, x[maxN];\nll res;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &x[i]);\n    sort(x, x+N);\n\n    res = 1;\n    for(int i = 0; i < N && x[i] <= res; i++)\n        res += x[i];\n    printf("%lld\\n", res);\n}\n',
//   "2184":
//     "#include <bits/stdc++.h>\n\n/* Fast Input and Output Template */\nchar _i[1<<24], _o[1<<10], __[20], _, _c; int _i0, _o0, _n;\n#define readio()    { fread(_i, 1, 1<<24, stdin); }\n#define writeio()   { fwrite(_o, 1, _o0, stdout); }\n#define scanu(x)    { for (x = _i[_i0++] & 15; 47 < (_ = _i[_i0++]); x = x * 10 + (_ & 15)); }\n#define putnumu(x)  { _ = 0; do __[_++] = x % 10 | '0'; while (x /= 10); while (_--) _o[_o0++] = __[_]; }\n#define putnl()     { _o[_o0++] = '\\n'; }\n/* End of Template */\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+2;\nconst int logC = 32, logN = 18;\nconst int INF = 0x3f3f3f3f;\n\nint N, Q, mn[logC][logN][maxN];\nll pre[logC][maxN];\n\nint layer(int x){\n    return 31 - __builtin_clz(x);\n}\n\nll sum(int l, int a, int b){\n    return pre[l][b] - pre[l][a-1];\n}\n\nint minimum(int l, int a, int b){\n    a--; b--;\n    int len = b-a+1;\n    int k = (int) floor(log2(len));\n    return min(mn[l][k][a], mn[l][k][b-(1<<k)+1]);\n}\n\nvoid init(){\n    scanu(N); scanu(Q);\n    for(int i = 1, x; i <= N; i++){\n        scanu(x);\n        int l = layer(x);\n        pre[l][i] = x;\n        for(int j = 0; j < logC; j++)\n            mn[j][0][i-1] = (j == l ? x : INF);\n    }\n\n    for(int l = 0; l < logC; l++){\n        for(int j = 1; j <= N; j++)\n            pre[l][j] += pre[l][j-1];\n\n        for(int i = 1; i < logN; i++)\n            for(int j = 0; j <= N-(1<<i); j++)\n                mn[l][i][j] = min(mn[l][i-1][j], mn[l][i-1][j+(1<<(i-1))]);\n    }\n}\n\nll query(int a, int b){\n    ll ans = 1;\n    for(int l = 0; l < logC && ans >= (1<<l); l++)\n        if(minimum(l, a, b) <= ans)\n            ans += sum(l, a, b);\n    return ans;\n}\n\nint main(){\n    readio();\n    init();\n    for(int q = 0, a, b; q < Q; q++){\n        scanu(a); scanu(b);\n        ll ans = query(a, b);\n        putnumu(ans);\n        putnl();\n    }\n    writeio();\n}",
//   "2185":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 0.001;\nconst int maxK = 20;\n\nint K;\nll N, cnt, a[maxK];\n\nint main(){\n    scanf("%lld %d", &N, &K);\n    for(int i = 0; i < K; i++)\n        scanf("%lld", &a[i]);\n\n    cnt = N;\n    double RHS = log(N) + EPS;\n    for(int mask = 0; mask < (1<<K); mask++){\n        bool odd = (__builtin_popcount(mask)&1);\n\n        ll prod = 1;\n        double LHS = 0.0;\n        for(int i = 0; i < K; i++){\n            if(mask&(1<<i)){\n                LHS += log(a[i]);\n                prod *= a[i];\n            }\n        }\n\n        if(LHS < RHS)\n            cnt += (odd ? 1 : -1) * (N/prod);\n    }\n\n    printf("%lld\\n", cnt);\n}',
//   "2186":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, M;\nchar S[maxN];\nbool exists[26];\nmap<char,int> ch;\nmap<vector<int>,ll> dp;\n\nbool containsEach(vector<int> V){\n    for(int i = 0; i < (int) V.size(); i++)\n        if(V[i] <= 0)\n            return false;\n    return true;\n}\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n    for(int i = 0; i < N; i++){\n        int c = (int) (S[i] - \'a\');\n        if(!exists[c]){\n            ch[S[i]] = M++;\n            exists[c] = true;\n        }\n    }\n\n    ll ans = 0;\n    vector<int> freq(M);\n    dp[freq]++;\n    for(int i = 0; i < N; i++){\n        int c = ch[S[i]];\n        freq[c]++;\n        if(containsEach(freq))\n            for(int j = 0; j < M; j++)\n                freq[j]--;\n        ans += dp[freq];\n        dp[freq]++;\n    }\n    printf("%lld\\n", ans);\n}',
//   "2187":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e6+5;\nconst ll MOD = 1e9+7;\n\nchar S[maxN];\nint N, M, K;\nll tot, bad, fact[maxN], inv[maxN];\n\nll inverse(ll x){\n    ll res = 1;\n    ll b = MOD-2;\n    while(b){\n        if(b&1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll choose(int x, int y){\n    return (fact[x] * inv[y] % MOD) * inv[x-y] % MOD;\n}\n\nvoid init(){\n    fact[0] = inv[0] = 1;\n    for(int i = 1; i <= N; i++){\n        fact[i] = (fact[i-1] * i) % MOD;\n        inv[i] = (inv[i-1] * inverse(i)) % MOD;\n    }\n}\n\nint main(){\n    scanf("%d %s", &N, S);\n    M = (int) strlen(S);\n    init();\n\n    int open = 0, closed = 0;\n    for(int i = 0; i < M; i++){\n        if(S[i] == \'(\')         open++;\n        else if(S[i] == \')\')    closed++;\n\n        if(closed > open){\n            printf("0\\n");\n            return 0;\n        }\n    }\n\n    if(N&1 || open > N/2){\n        printf("0\\n");\n        return 0;\n    }\n\n    tot = choose(N-open-closed, N/2-open);\n    bad = choose(N-open-closed, N/2-open-1);\n    printf("%lld\\n", ((tot-bad)%MOD+MOD)%MOD);\n}',
//   "2189":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct Point {\n    int x, y;\n    void read(){ scanf("%d %d", &x, &y); }\n    Point operator +(const Point& b) const { return Point{x+b.x, y+b.y}; }\n    Point operator -(const Point& b) const { return Point{x-b.x, y-b.y}; }\n    ll operator *(const Point& b) const { return (ll) x * b.y - (ll) y * b.x; }\n    void operator +=(const Point& b) { x += b.x; y += b.y; }\n    void operator -=(const Point &b) { x -= b.x; y -= b.y; }\n    void operator *=(const int k) { x *= k; y *= k; }\n\n    ll cross(const Point& b, const Point& c) const {\n        return (b - *this) * (c - *this);\n    }\n};\n\nint T;\nPoint P[3];\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        for(int i = 0; i < 3; i++)\n            P[i].read();\n\n        ll cross = P[0].cross(P[1], P[2]);\n        if(cross < 0)       printf("RIGHT\\n");\n        else if(cross > 0)  printf("LEFT\\n");\n        else                printf("TOUCH\\n");\n    }\n}\n',
//   "2190":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct Point {\n    int x, y;\n    void read(){ scanf("%d %d", &x, &y); }\n    Point operator +(const Point& b) const { return Point{x+b.x, y+b.y}; }\n    Point operator -(const Point& b) const { return Point{x-b.x, y-b.y}; }\n    ll operator *(const Point& b) const { return (ll) x * b.y - (ll) y * b.x; }\n    void operator +=(const Point& b) { x += b.x; y += b.y; }\n    void operator -=(const Point &b) { x -= b.x; y -= b.y; }\n    void operator *=(const int k) { x *= k; y *= k; }\n\n    ll cross(const Point& b, const Point& c) const {\n        return (b - *this) * (c - *this);\n    }\n};\n\nint T;\nPoint P[4];\n\nvoid lineintersect(Point P1, Point P2, Point P3, Point P4){\n    // Parallel case\n    if((P2-P1) * (P4-P3) == 0){\n        // Collinear case, check bounding boxes\n        if(P1.cross(P2, P3) == 0){\n            for(int i = 0; i < 2; i++){\n                if(max(P1.x, P2.x) < min(P3.x, P4.x) || max(P1.y, P2.y) < min(P3.y, P4.y)){\n                    printf("NO\\n");\n                    return;\n                }\n                swap(P1, P3);\n                swap(P2, P4);\n            }\n            printf("YES\\n");\n            return;\n        }\n\n        // Non-collinear parallel lines never intersect\n        printf("NO\\n");\n        return;\n    }\n\n    // Non-parallel case\n    for(int i = 0; i < 2; i++){\n        ll s1 = P1.cross(P2, P3);\n        ll s2 = P1.cross(P2, P4);\n        if((s1 < 0 && s2 < 0) || (s1 > 0 && s2 > 0)){\n            printf("NO\\n");\n            return;\n        }\n        swap(P1, P3);\n        swap(P2, P4);\n    }\n\n    printf("YES\\n");\n}\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        for(int i = 0; i < 4; i++)\n            P[i].read();\n        lineintersect(P[0], P[1], P[2], P[3]);\n    }\n}\n',
//   "2191":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1001;\n\nint N;\nll x[maxN], y[maxN], ans;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        scanf("%lld %lld", &x[i], &y[i]);\n    x[N] = x[0]; y[N] = y[0];\n\n    for(int i = 0; i < N; i++){\n        ans += x[i] * y[i+1];\n        ans -= y[i] * x[i+1];\n    }\n    printf("%lld\\n", abs(ans));\n}\n',
//   "2192":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1001;\n\nstruct Point {\n    int x, y;\n    void read(){ scanf("%d %d", &x, &y); }\n    Point operator +(const Point& b) const { return Point{x+b.x, y+b.y}; }\n    Point operator -(const Point& b) const { return Point{x-b.x, y-b.y}; }\n    ll operator *(const Point& b) const { return (ll) x * b.y - (ll) y * b.x; }\n    void operator +=(const Point& b) { x += b.x; y += b.y; }\n    void operator -=(const Point& b) { x -= b.x; y -= b.y; }\n    void operator *=(const int k) { x *= k; y *= k; }\n\n    ll cross(const Point& b, const Point& c) const {\n        return (b - *this) * (c - *this);\n    }\n};\n\nint N, M;\nPoint P[maxN];\n\nbool pointlineintersect(Point P1, Point P2, Point P3){\n    if(P2.cross(P1, P3) != 0)   return false;\n    return (min(P2.x, P3.x) <= P1.x && P1.x <= max(P2.x, P3.x))\n        && (min(P2.y, P3.y) <= P1.y && P1.y <= max(P2.y, P3.y));\n}\n\nvoid pointinpolygon(){\n    int cnt = 0;\n    bool boundary = false;\n    for(int i = 1; i <= N; i++){\n        int j = (i == N ? 1 : i+1);\n        if(pointlineintersect(P[0], P[i], P[j]))\n            boundary = true;\n\n        if(P[i].x <= P[0].x && P[0].x < P[j].x && P[0].cross(P[i], P[j]) < 0)       cnt++;\n        else if(P[j].x <= P[0].x && P[0].x < P[i].x && P[0].cross(P[j], P[i]) < 0)  cnt++;\n    }\n\n    if(boundary)    printf("BOUNDARY\\n");\n    else if(cnt&1)  printf("INSIDE\\n");\n    else            printf("OUTSIDE\\n");\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 1; i <= N; i++)\n        P[i].read();\n    for(int i = 0; i < M; i++){\n        P[0].read();\n        pointinpolygon();\n    }\n}\n',
//   "2193":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+5;\n\nint N;\nll area, boundary, inside, x[maxN], y[maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        scanf("%lld %lld", &x[i], &y[i]);\n    x[N] = x[0]; y[N] = y[0];\n\n    for(int i = 0; i < N; i++){\n        area += x[i] * y[i+1];\n        area -= y[i] * x[i+1];\n    }\n    area = abs(area);\n\n    for(int i = 0; i < N; i++){\n        if(x[i+1] == x[i])      boundary += abs(y[i+1]-y[i]);\n        else if(y[i+1] == y[i]) boundary += abs(x[i+1]-x[i]);\n        else boundary += __gcd(abs(x[i+1]-x[i]), abs(y[i+1]-y[i]));\n    }\n\n    printf("%lld %lld\\n", (area+2-boundary)/2, boundary);\n}\n',
//   "2194":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst int maxN = 2e5+1;\n\nint N;\nll best;\nbool isLeft[maxN];\npll P[maxN];\n\nll square(ll x){\n    return x*x;\n}\n\nll dist(pll A, pll B){\n    ll dx = A.first-B.first;\n    ll dy = A.second-B.second;\n    return square(dx) + square(dy);\n}\n\nvoid solve(vector<int> PX, vector<int> PY){\n    int len = PX.size();\n    if(len == 1)  return;\n\n    vector<int> LX, LY, RX, RY;\n    for(int i = 0; i < len; i++){\n        if(i < len/2){\n            LX.push_back(PX[i]);\n            isLeft[PX[i]] = true;\n        } else {\n            RX.push_back(PX[i]);\n            isLeft[PX[i]] = false;\n        }\n    }\n\n    for(int id : PY){\n        if(isLeft[id])  LY.push_back(id);\n        else            RY.push_back(id);\n    }\n\n    solve(LX, LY);\n    solve(RX, RY);\n\n    ll midX = P[LX.back()].first;\n    vector<int> stripe;\n    for(int id : PY)\n        if(square(P[id].first-midX) < best)\n            stripe.push_back(id);\n\n    for(int i = 0; i < (int) stripe.size(); i++)\n        for(int j = i+1; j < (int) stripe.size() && square(P[stripe[i]].second-P[stripe[j]].second) < best; j++)\n            best = min(best, dist(P[stripe[i]], P[stripe[j]]));\n}\n\nint main(){\n    scanf("%d", &N);\n    vector<int> sortedX, sortedY;\n    for(int i = 0, x, y; i < N; i++){\n        scanf("%d %d", &x, &y);\n        P[i] = {x, y};\n        sortedX.push_back(i);\n        sortedY.push_back(i);\n    }\n    sort(sortedX.begin(), sortedX.end(), [](int A, int B){\n        return P[A].first < P[B].first;\n    });\n    sort(sortedY.begin(), sortedY.end(), [](int A, int B){\n        return P[A].second < P[B].second;\n    });\n\n    best = LLONG_MAX;\n    solve(sortedX, sortedY);\n    printf("%lld\\n", best);\n}',
//   "2195":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+5;\n\nstruct Point {\n    int x, y;\n    void read(){ scanf("%d %d", &x, &y); }\n    Point operator +(const Point& b) const { return Point{x+b.x, y+b.y}; }\n    Point operator -(const Point& b) const { return Point{x-b.x, y-b.y}; }\n    ll operator *(const Point& b) const { return (ll) x * b.y - (ll) y * b.x; }\n    bool operator <(const Point& b) const { return x == b.x ? y < b.y : x < b.x; }\n    void operator +=(const Point& b) { x += b.x; y += b.y; }\n    void operator -=(const Point &b) { x -= b.x; y -= b.y; }\n    void operator *=(const int k) { x *= k; y *= k; }\n\n    ll cross(const Point& b, const Point& c) const {\n        return (b - *this) * (c - *this);\n    }\n};\n\nint N, S;\nPoint P[maxN];\nvector<Point> hull;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        P[i].read();\n    sort(P, P+N);\n\n    for(int t = 0; t < 2; t++){\n        for(int i = 0; i < N; i++){\n            while((int) hull.size()-S >= 2){\n                Point P1 = hull[hull.size()-2];\n                Point P2 = hull[hull.size()-1];\n                if(P1.cross(P2, P[i]) <= 0) break;\n                hull.pop_back();\n            }\n            hull.push_back(P[i]);\n        }\n        hull.pop_back();\n        S = hull.size();\n        reverse(P, P+N);\n    }\n\n    printf("%d\\n", S);\n    for(Point h : hull)\n        printf("%d %d\\n", h.x, h.y);\n}\n',
//   "2205":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 16;\n\nint N;\nbool b[maxN+1];\n\nvoid print(){\n    for(int i = N; i > 0; i--)\n        printf("%d", b[i]);\n    printf("\\n");\n}\n\nint main(){\n    scanf("%d", &N);\n\n    print();\n    for(int i = 1; i < (1<<N); i++){\n        int LSB = __builtin_ffs(i);\n        b[LSB] ^= 1;\n        print();\n    }\n}\n',
//   "2206":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1, SIZE = 4*maxN;\nconst int INF = 0x3f3f3f3f;\n\nint N, Q, p[maxN], mp[maxN], lo[SIZE], hi[SIZE], mn[2][SIZE];\n\nvoid pull(int i){\n    mn[0][i] = min(mn[0][2*i], mn[0][2*i+1]);\n    mn[1][i] = min(mn[1][2*i], mn[1][2*i+1]);\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        scanf("%d", &p[l]);\n        mn[0][i] = l+p[l];\n        mn[1][i] = (N-l+1)+p[l];\n        mp[l] = i;\n        return;\n    }\n    int m = (l+r)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid update(int idx, int val){\n    int i = mp[idx];\n    mn[0][i] = idx+val;\n    mn[1][i] = (N-idx+1)+val;\n    i >>= 1;\n    while(i){\n        pull(i);\n        i >>= 1;\n    }\n}\n\nint query(int i, int t, int l, int r){\n    if(l > hi[i] || r < lo[i])      return INF;\n    if(l <= lo[i] && hi[i] <= r)    return mn[t][i];\n\n    int left = query(2*i, t, l, r);\n    int right = query(2*i+1, t, l, r);\n    return min(left, right);\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    init(1, 1, N);\n    for(int q = 0, t, k, x; q < Q; q++){\n        scanf("%d %d", &t, &k);\n        if(t == 1){\n            scanf("%d", &x);\n            update(k, x);\n        } else if(t == 2){\n            int left = query(1, 1, 1, k);\n            int right = query(1, 0, k, N);\n            printf("%d\\n", min(left-(N-k+1), right-k));\n        }\n    }\n}\n',
//   "2207":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6+1;\n\n/**\n * A036685\n * Retrivied from https://oeis.org/A036685\n */\n\nint T, lose[42] = { 0, 1, 2, 4, 7, 10, 20, 23, 26, 50, 53, 270, 273, 276, 282, 285, 288, 316, 334, 337, 340, 346, 359, 362, 365, 386, 389, 392, 566, 630, 633, 636, 639, 673, 676, 682, 685, 923, 926, 929, 932, 1222 };\nbool b[maxN];\n\nvoid init(){\n    for(int x : lose)\n        b[x] = true;\n}\n\nint main(){\n    init();\n    scanf("%d", &T);\n    for(int t = 0, N; t < T; t++){\n        scanf("%d", &N);\n        printf("%s\\n", b[N] ? "second" : "first");\n    }\n}',
//   "2208":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T, N, x;\nbool even;\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        scanf("%d", &N);\n        even = true;\n        for(int i = 0; i < N; i++){\n            scanf("%d", &x);\n            even &= !(x&1);\n        }\n        printf("%s\\n", even ? "second" : "first");\n    }\n}',
//   "2209":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nint N, M;\nll ans;\n\nll fastpow(ll a, ll b){\n    ll res = 1;\n    while(b > 0){\n        if(b&1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int k = 0; k < N; k++)\n        ans = (ans + fastpow(M, __gcd(k, N))) % MOD;\n    ans = (ans * fastpow(N, MOD-2)) % MOD;\n    printf("%lld\\n", ans);\n}',
//   "2210":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nll N, A, B, C;\n\nll fastpow(ll a, ll b){\n    ll res = 1;\n    while(b > 0){\n        if(b&1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    scanf("%lld", &N);\n    A = N * N;\n    B = (A+3*(N&1))/4;\n    C = (A+(N&1))/2;\n    printf("%lld\\n", ((fastpow(2, A)+2*fastpow(2, B)+fastpow(2, C))*fastpow(4,MOD-2))%MOD);\n}\n',
//   "2214":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e6+1;\n\nint N, idx, ans[maxN];\nll K;\ndeque<int> DQ;\n\nint main(){\n    scanf("%d %lld", &N, &K);\n    for(int i = 1; i <= N; i++)\n        DQ.push_back(i);\n\n    for(int k = N-1; k >= 0; k--){\n        if(k <= K){\n            ans[++idx] = DQ.back();\n            DQ.pop_back();\n            K -= k;\n        } else {\n            ans[++idx] = DQ.front();\n            DQ.pop_front();\n        }\n    }\n\n    for(int i = 1; i <= idx; i++)\n        printf("%d%c", ans[i], (" \\n")[i==idx]);\n}',
//   "2215":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, K;\n\nvoid solve(){\n    scanf("%d %d", &N, &K);\n    if(K*K < N){\n        printf("IMPOSSIBLE\\n");\n        return;\n    }\n\n    vector<int> ans;\n    int l = 1, r = K;\n    while(true){\n        for(int i = r; i >= l; i--)\n            ans.push_back(i);\n        if(r == N)  break;\n        l = r+1;\n        r = min(r+K, N);\n    }\n\n    for(int i = 0; i < N; i++)\n        printf("%d%c", ans[i], (" \\n")[i==N-1]);\n}\n\nint main(){\n    int T;\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        solve();\n    }\n}',
//   "2217":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\n\nint N, M, cnt, x[maxN], pos[maxN];\n\nvoid update(int a, int b){\n    if(pos[x[a]-1] <= pos[x[a]] && b < pos[x[a]-1]) cnt++;\n    if(pos[x[a]-1] > pos[x[a]] && b >= pos[x[a]-1]) cnt--;\n    if(pos[x[a]+1] >= pos[x[a]] && b > pos[x[a]+1]) cnt++;\n    if(pos[x[a]+1] < pos[x[a]] && b <= pos[x[a]+1]) cnt--;\n    pos[x[a]] = b;\n\n    if(pos[x[b]-1] <= pos[x[b]] && a < pos[x[b]-1]) cnt++;\n    if(pos[x[b]-1] > pos[x[b]] && a >= pos[x[b]-1]) cnt--;\n    if(pos[x[b]+1] >= pos[x[b]] && a > pos[x[b]+1]) cnt++;\n    if(pos[x[b]+1] < pos[x[b]] && a <= pos[x[b]+1]) cnt--;\n    pos[x[b]] = a;\n\n    swap(x[a], x[b]);\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &x[i]);\n        pos[x[i]] = i;\n    }\n    pos[N+1] = N+1;\n\n    cnt = 1;\n    for(int i = 1, ptr = 0; i <= N; i++){\n        if(ptr > pos[i])\n            cnt++;\n        ptr = pos[i];\n    }\n\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        update(a, b);\n        printf("%d\\n", cnt);\n    }\n}\n',
//   "2220":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 20;\n\nbool tight[maxN];\nll dp[10][maxN];\n\nll solve(ll x){\n    if(x <= 10) return x;\n\n    vector<int> D;\n    memset(dp, 0, sizeof(dp));\n    memset(tight, 0, sizeof(tight));\n    for(int i = 0; x; i++){\n        D.push_back(x%10);\n        x /= 10;\n    }\n    reverse(D.begin(), D.end());\n    int N = (int) D.size();\n\n    tight[0] = true;\n    for(int i = 1; i < N; i++)\n        tight[i] = tight[i-1] && (D[i] != D[i-1]);\n    for(int d = 1; d < D[0]; d++)\n        dp[d][0] = 1;\n\n    for(int i = 1; i < N; i++){\n        // Prefix [0..i-1] is same as X\n        if(tight[i-1])\n            for(int d = 0; d < D[i]; d++)\n                if(d != D[i-1])\n                    dp[d][i]++;\n\n        // Prefix [0..i-1] is all leading zeros\n        for(int d = 1; d <= 9; d++)\n            dp[d][i]++;\n\n        //  All other cases\n        for(int d1 = 0; d1 <= 9; d1++)\n            for(int d2 = 0; d2 <= 9; d2++)\n                if(d1 != d2)\n                    dp[d2][i] += dp[d1][i-1];\n    }\n\n    ll cnt = tight[N-1];\n    for(int d = 0; d <= 9; d++)\n        cnt += dp[d][N-1];\n    return cnt;\n}\n\nint main(){\n    ll a, b;\n    scanf("%lld %lld", &a, &b);\n    printf("%lld\\n", solve(b) - solve(a-1));\n}',
//   "2228":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e6+1;\nconst ll MOD = 1e9+7;\n\nint N, K;\nll fac[maxN], inv[maxN];\n\nll fastpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n        if(b&1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid init_choose(){\n    fac[0] = inv[0] = 1;\n    for(int i = 1; i < maxN; i++){\n        fac[i] = (fac[i-1] * i) % MOD;\n        inv[i] = fastpow(fac[i], MOD-2);\n    }\n}\n\nll choose(int n, int k){\n    if(k < 0 || k > n)  return 0;\n    return fac[n] * inv[k] % MOD * inv[n-k] % MOD;\n}\n\nll T(int n, int k){\n    ll sum = 0;\n    for(int j = 0; j <= k; j++){\n        ll a = (j&1 ? -1 : 1);\n        ll b = choose(k, j);\n        ll c = fastpow(k-j, n);\n        ll term = (a * b % MOD * c % MOD + MOD) % MOD;\n        sum = (sum + term) % MOD;\n    }\n    return sum;\n}\n\nint main(){\n    init_choose();\n    scanf("%d %d", &N, &K);\n    printf("%lld\\n", T(N, K));\n}',
//   "2229":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 501;\nconst int maxK = maxN*(maxN-1)/2;\nconst ll MOD = 1e9+7;\n\nint N, K;\nll dp[maxN][maxK];\n\nvoid init(){\n    for(int i = 1; i < maxN; i++){\n        int r = i*(i-1)/2;\n        dp[i][0] = dp[i][r] = 1;\n        for(int j = 1; j <= r/2; j++){\n            dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD;\n            if(j-i >= 0)\n                dp[i][j] = (dp[i][j] - dp[i-1][j-i] + MOD) % MOD;\n        }\n        for(int j = r/2+1; j < r; j++)\n            dp[i][j] = dp[i][r-j];\n    }\n}\n\nint main(){\n    init();\n    scanf("%d %d", &N, &K);\n    printf("%lld\\n", dp[N][K]);\n}',
//   "2413":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e6;\nconst ll MOD = 1e9+7;\n\nint T, N;\nll dp[maxN+1];\n\nint main(){\n    dp[1] = 2;\n    dp[2] = 8;\n    for(int i = 3; i <= maxN; i++)\n        dp[i] = ((6*dp[i-1] - 7*dp[i-2]) % MOD + MOD) % MOD;\n\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        scanf("%d", &N);\n        printf("%lld\\n", dp[N]);\n    }\n}\n',
//   "2414":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 101, maxM = 4951;\n\nint N, M;\nmultiset<ll> Bvals;\nll A[maxN], B[maxM];\n\nbool check(ll a0){\n    A[0] = a0;\n    Bvals.clear();\n    for(int i = 0; i < M; i++)\n        Bvals.insert(B[i]);\n\n    for(int i = 1; i < N; i++){\n        for(int j = 0; j < i-1; j++){\n            if(Bvals.find(A[j]+A[i-1]) == Bvals.end())\n                return false;\n            Bvals.erase(Bvals.lower_bound(A[j]+A[i-1]));\n        }\n        A[i] = *Bvals.begin() - A[0];\n    }\n\n    // Confirm that the last element, A[N-1], works. We desire\n    // the sum with the other A[i] to produce the remaining Bvals\n    for(int j = 0; j < N-1; j++){\n        if(Bvals.find(A[j]+A[N-1]) == Bvals.end())\n            return false;\n        Bvals.erase(Bvals.lower_bound(A[j]+A[N-1]));\n    }\n\n    return true;\n}\n\nint main(){\n    scanf("%d", &N);\n    M = N*(N-1)/2;\n    for(int i = 0; i < M; i++)\n        scanf("%lld", &B[i]);\n    sort(B, B+M);\n\n    for(int i = 1; i < M; i++){\n        ll a0 = (B[0] + B[1] - B[i])/2;\n        if(1 <= a0 && a0 <= B[0]/2 && check(a0)){\n            for(int j = 0; j < N; j++)\n                printf("%lld%c", A[j], (" \\n")[j==N-1]);\n            return 0;\n        }\n    }\n\n    printf("IMPOSSIBLE\\n");\n}',
//   "2415":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 5001;\nconst ll MOD = 1e9+7;\n\nint N;\nll pown[maxN], fac[maxN], inv[maxN], S[maxN][maxN];\n\nll inverse(ll x){\n    ll res = 1;\n    ll b = MOD-2;\n    while(b){\n        if(b&1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid init_powers(){\n    pown[0] = 1;\n    for(int i = 1; i < maxN; i++)\n        pown[i] = (pown[i-1] * N) % MOD;\n}\n\nvoid init_choose(){\n    fac[0] = inv[0] = 1;\n    for(int i = 1; i < maxN; i++){\n        fac[i] = (fac[i-1] * i) % MOD;\n        inv[i] = inverse(fac[i]);\n    }\n}\n\nvoid init_stirling(){\n    S[1][1] = 1;\n    for(int n = 2; n < maxN; n++)\n        for(int k = 1; k <= n; k++)\n            S[n][k] = (S[n-1][k-1] - (n-1) * S[n-1][k]) % MOD;\n}\n\nll choose(int n, int k){\n    if(k < 0 || k > n)  return 0;\n    return fac[n] * inv[k] % MOD * inv[n-k] % MOD;\n}\n\nll stirling1(int n, int k){\n    return abs(S[n][k]);\n}\n\nll T(int n, int k){\n    ll sum = 0;\n    for(int j = 0; j <= n-1; j++){\n        ll a = choose(n-1, j);\n        ll b = pown[n-1-j];\n        ll c = stirling1(j+1, k);\n        sum += a * b % MOD * c % MOD;\n        sum %= MOD;\n    }\n    return sum;\n}\n\nint main(){\n    scanf("%d", &N);\n    init_powers();\n    init_choose();\n    init_stirling();\n    for(int k = 1; k <= N; k++)\n        printf("%lld\\n", T(N, k));\n}',
//   "2416":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5+1;\nconst int SIZE = 4*maxN;\n\nint N, Q, lo[SIZE], hi[SIZE];\nll a[maxN], ass[SIZE], mx[SIZE], sm[SIZE], ans[maxN];\nvector<pii> queries[maxN];\n\nint len(int i){\n    return hi[i]-lo[i]+1;\n}\n\nvoid assign(int i, ll val){\n    ass[i] = mx[i] = val;\n    sm[i] = val * len(i);\n}\n\nvoid push(int i){\n    if(ass[i]){\n        assign(2*i, ass[i]);\n        assign(2*i+1, ass[i]);\n        ass[i] = 0;\n    }\n}\n\nvoid pull(int i){\n    sm[i] = sm[2*i] + sm[2*i+1];\n    mx[i] = max(mx[2*i], mx[2*i+1]);\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        sm[i] = a[l];\n        return;\n    }\n    int m = (l+r)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid update(int i, int l, int r, ll val){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        assign(i, val);\n        return;\n    }\n\n    push(i);\n    update(2*i, l, r, val);\n    update(2*i+1, l, r, val);\n    pull(i);\n}\n\nint orderOf(int i, int l, int val){\n    if(lo[i] == hi[i])                  return lo[i];\n    push(i);\n    int idx = -1;\n    if(hi[2*i] <= l || mx[2*i] < val)   idx = orderOf(2*i+1, l, val);\n    else                                idx = orderOf(2*i, l, val);\n    pull(i);\n    return idx;\n}\n\nll sum(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])      return 0;\n    if(l <= lo[i] && hi[i] <= r)    return sm[i];\n\n    push(i);\n    ll left = sum(2*i, l, r);\n    ll right = sum(2*i+1, l, r);\n    pull(i);\n\n    return left+right;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++)\n        scanf("%lld", &a[i]);\n\n    init(1, 1, N);\n    for(int q = 0, l, r; q < Q; q++){\n        scanf("%d %d", &l, &r);\n        queries[l].push_back({r, q});\n    }\n\n    for(int i = 2; i <= N; i++) a[i] += a[i-1];\n    for(int l = N; l >= 1; l--){\n        int val = a[l]-a[l-1];\n        int modifyR = (mx[1] < val ? N+1 : orderOf(1, l, val));\n        update(1, l, modifyR-1, val);\n        for(pii q : queries[l]){\n            int r = q.first;\n            int id = q.second;\n            ans[id] = sum(1, l, r) - (a[r]-a[l-1]);\n        }\n    }\n\n    for(int i = 0; i < Q; i++)\n        printf("%lld\\n", ans[i]);\n}\n',
//   "2417":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxX = 1e6+1;\n\nll ans;\nint N, dp[maxX];\nbool b[maxX];\nvector<int> primes;\n\nvoid init(){\n    fill(b+2, b+maxX, true);\n    for(int i = 2; i*i < maxX; i++)\n        if(b[i])\n            for(int j = i*i; j < maxX; j += i)\n                b[j] = false;\n    for(int i = 2; i < maxX; i++)\n        if(b[i])\n            primes.push_back(i);\n}\n\nvoid compute(int x){\n    vector<int> pf;\n    for(int p : primes){\n        if(x == 1)  break;\n        else if(b[x]){\n            pf.push_back(x);\n            break;\n        }\n\n        if(x % p)   continue;\n        pf.push_back(p);\n        while(x % p == 0)\n            x /= p;\n    }\n\n    int K = (int) pf.size();\n    for(int mask = 0; mask < (1<<K); mask++){\n        int mu = 1;\n        for(int i = 0; i < K; i++)\n            if(mask&(1<<i))\n                mu *= pf[i];\n\n        int k = __builtin_popcount(mask);\n        ans += (k&1 ? -dp[mu] : dp[mu]);\n        dp[mu]++;\n    }\n}\n\nint main(){\n    init();\n    scanf("%d", &N);\n    for(int i = 0, x; i < N; i++){\n        scanf("%d", &x);\n        compute(x);\n    }\n    printf("%lld\\n", ans);\n}',
//   "2419":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\n\nint N, D, a, xum;\n\nint two_divisibility(int x){\n    int res = 0;\n    while(x){\n        x >>= 1;\n        res += x;\n    }\n    return res;\n}\n\nint main(){\n    scanf("%d", &N);\n    D = two_divisibility(N-1);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &a);\n        int d1 = two_divisibility(i);\n        int d2 = two_divisibility(N-i-1);\n        if(D - d1 - d2 == 0)\n            xum ^= a;\n    }\n    printf("%d\\n", xum);\n}\n',
//   "2420":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\nconst ll p[2] = {31, 37};\nconst int maxN = 2e5+5;\n\nchar S[maxN];\nint N, K;\nll pows[2][maxN], invs[2][maxN], F[2], B[2], ds[2][2][maxN];\n\nll inverse(ll x){\n    ll res = 1;\n    ll b = MOD-2;\n    while(b){\n        if(b&1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid update(int pt, int t, int idx, ll val){\n    val %= MOD; val += MOD; val %= MOD;\n    for(int i = idx+1; i < maxN; i += -i&i)\n        ds[pt][t][i] = (ds[pt][t][i] + val) % MOD;\n}\n\nll query(int pt, int t, int idx){\n    if(idx < 0) return 0;\n    ll sum = 0;\n    for(int i = idx+1; i > 0; i -= -i&i)\n        sum = (sum + ds[pt][t][i]) % MOD;\n    return sum;\n}\n\nvoid init(){\n    for(int t = 0; t < 2; t++){\n        pows[t][0] = invs[t][0] = 1;\n        for(int i = 1; i < maxN; i++){\n            pows[t][i] = (pows[t][i-1] * p[t]) % MOD;\n            invs[t][i] = inverse(pows[t][i]);\n        }\n        update(t, 0, 0, (int) (S[0]-\'a\'+1) * pows[t][N-1]);\n        update(t, 1, 0, (int) (S[0]-\'a\'+1));\n        for(int i = 1; i < N; i++){\n            int c = (int) (S[i]-\'a\'+1);\n            update(t, 0, i, c * pows[t][N-i-1]);\n            update(t, 1, i, c * pows[t][i]);\n        }\n    }\n}\n\nvoid modify(int a, char c){\n    int newchar = (int) (c - \'a\' + 1);\n    int oldchar = (int) (S[a] - \'a\' + 1);\n    for(int t = 0; t < 2; t++){\n        update(t, 0, a, -oldchar * pows[t][N-a-1]);\n        update(t, 0, a, newchar * pows[t][N-a-1]);\n        update(t, 1, a, -oldchar * pows[t][a]);\n        update(t, 1, a, newchar * pows[t][a]);\n    }\n    S[a] = c;\n}\n\nbool palindrome(int a, int b){\n    for(int t = 0; t < 2; t++){\n        F[t] = (query(t, 0, b) - query(t, 0, a-1) + MOD) % MOD;\n        F[t] = (F[t] * invs[t][N-b-1]) % MOD;\n        B[t] = (query(t, 1, b) - query(t, 1, a-1) + MOD) % MOD;\n        B[t] = (B[t] * invs[t][a]) % MOD;\n    }\n    return F[0] == B[0] && F[1] == B[1];\n}\n\nint main(){\n    scanf("%d %d %s", &N, &K, S);\n\n    init();\n    for(int i = 0, t, a, b; i < K; i++){\n        char c;\n        scanf("%d", &t);\n        if(t == 1){\n            scanf("%d %c", &a, &c);\n            modify(a-1, c);\n        } else if(t == 2){\n            scanf("%d %d", &a, &b);\n            printf("%s\\n", palindrome(a-1, b-1) ? "YES" : "NO");\n        }\n    }\n}',
//   "2422":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nll N;\n\nll f(ll x){\n    ll cnt = 0;\n    for(ll i = 1; i <= N; i++)\n        cnt += min(N, x/i);\n    return cnt;\n}\n\nint main(){\n    scanf("%lld", &N);\n    ll lo = 0, hi = N*N;\n    while(hi-lo > 1){\n        ll mid = lo + (hi-lo)/2;\n        if(f(mid) < (N*N+1)/2)  lo = mid;\n        else                    hi = mid;\n    }\n    printf("%lld\\n", lo+1);\n}\n',
//   "2425":
//     "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1, SIZE = 4*maxN;\nconst int INF = 0x3f3f3f3f;\n\nint N, lo[SIZE], hi[SIZE], delta[SIZE], mx[SIZE], mn[SIZE];\n\nvoid push(int i){\n    if(delta[i] != 0){\n        delta[2*i] += delta[i];\n        delta[2*i+1] += delta[i];\n        delta[i] = 0;\n    }\n}\n\nvoid pull(int i){\n    mn[i] = min(mn[2*i]+delta[2*i], mn[2*i+1]+delta[2*i+1]);\n    mx[i] = max(mx[2*i]+delta[2*i], mx[2*i+1]+delta[2*i+1]);\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r)  return;\n    int m = l+(r-l)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid increment(int i, int l, int r, int v){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        delta[i] += v; return;\n    }\n\n    push(i);\n    increment(2*i, l, r, v);\n    increment(2*i+1, l, r, v);\n    pull(i);\n}\n\nint minimum(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])      return INF;\n    if(l <= lo[i] && hi[i] <= r)    return mn[i]+delta[i];\n\n    push(i);\n    int lmin = minimum(2*i, l, r);\n    int rmin = minimum(2*i+1, l, r);\n    pull(i);\n\n    return min(lmin, rmin);\n}\n\nint maximum(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])      return -INF;\n    if(l <= lo[i] && hi[i] <= r)    return mx[i]+delta[i];\n\n    push(i);\n    int lmax = maximum(2*i, l, r);\n    int rmax = maximum(2*i+1, l, r);\n    pull(i);\n\n    return max(lmax, rmax);\n}\n\nvoid place_coin(int c, int s){\n    int v = (s == 1 ? -1 : 1);\n    increment(1, 1, c, v);\n}\n\nchar query_stacks(){\n    int totmin = minimum(1, 1, N);\n    int totmax = maximum(1, 1, N);\n    if(totmin >= 0 && totmax <= 0)  return '?';\n    else if(totmin >= 0)            return '<';\n    else if(totmax <= 0)            return '>';\n    else                            return '?';\n}\n\nint main(){\n    scanf(\"%d\", &N);\n    init(1, 1, N);\n    for(int i = 0, c, s; i < N; i++){\n        scanf(\"%d %d\", &c, &s);\n        place_coin(c, s);\n        printf(\"%c\\n\", query_stacks());\n    }\n}",
//   "2426":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5+5;\n\nint N, A, B;\npii cand[maxN];\n\nmultiset<int> initial_artist_set(){\n    vector<int> all;\n    for(int i = A; i < N; i++)\n        all.push_back(cand[i].second);\n    sort(all.begin(), all.end());\n\n    reverse(all.begin(), all.end());\n    multiset<int> best;\n    for(int i = 0; i < B; i++)\n        best.insert(all[i]);\n    return best;\n}\n\nint main(){\n    scanf("%d %d %d", &A, &B, &N);\n    for(int i = 0, x, y; i < N; i++){\n        scanf("%d %d", &x, &y);\n        cand[i] = {x, y};\n    }\n    sort(cand, cand+N, [](const pii a, const pii b){\n        return a.first == b.first ? a.second < b.second : a.first > b.first;\n    });\n\n    ll pref = 0;\n    priority_queue<int> prefix_deltas;\n    for(int i = 0; i < A; i++){\n        pref += cand[i].first;\n        prefix_deltas.push(cand[i].second - cand[i].first);\n    }\n\n    multiset<int> remaining_art = initial_artist_set();\n    ll suf = accumulate(remaining_art.begin(), remaining_art.end(), 0LL);\n\n    ll ans = pref + suf;\n    for(int i = A; i < A+B; i++){\n        const int x = cand[i].first;\n        const int y = cand[i].second;\n        pref += x;\n\n        prefix_deltas.push(y - x);\n        pref += prefix_deltas.top();\n        prefix_deltas.pop();\n\n        auto worst_artist = remaining_art.lower_bound(y);\n        int art_value = *worst_artist;\n        remaining_art.erase(worst_artist);\n        suf -= art_value;\n\n        ans = max(ans, pref + suf);\n    }\n    printf("%lld\\n", ans);\n}\n',
//   "2428":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+5;\n\nint N, K, x[maxN];\nmap<int,int> freq;\nll ans;\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &x[i]);\n\n    int unique = 0;\n    int r = 0;\n    for(int l = 1; l <= N; l++){\n        while(r < N && (freq[x[r+1]] >= 1 || unique < K)){\n            r++;\n            freq[x[r]]++;\n            if(freq[x[r]] == 1)\n                unique++;\n        }\n\n        ans += (r-l+1);\n\n        freq[x[l]]--;\n        if(!freq[x[l]])\n            unique--;\n    }\n\n    printf("%lld\\n", ans);\n}\n',
//   "2429":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\nconst int maxN = 505;\n\nint N, p[maxN], q[maxN], C[6];\nbool inp[maxN], inq[maxN];\nchar S[maxN];\nll fact[maxN], inv[maxN];\n\nll inverse(ll x){\n    ll res = 1;\n    ll b = MOD-2;\n    while(b){\n        if(b&1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll choose(int x, int y){\n    return (fact[x] * inv[y] % MOD) * inv[x-y] % MOD;\n}\n\nvoid init(){\n    fact[0] = inv[0] = 1;\n    for(int i = 1; i <= N; i++){\n        fact[i] = (fact[i-1] * i) % MOD;\n        inv[i] = (inv[i-1] * inverse(i)) % MOD;\n    }\n}\n\nll f(int i, int j, int k){\n    ll res = (choose(C[0], i)\n            * choose(C[1], j) % MOD\n            * choose(C[2], k) % MOD\n            * choose(C[3], i) % MOD);\n\n    res = (res * fact[i] % MOD\n               * fact[C[4]-i-j] % MOD\n               * fact[C[5]-i-k] % MOD);\n\n    if((i+j+k) % 2 == 1)\n        res = (MOD - res);\n\n    return res;\n}\n\nint main(){\n    scanf("%d", &N);\n    init();\n    for(int i = 0; i < N; i++){\n        scanf(" %s", S);\n        p[i] = q[i] = -1;\n        for(int j = 0; j < N; j++){\n            if(S[j] == \'A\') { p[i] = j; inp[j] = true; }\n            if(S[j] == \'B\') { q[i] = j; inq[j] = true; }\n        }\n    }\n\n    for(int i = 0; i < N; i++){\n        if(p[i] == -1 && q[i] == -1)                C[0]++;\n        if(p[i] == -1 && q[i] != -1 && !inp[q[i]])  C[1]++;\n        if(p[i] != -1 && q[i] == -1 && !inq[p[i]])  C[2]++;\n    }\n\n    for(int i = 0; i < N; i++){\n        if(!inp[i] && !inq[i])  C[3]++;\n        if(!inp[i])             C[4]++;\n        if(!inq[i])             C[5]++;\n    }\n\n    ll ans = 0;\n    for(int i = 0; i <= min(C[0], C[3]); i++)\n        for(int j = 0; j <= C[1]; j++)\n            for(int k = 0; k <= C[2]; k++)\n                ans = (ans + f(i, j, k)) % MOD;\n    printf("%lld\\n", ans);\n}',
//   "2431":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint Q;\nll K;\n\nll pow10(int x){\n    ll res = 1;\n    for(int i = 0; i < x; i++)\n        res *= 10;\n    return res;\n}\n\nint solve(ll N){\n    if(N < 9)   return (int) N+1;\n\n    int len = 1;\n    while(9 * pow10(len-1) * len < N){\n        N -= 9 * pow10(len-1) * len;\n        len++;\n    }\n\n    string S = to_string(pow10(len-1) + N/len);\n    return (int) (S[N%len] - \'0\');\n}\n\nint main(){\n    scanf("%d", &Q);\n    for(int q = 0; q < Q; q++){\n        scanf("%lld", &K);\n        printf("%d\\n", solve(K-1));\n    }\n}',
//   "2432":
//     '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 105, maxM = 2605;\nconst int INF = 0x3f3f3f3f;\n\nint N, rowTot, colTot, edgeID, p[maxN], cap[maxN][maxN];\nbool vis[maxM];\nvector<int> path, F[maxN];\nvector<pii> G[maxN];\n\nint bfs(int s = 0, int t = 2*N+1){\n    fill(p, p+2*N+2, -1);\n    p[s] = -2;\n\n    queue<pii> Q;\n    Q.push({s, INF});\n    while(!Q.empty()){\n        int u = Q.front().first;\n        int f = Q.front().second;\n        Q.pop();\n\n        for(int v : F[u]){\n            if(p[v] == -1 && cap[u][v]){\n                p[v] = u;\n                int aug = min(f, cap[u][v]);\n                if(v == t)  return aug;\n                Q.push({v, aug});\n            }\n        }\n    }\n\n    return 0;\n}\n\nvoid dfs(int u = 0){\n    path.push_back(u);\n    if(u == N)  return;\n    for(pii e : G[u]){\n        int v = e.first;\n        int id = e.second;\n        if(cap[u][v] == 0 && !vis[id]){\n            vis[id] = true;\n            dfs(v);\n            return;\n        }\n    }\n}\n\nint maxflow(int s = 0, int t = 2*N+1){\n    int flow = 0, aug = 0;\n    while(aug = bfs()){\n        flow += aug;\n        int u = t;\n        while(u != s){\n            int v = p[u];\n            cap[v][u] -= aug;\n            cap[u][v] += aug;\n            u = v;\n        }\n    }\n    return flow;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1, c; i <= N; i++){\n        scanf("%d", &c);\n        G[0].push_back({i, ++edgeID});\n        F[0].push_back(i);\n        F[i].push_back(0);\n        cap[0][i] += c;\n        rowTot += c;\n    }\n    for(int i = N+1, c; i <= 2*N; i++){\n        scanf("%d", &c);\n        G[i].push_back({2*N+1, ++edgeID});\n        F[i].push_back(2*N+1);\n        F[2*N+1].push_back(i);\n        cap[i][2*N+1] += c;\n        colTot += c;\n    }\n    for(int i = 1; i <= N; i++){\n        for(int j = N+1; j <= 2*N; j++){\n            G[i].push_back({j, ++edgeID});\n            F[i].push_back(j);\n            F[j].push_back(i);\n            cap[i][j]++;\n        }\n    }\n\n    int K = maxflow();\n    if(rowTot != colTot || K != rowTot){\n        printf("-1\\n");\n        return 0;\n    }\n\n    for(int i = 1; i <= N; i++){\n        for(int j = 1; j <= N; j++)\n            printf("%c", (cap[i][j+N] ? \'.\' : \'X\'));\n        printf("\\n");\n    }\n}',
// };
const solutions: Record<string, string> = {
  "1068":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long N;\n\nint main(){\n    scanf("%lld", &N);\n    while(N > 1){\n        printf("%lld ", N);\n        if(N&1) N = 3*N+1;\n        else    N >>= 1;\n    }\n    printf("1\\n");\n}\n',
  "1069":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6+5;\n\nchar S[maxN];\nint N, cur, best;\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n    cur = best = 1;\n    for(int i = 1; i < N; i++){\n        if(S[i] == S[i-1])  cur++;\n        else                cur = 1;\n        best = max(best, cur);\n    }\n    printf("%d\\n", best);\n}\n',
  "1070":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\n\nint main(){\n    scanf("%d", &N);\n    if(N == 1)      printf("1 ");\n    else if(N <= 3) printf("NO SOLUTION\\n");\n    else {\n        for(int i = 2; i <= N; i += 2)\n            printf("%d ", i);\n        for(int i = 1; i <= N; i += 2)\n            printf("%d ", i);\n    }\n}\n',
  "1071":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint T;\nll X, Y;\n\nll solve(ll x, ll y){\n    ll l = max(x, y)-1;\n    if(l&1){\n        if(x < y)   return l*l + x;\n        else        return l*l+2*l-y+2;\n    } else {\n        if(x < y)   return l*l+2*l-x+2;\n        else        return l*l + y;\n    }\n}\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        scanf("%lld %lld", &X, &Y);\n        printf("%lld\\n", solve(X, Y));\n    }\n}\n',
  "1072":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\n\nint main(){\n    scanf("%d", &N);\n    for(int k = 1; k <= N; k++){\n        ll cnt = 1LL + (k-1)*(k-2)/2;\n        cnt = cnt * (k-1) * (k+4);\n        printf("%lld\\n", cnt);\n    }\n}\n',
  "1073":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, k;\nmultiset<int> S;\nmultiset<int>::iterator it;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &k);\n        it = S.upper_bound(k);\n        if(it != S.end())\n            S.erase(it);\n        S.insert(k);\n    }\n    printf("%d\\n", (int) S.size());\n}\n',
  "1074":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, p[maxN];\nll median, sum;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &p[i]);\n    sort(p, p+N);\n\n    median = p[(N-1)/2];\n    for(int i = 0; i < N; i++)\n        sum += abs(p[i]-median);\n    printf("%lld\\n", sum);\n}\n',
  "1075":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1000;\nconst ll MOD = 1e9+7;\n\nint N;\nll dp[maxN+1];\n\nvoid init(){\n    dp[0] = dp[1] = 1;\n    dp[2] = dp[3] = 0;\n    for(int i = 4; i <= maxN; i++){\n        ll a = (i+1) * dp[i-1] % MOD;\n        ll b = (i-2) * dp[i-2] % MOD;\n        ll c = (i-5) * dp[i-3] % MOD;\n        ll d = (i-3) * dp[i-4] % MOD;\n\n        dp[i] = (a-b-c+d);\n        while(dp[i] < 0)\n            dp[i] += MOD;\n        dp[i] %= MOD;\n    }\n}\n\nint main(){\n    init();\n    scanf("%d", &N);\n    printf("%lld\\n", dp[N]);\n}\n',
  "1076":
    '#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5;\n\nint N, K, x[maxN];\ntree<pii, null_type, less<pii>, rb_tree_tag,\ntree_order_statistics_node_update> T;\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 0; i < K; i++){\n        scanf("%d", &x[i]);\n        T.insert({x[i], i});\n    }\n\n    printf("%d%c", (*T.find_by_order((K-1)/2)).first, (" \\n")[N==K]);\n    for(int i = K; i < N; i++){\n        scanf("%d", &x[i]);\n        T.insert({x[i], i});\n        T.erase({x[i-K], i-K});\n        printf("%d%c", (*T.find_by_order((K-1)/2)).first, (" \\n")[i==N-1]);\n    }\n}\n',
  "1077":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, K, x[maxN];\nll losum, hisum;\nmultiset<int> lo, hi;\n\nll cost(){\n    ll median = *lo.rbegin();\n    ll locost = (median * lo.size()) - losum;\n    ll hicost = hisum - (median * hi.size());\n    return locost + hicost;\n}\n\nvoid lowToHigh(){\n    ll val = *lo.rbegin();\n    lo.erase(lo.lower_bound(val));\n    hi.insert(val);\n    losum -= val;\n    hisum += val;\n}\n\nvoid highToLow(){\n    ll val = *hi.begin();\n    lo.insert(val);\n    hi.erase(hi.lower_bound(val));\n    losum += val;\n    hisum -= val;\n}\n\nvoid adjust(){\n    int tot = (int) (lo.size() + hi.size());\n    if(lo.size() < (tot+1)/2)       highToLow();\n    else if(lo.size() > (tot+1)/2)  lowToHigh();\n}\n\nvoid erase(ll val){\n    ll median = *lo.rbegin();\n    if(val > median){\n        hi.erase(hi.lower_bound(val));\n        hisum -= val;\n    } else {\n        lo.erase(lo.lower_bound(val));\n        losum -= val;\n    }\n    adjust();\n}\n\nvoid insert(ll val){\n    if(lo.size() == 0){\n        lo.insert(val);\n        losum += val;\n        return;\n    }\n\n    ll median = *lo.rbegin();\n    if(val > median){\n        hi.insert(val);\n        hisum += val;\n    } else {\n        lo.insert(val);\n        losum += val;\n    }\n    adjust();\n}\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 0; i < K; i++){\n        scanf("%d", &x[i]);\n        insert(x[i]);\n    }\n\n    printf("%lld%c", cost(), (" \\n")[K==N]);\n    for(int i = K; i < N; i++){\n        scanf("%d", &x[i]);\n        insert(x[i]);\n        erase(x[i-K]);\n        printf("%lld%c", cost(), (" \\n")[i==N-1]);\n    }\n}',
  "1078":
    "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 7;\n\nint ans;\nchar c[N*N+1];\nbool vis[N+1][N+1];\n\nbool inbounds(int x, int y){\n    return 1 <= x && x <= N && 1 <= y && y <= N;\n}\n\nvoid dfs(int x, int y, int i){\n    if(i == N*N-1 || (x == N && y == 1)){\n        ans += (i == N*N-1 && (x == N && y == 1));\n        return;\n    }\n\n    if((!inbounds(x+1, y) || vis[x+1][y]) && (!inbounds(x-1, y) || vis[x-1][y]))\n        if(inbounds(x, y-1) && !vis[x][y-1] && inbounds(x, y+1) && !vis[x][y+1])\n            return;\n    if((!inbounds(x, y+1) || vis[x][y+1]) && (!inbounds(x, y-1) || vis[x][y-1]))\n        if(inbounds(x+1, y) && !vis[x+1][y] && inbounds(x-1, y) && !vis[x-1][y])\n            return;\n\n    vis[x][y] = true;\n    if(c[i] == 'D' || c[i] == '?')\n        if(inbounds(x+1, y) && !vis[x+1][y])\n            dfs(x+1, y, i+1);\n    if(c[i] == 'U' || c[i] == '?')\n        if(inbounds(x-1, y) && !vis[x-1][y])\n            dfs(x-1, y, i+1);\n    if(c[i] == 'R' || c[i] == '?')\n        if(inbounds(x, y+1) && !vis[x][y+1])\n            dfs(x, y+1, i+1);\n    if(c[i] == 'L' || c[i] == '?')\n        if(inbounds(x, y-1) && !vis[x][y-1])\n            dfs(x, y-1, i+1);\n    vis[x][y] = false;\n}\n\nint main(){\n    scanf(\" %s\", c);\n    dfs(1, 1, 0);\n    printf(\"%d\\n\", ans);\n}\n",
  "1079":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxA = 1e6;\nconst ll MOD = 1e9+7;\n\nint N, a, b;\nll fact[maxA+1], inv[maxA+1];\n\nll inverse(ll x){\n    ll res = 1;\n    ll expo = MOD-2;\n    while(expo > 0){\n        if(expo&1)\n            res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        expo >>= 1;\n    }\n    return res;\n}\n\nvoid init(){\n    fact[0] = inv[0] = 1;\n    for(int i = 1; i <= maxA; i++){\n        fact[i] = i * fact[i-1] % MOD;\n        inv[i] = inverse(fact[i]);\n    }\n}\n\nint main(){\n    init();\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d %d", &a, &b);\n        printf("%lld\\n", fact[a] * inv[b] % MOD * inv[a-b] % MOD);\n    }\n}\n',
  "1080":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 505;\nconst ll MOD = 1e9+7;\n\nint N;\nchar S[maxN];\nll fac[maxN], inv[maxN], dp[maxN][maxN];\n\nll fastpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n        if(b&1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll choose(int n, int k){\n    if(k < 0 || n < k)  return 0;\n    return fac[n] * inv[k] % MOD * inv[n-k] % MOD;\n}\n\nvoid init(){\n    fac[0] = inv[0] = 1;\n    for(int i = 1; i < maxN; i++){\n        fac[i] = (fac[i-1] * i) % MOD;\n        inv[i] = fastpow(fac[i], MOD-2);\n    }\n\n    for(int i = 0; i < maxN; i++)\n        for(int j = i; j < maxN; j++)\n            dp[i][j] = -1;\n}\n\nll solve(int l, int r){\n    if((r-l+1)&1)       return 0;\n    if(l > r)           return 1;\n    if(dp[l][r] != -1)  return dp[l][r];\n\n    ll cnt = 0;\n    for(int m = l+1; m <= r; m++){\n        if(S[l] == S[m]){\n            ll subcases = solve(l+1, m-1) * solve(m+1, r) % MOD;\n            ll aftercombine = subcases * choose((r-l+1)/2, (m-l+1)/2) % MOD;\n            cnt = (cnt + aftercombine) % MOD;\n        }\n    }\n\n    return dp[l][r] = cnt;\n}\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n    init();\n    printf("%lld\\n", N&1 ? 0 : solve(0, N-1));\n}',
  "1081":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxX = 1e6;\n\nint N, a, cnt, d[maxX+1];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &a);\n        d[a]++;\n    }\n    for(int i = maxX; i >= 1; i--){\n        cnt = 0;\n        for(int j = i; j <= maxX; j += i)\n            cnt += d[j];\n        if(cnt >= 2){\n            printf("%d\\n", i);\n            return 0;\n        }\n    }\n}\n',
  "1082":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nll N, sum;\n\nll sigma(ll x){\n    return ((x%MOD)*((x+1)%MOD)/2)%MOD;\n}\n\nint main(){\n    scanf("%lld", &N);\n    for(ll l = 1; l <= N; l++){\n        ll r = N/(N/l);\n        sum += (N/l)%MOD*(sigma(r)-sigma(l-1)+MOD)%MOD;\n        sum = (sum+MOD)%MOD;\n        l = r;\n    }\n    printf("%lld\\n", sum);\n}\n',
  "1083":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, x, xum;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++)\n        xum ^= i;\n    for(int i = 0; i < N-1; i++){\n        scanf("%d", &x);\n        xum ^= x;\n    }\n    printf("%d\\n", xum);\n}\n',
  "1084":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, M, K, a[maxN], b[maxN];\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n    for(int i = 0; i < N; i++)  scanf("%d", &a[i]);\n    for(int i = 0; i < M; i++)  scanf("%d", &b[i]);\n\n    sort(a, a+N);\n    sort(b, b+M);\n\n    int cnt = 0;\n    int aptr = 0, bptr = 0;\n    while(aptr < N){\n        while(bptr < M && b[bptr] < a[aptr]-K)  bptr++;\n        if(bptr < M && a[aptr]-K <= b[bptr] && b[bptr] <= a[aptr]+K){\n            cnt++;\n            aptr++;\n            bptr++;\n        } else aptr++;\n    }\n    printf("%d\\n", cnt);\n}\n',
  "1085":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, K, a[maxN];\nll lo = 0, hi = 1e18;\n\nbool check(ll X){\n    int k = 1;\n    ll sum = 0;\n    for(int i = 0; i < N; i++){\n        sum += a[i];\n        if(sum > X){\n            k++;\n            sum = a[i];\n        }\n    }\n    return k <= K;\n}\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &a[i]);\n        lo = max(lo, (ll) a[i]);\n    }\n\n    while(lo <= hi){\n        ll mid = lo + (hi-lo)/2;\n        if(check(mid))  hi = mid-1;\n        else            lo = mid+1;\n    }\n    printf("%lld\\n", lo);\n}\n',
  "1086":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nll p[19];\n\nvoid init(){\n    p[0] = 1;\n    for(int i = 1; i <= 18; i++)\n        p[i] = p[i-1] * 10;\n}\n\nll check(ll N){\n    ll cnt = 0, l = N, r = 0;\n    for(int i = 0; l; i++){\n        int d = l % 10;\n        l /= 10;\n        cnt += (d == 1 ? l*p[i]+r+1 : (l+(d!=0))*p[i]);\n        r += p[i] * d;\n    }\n    return cnt;\n}\n\nint main(){\n    ll K;\n    scanf("%lld", &K);\n    ll lo = 1, hi = 1e18;\n    init();\n    while(hi-lo > 1){\n        ll mid = lo+(hi-lo)/2;\n        if(check(mid) <= K) lo = mid;\n        else                hi = mid;\n    }\n    printf("%lld\\n", lo);\n}',
  "1087":
    "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6+5;\n\nint N, cnt;\nchar S[maxN], ch[4] = {'A', 'C', 'G', 'T'};\nbool has[4];\nvector<int> segs;\nmap<char,int> mp;\n\nvoid init(){\n    mp['A'] = 0;\n    mp['C'] = 1;\n    mp['G'] = 2;\n    mp['T'] = 3;\n}\n\nint main(){\n    init();\n    scanf(\" %s\", S);\n\n    N = (int) strlen(S);\n    for(int i = 0; i < N; i++){\n        int c = mp[S[i]];\n        if(!has[c]){\n            has[c] = true;\n            cnt++;\n            if(cnt == 4){\n                fill(has, has+4, false);\n                segs.push_back(i);\n                cnt = 0;\n            }\n        }\n    }\n\n    for(int i : segs)\n        printf(\"%c\", S[i]);\n    for(int i = 0; i < 4; i++){\n        if(!has[i]){\n            printf(\"%c\\n\", ch[i]);\n            return 0;\n        }\n    }\n}",
  "1090":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5;\n\nint N, X, l, ans, p[maxN];\n\nint main(){\n    scanf("%d %d", &N, &X);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &p[i]);\n    sort(p, p+N);\n\n    l = 0;\n    for(int r = N-1; r >= l; r--){\n        if(p[l] + p[r] <= X)\n            l++;\n        ans++;\n    }\n    printf("%d\\n", ans);\n}\n',
  "1091":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, h, t;\nmultiset<int> prices;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &h);\n        prices.insert(-h);\n    }\n    for(int i = 0; i < M; i++){\n        scanf("%d", &t);\n        if(prices.lower_bound(-t) == prices.end())\n            printf("-1\\n");\n        else {\n            printf("%d\\n", -(*prices.lower_bound(-t)));\n            prices.erase(prices.lower_bound(-t));\n        }\n    }\n}\n',
  "1092":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\n\nint main(){\n    scanf("%d", &N);\n    if(N%4 == 1 || N%4 == 2)    printf("NO\\n");\n    else if(N%4 == 3){\n        printf("YES\\n");\n        printf("%d\\n", N/2);\n        for(int i = 2; i <= N/2; i += 2)\n            printf("%d %d ", i, N-i);\n        printf("%d\\n%d\\n", N, N/2+1);\n        for(int i = 1; i <= N/2; i += 2)\n            printf("%d %d ", i, N-i);\n    } else {\n        printf("YES\\n");\n        printf("%d\\n", N/2);\n        for(int i = 2; i <= N/2; i += 2)\n            printf("%d %d ", i, N-i+1);\n        printf("\\n%d\\n", N/2);\n        for(int i = 1; i <= N/2; i += 2)\n            printf("%d %d ", i, N-i+1);\n    }\n}\n',
  "1093":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\n/**\n * A058377\n * Retrivied from https://oeis.org/A058377\n */\n\nint N, mp[501];\n\nvoid init(){\n    mp[3] = 1;\n    mp[4] = 1;\n    mp[7] = 4;\n    mp[8] = 7;\n    mp[11] = 35;\n    mp[12] = 62;\n    mp[15] = 361;\n    mp[16] = 657;\n    mp[19] = 4110;\n    mp[20] = 7636;\n    mp[23] = 49910;\n    mp[24] = 93846;\n    mp[27] = 632602;\n    mp[28] = 1199892;\n    mp[31] = 8273610;\n    mp[32] = 15796439;\n    mp[35] = 110826888;\n    mp[36] = 212681976;\n    mp[39] = 512776583;\n    mp[40] = 915017346;\n    mp[43] = 965991877;\n    mp[44] = 536015750;\n    mp[47] = 245739109;\n    mp[48] = 497111739;\n    mp[51] = 319303648;\n    mp[52] = 661531964;\n    mp[55] = 919134122;\n    mp[56] = 526597333;\n    mp[59] = 857860749;\n    mp[60] = 323065127;\n    mp[63] = 142897738;\n    mp[64] = 454622296;\n    mp[67] = 832964922;\n    mp[68] = 112945499;\n    mp[71] = 21130483;\n    mp[72] = 134912852;\n    mp[75] = 58392205;\n    mp[76] = 594756797;\n    mp[79] = 116285762;\n    mp[80] = 46020942;\n    mp[83] = 199311883;\n    mp[84] = 637852081;\n    mp[87] = 681073029;\n    mp[88] = 687587655;\n    mp[91] = 403293621;\n    mp[92] = 859161650;\n    mp[95] = 135570834;\n    mp[96] = 16951659;\n    mp[99] = 90174435;\n    mp[100] = 906443459;\n    mp[103] = 445036292;\n    mp[104] = 696064542;\n    mp[107] = 589938798;\n    mp[108] = 17765238;\n    mp[111] = 671699270;\n    mp[112] = 979144036;\n    mp[115] = 717567569;\n    mp[116] = 962408760;\n    mp[119] = 24874238;\n    mp[120] = 651719820;\n    mp[123] = 882521441;\n    mp[124] = 815306501;\n    mp[127] = 177673311;\n    mp[128] = 381523124;\n    mp[131] = 647107433;\n    mp[132] = 822743471;\n    mp[135] = 951125976;\n    mp[136] = 913762232;\n    mp[139] = 860772858;\n    mp[140] = 718799291;\n    mp[143] = 546548485;\n    mp[144] = 520899315;\n    mp[147] = 348826222;\n    mp[148] = 979465686;\n    mp[151] = 551269897;\n    mp[152] = 226367872;\n    mp[155] = 224237396;\n    mp[156] = 275455845;\n    mp[159] = 597702194;\n    mp[160] = 580526114;\n    mp[163] = 837164670;\n    mp[164] = 579854574;\n    mp[167] = 643888367;\n    mp[168] = 547744591;\n    mp[171] = 362172782;\n    mp[172] = 203753851;\n    mp[175] = 472078730;\n    mp[176] = 414960148;\n    mp[179] = 751350256;\n    mp[180] = 597996235;\n    mp[183] = 302890488;\n    mp[184] = 463389357;\n    mp[187] = 28369705;\n    mp[188] = 625260957;\n    mp[191] = 439010166;\n    mp[192] = 625343710;\n    mp[195] = 345211145;\n    mp[196] = 783212645;\n    mp[199] = 171026155;\n    mp[200] = 746149676;\n    mp[203] = 574908810;\n    mp[204] = 400819234;\n    mp[207] = 797285006;\n    mp[208] = 671068618;\n    mp[211] = 857904807;\n    mp[212] = 118539037;\n    mp[215] = 258515519;\n    mp[216] = 103887197;\n    mp[219] = 692754470;\n    mp[220] = 307691579;\n    mp[223] = 543477917;\n    mp[224] = 494845326;\n    mp[227] = 461141061;\n    mp[228] = 681627336;\n    mp[231] = 194431224;\n    mp[232] = 798222254;\n    mp[235] = 34177070;\n    mp[236] = 324550451;\n    mp[239] = 395144714;\n    mp[240] = 314224734;\n    mp[243] = 256354567;\n    mp[244] = 216295565;\n    mp[247] = 556521816;\n    mp[248] = 594547313;\n    mp[251] = 701665484;\n    mp[252] = 287171616;\n    mp[255] = 305999810;\n    mp[256] = 817725356;\n    mp[259] = 456522567;\n    mp[260] = 42456953;\n    mp[263] = 53352478;\n    mp[264] = 896195082;\n    mp[267] = 374247344;\n    mp[268] = 900048655;\n    mp[271] = 613110673;\n    mp[272] = 91338349;\n    mp[275] = 904876664;\n    mp[276] = 300880501;\n    mp[279] = 604541603;\n    mp[280] = 441166519;\n    mp[283] = 73667549;\n    mp[284] = 41483999;\n    mp[287] = 51276243;\n    mp[288] = 149197976;\n    mp[291] = 539103967;\n    mp[292] = 982253554;\n    mp[295] = 969982399;\n    mp[296] = 98482383;\n    mp[299] = 605461327;\n    mp[300] = 65785519;\n    mp[303] = 548373331;\n    mp[304] = 421491751;\n    mp[307] = 480765781;\n    mp[308] = 925355425;\n    mp[311] = 850819946;\n    mp[312] = 434384766;\n    mp[315] = 747079619;\n    mp[316] = 140715817;\n    mp[319] = 154291092;\n    mp[320] = 436737393;\n    mp[323] = 694334366;\n    mp[324] = 278298264;\n    mp[327] = 100011200;\n    mp[328] = 186925353;\n    mp[331] = 951803656;\n    mp[332] = 826521841;\n    mp[335] = 467206470;\n    mp[336] = 625245512;\n    mp[339] = 37014692;\n    mp[340] = 370302058;\n    mp[343] = 942594593;\n    mp[344] = 625802329;\n    mp[347] = 696810018;\n    mp[348] = 839447903;\n    mp[351] = 973813010;\n    mp[352] = 340829958;\n    mp[355] = 333578000;\n    mp[356] = 162910708;\n    mp[359] = 898163184;\n    mp[360] = 938735258;\n    mp[363] = 969420912;\n    mp[364] = 767331949;\n    mp[367] = 49040853;\n    mp[368] = 864361228;\n    mp[371] = 666086921;\n    mp[372] = 681324453;\n    mp[375] = 406330883;\n    mp[376] = 715350645;\n    mp[379] = 276425302;\n    mp[380] = 691275326;\n    mp[383] = 936153559;\n    mp[384] = 806887794;\n    mp[387] = 672700998;\n    mp[388] = 324056520;\n    mp[391] = 624244157;\n    mp[392] = 887151949;\n    mp[395] = 111928807;\n    mp[396] = 555201478;\n    mp[399] = 892266330;\n    mp[400] = 406976742;\n    mp[403] = 179624853;\n    mp[404] = 766709833;\n    mp[407] = 615024703;\n    mp[408] = 25276943;\n    mp[411] = 675398735;\n    mp[412] = 373735428;\n    mp[415] = 283235362;\n    mp[416] = 613728485;\n    mp[419] = 581407804;\n    mp[420] = 135760574;\n    mp[423] = 421029356;\n    mp[424] = 925084280;\n    mp[427] = 409496848;\n    mp[428] = 345330916;\n    mp[431] = 754684998;\n    mp[432] = 388429454;\n    mp[435] = 997193850;\n    mp[436] = 722803385;\n    mp[439] = 747396848;\n    mp[440] = 879532546;\n    mp[443] = 363180870;\n    mp[444] = 301109892;\n    mp[447] = 337814331;\n    mp[448] = 439172004;\n    mp[451] = 142119927;\n    mp[452] = 761228466;\n    mp[455] = 649629227;\n    mp[456] = 868002592;\n    mp[459] = 927500726;\n    mp[460] = 71856333;\n    mp[463] = 621649641;\n    mp[464] = 86464550;\n    mp[467] = 159973467;\n    mp[468] = 281964303;\n    mp[471] = 220801847;\n    mp[472] = 172221992;\n    mp[475] = 631635476;\n    mp[476] = 30971150;\n    mp[479] = 664722592;\n    mp[480] = 692804591;\n    mp[483] = 620001363;\n    mp[484] = 22371363;\n    mp[487] = 541326371;\n    mp[488] = 8514587;\n    mp[491] = 996643776;\n    mp[492] = 106479414;\n    mp[495] = 920757401;\n    mp[496] = 236457589;\n    mp[499] = 608650075;\n    mp[500] = 71857061;\n}\n\nint main(){\n    init();\n    scanf("%d", &N);\n    printf("%d\\n", mp[N]);\n}\n',
  "1094":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll x, mx, sum;\n\nint main(){\n    scanf("%d", &N);\n    scanf("%lld", &mx);\n    for(int i = 1; i < N; i++){\n        scanf("%lld", &x);\n        mx = max(mx, x);\n        sum += (mx - x);\n    }\n    printf("%lld\\n", sum);\n}\n',
  "1095":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nint N;\nll A, B;\n\nll fastpow(ll a, ll b){\n    ll res = 1;\n    while(b > 0){\n        if(b&1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%lld %lld", &A, &B);\n        printf("%lld\\n", fastpow(A, B));\n    }\n}\n',
  "1096":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nll N, x[6][6], y[6][6];\n\nvoid init(){\n    for(int i = 0; i < 6; i++)\n        x[0][i] = 1;\n    for(int i = 0; i < 5; i++)\n        x[i+1][i] = 1;\n    for(int i = 0; i < 6; i++)\n        y[i][i] = 1;\n}\n\nvoid mult(ll A[6][6], ll B[6][6]){\n    ll C[6][6];\n    memset(C, 0, sizeof(C));\n    for(int i = 0; i < 6; i++){\n        for(int j = 0; j < 6; j++){\n            for(int k = 0; k < 6; k++){\n                C[i][j] += A[i][k] * B[k][j];\n                C[i][j] %= MOD;\n            }\n        }\n    }\n    for(int i = 0; i < 6; i++)\n        for(int j = 0; j < 6; j++)\n            A[i][j] = C[i][j];\n}\n\nint main(){\n    init();\n\n    scanf("%lld", &N);\n    while(N){\n        if(N&1)\n            mult(y, x);\n        mult(x, x);\n        N >>= 1;\n    }\n\n    printf("%lld\\n", y[0][0]);\n}\n',
  "1097":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 5000;\n\nint N, x[maxN+1];\nll p[maxN+1], dp[maxN+1][maxN+1];\nbool found[maxN+1][maxN+1];\n\nll sum(int l, int r){\n\treturn p[r] - p[l-1];\n}\n\nll solve(int l, int r){\n\tif(found[l][r])\treturn dp[l][r];\n\tif(l == r)\t\treturn x[l];\n\tfound[l][r]=true;\n\treturn dp[l][r] = max(x[l]+sum(l+1, r)-solve(l+1, r), x[r]+sum(l,r-1)-solve(l,r-1));\n}\n\nint main(){\n\tscanf("%d", &N);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf("%d", &x[i]);\n\t\tp[i] = p[i-1] + x[i];\n\t}\n\tprintf("%lld\\n", solve(1, N));\n}\n',
  "1098":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T, N, x, xum;\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        scanf("%d", &N);\n        xum = 0;\n        for(int i = 0; i < N; i++){\n            scanf("%d", &x);\n            xum ^= (x%4);\n        }\n        printf(xum ? "first\\n" : "second\\n");\n    }\n}\n',
  "1099":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T, N, p, xum;\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        scanf("%d", &N);\n        xum = 0;\n        for(int i = 0; i < N; i++){\n            scanf("%d", &p);\n            if(i%2)\n                xum ^= p;\n        }\n        printf(xum ? "first\\n" : "second\\n");\n    }\n}\n',
  "1110":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e6+5;\n\nint N, F[maxN];\nchar S[maxN];\n\nint main(){\n    scanf("%s", S);\n\n    N = (int) strlen(S);\n    for(int i = 0; i < N; i++)\n        S[i+N] = S[i];\n\n    N = (int) strlen(S);\n    fill(F, F+N, -1);\n\n    int k = 0;\n    for(int i = 1; i < N; i++){\n        char c = S[i];\n        int f = F[i-k-1];\n        while(f != -1 && c != S[k+f+1]){\n            if(c < S[k+f+1])\n                k = i-f-1;\n            f = F[f];\n        }\n\n        if(c != S[k+f+1]){\n            if(c < S[k])\n                k = i;\n            F[i-k] = -1;\n        } else F[i-k] = f+1;\n    }\n\n    for(int i = 0; i < N/2; i++)\n        printf("%c", S[i+k]);\n}',
  "1111":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6+5;\n\nchar S[maxN];\nint N, bestl, bestr, d1[maxN], d2[maxN];\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n\n    for(int i = 0, l = 0, r = -1; i < N; i++){\n        int k = (i > r ? 1 : min(d1[l+r-i], r-i+1));\n        while(0 <= i-k && i+k < N && S[i-k] == S[i+k])  k++;\n\n        if(2*k-1 > bestr-bestl+1){\n            bestl = i-k+1;\n            bestr = i+k-1;\n        }\n\n        d1[i] = k--;\n        if(i+k > r){\n            l = i-k;\n            r = i+k;\n        }\n    }\n\n    for(int i = 0, l = 0, r = -1; i < N; i++){\n        int k = (i > r ? 0 : min(d2[l+r-i+1], r-i+1));\n        while(0 <= i-k-1 && i+k < N && S[i-k-1] == S[i+k])  k++;\n\n        if(2*k > bestr-bestl+1){\n            bestl = i-k;\n            bestr = i+k-1;\n        }\n\n        d2[i] = k--;\n        if(i+k > r){\n            l = i-k-1;\n            r = i+k;\n        }\n    }\n\n    for(int i = bestl; i <= bestr; i++)\n        printf("%c", S[i]);\n}',
  "1112":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1005, maxM = 505;\nconst ll MOD = 1e9+7;\n\nint N, M, best[26][maxM];\nchar S[maxN];\nll ans, dp[maxM][maxN];\n\nll pow26(ll b){\n    ll a = 26;\n    ll res = 1;\n    while(b){\n        if(b&1) res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nbool good(vector<char> pre, int k){\n    int SZ = (int) pre.size();\n    for(int i = 0; i < SZ-k; i++)\n        if(pre[i+k] != S[i])\n            return false;\n    return true;\n}\n\nint main(){\n    scanf("%d %s", &N, S);\n    M = (int) strlen(S);\n    if(M > N){\n        printf("0\\n");\n        return 0;\n    }\n\n    for(int r = 0; r < M; r++){\n        for(int c = 0; c < 26; c++){\n            vector<char> pre;\n            for(int i = 0; i < r; i++)\n                pre.push_back(S[i]);\n            pre.push_back((char) (c+\'A\'));\n\n            for(int k = 0; k < r+1; k++){\n                if(good(pre, k)){\n                    best[c][r] = r-k+1;\n                    break;\n                }\n            }\n        }\n    }\n\n    dp[0][0] = 1;\n    for(int i = 1; i <= N; i++)\n        for(int j = 0; j < M; j++)\n            for(int c = 0; c < 26; c++)\n                dp[best[c][j]][i] = (dp[best[c][j]][i] + dp[j][i-1]) % MOD;\n\n    ans = pow26(N);\n    for(int i = 0; i < M; i++)\n        ans = (ans - dp[i][N] + MOD) % MOD;\n    printf("%lld\\n", ans);\n}',
  "1113":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6+5;\n\nint N, nxt[maxN];\nchar S[maxN];\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n    for(int i = 0; i < N; i++)  nxt[i] = i;\n    stable_sort(nxt, nxt+N, [](int a, int b){\n        return S[a] < S[b];\n    });\n\n    int ptr = nxt[0];\n    while(ptr != 0){\n        ptr = nxt[ptr];\n        printf("%c", S[ptr]);\n    }\n}',
  "1130":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, a, b, cnt;\nbool used[maxN];\nvector<int> G[maxN];\n\nvoid dfs(int u = 1, int par = 0){\n    for(int v : G[u])\n        if(v != par)\n            dfs(v, u);\n\n    if(!used[par] && !used[u] && par != 0){\n        used[par] = used[u] = true;\n        cnt++;\n    }\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    dfs();\n    printf("%d\\n", cnt);\n}\n',
  "1131":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, a, b, last, dist[maxN];\nvector<int> G[maxN];\n\nvoid dfs(int u, int p = 0){\n    for(int v : G[u]){\n        if(v != p){\n            dist[v] = dist[u]+1;\n            dfs(v, u);\n        }\n    }\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs(1);\n    for(int i = 1; i <= N; i++)\n        if(dist[i] > dist[last])\n            last = i;\n    dist[last] = 0;\n    dfs(last);\n    for(int i = 1; i <= N; i++)\n        if(dist[i] > dist[last])\n            last = i;\n    printf("%d\\n", dist[last]);\n}\n',
  "1132":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, a, b, down[maxN], up[maxN], best[maxN];\nvector<int> G[maxN];\n\nvoid dfs1(int u = 1, int p = 0){\n    for(int v : G[u]){\n        if(v != p){\n            dfs1(v, u);\n            down[u] = max(down[u], down[v]+1);\n        }\n    }\n}\n\nvoid dfs2(int u = 1, int p = 0){\n    int first = 0, second = 0;\n    for(int v : G[u]){\n        if(v != p){\n            if(down[v] >= down[first]){\n                second = first;\n                first = v;\n            } else if(down[v] > down[second]){\n                second = v;\n            }\n        }\n    }\n\n    for(int v : G[u]){\n        if(v != p){\n            up[v] = max(up[v], up[u]+1);\n            if(v == first){\n                if(second != 0){\n                    up[v] = max(up[v], down[second]+2);\n                }\n            } else if(first != 0){\n                up[v] = max(up[v], down[first]+2);\n            }\n            dfs2(v, u);\n        }\n    }\n\n    best[u] = max(up[u], down[u]);\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs1();\n    dfs2();\n\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", best[i], (" \\n")[i==N]);\n}\n',
  "1133":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, a, b, sz[maxN];\nll down[maxN], up[maxN];\nvector<int> G[maxN];\n\nvoid dfs1(int u = 1, int p = 0){\n    sz[u] = 1;\n    for(int v : G[u]){\n        if(v != p){\n            dfs1(v, u);\n            sz[u] += sz[v];\n            down[u] += down[v] + sz[v];\n        }\n    }\n}\n\nvoid dfs2(int u = 1, int p = 0){\n    if(p != 0)\n        up[u] = (up[p]+down[p]) + N - (2*sz[u]+down[u]);\n    for(int v : G[u])\n        if(v != p)\n            dfs2(v, u);\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs1();\n    dfs2();\n\n    for(int i = 1; i <= N; i++)\n        printf("%lld%c", down[i]+up[i], (" \\n")[i==N]);\n}\n',
  "1134":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\n\nint N, a[maxN], deg[maxN];\npriority_queue<int, vector<int>, greater<int>> Q;\n\nint main(){\n    scanf("%d", &N);\n    fill(deg+1, deg+N+1, 1);\n    for(int i = 0; i < N-2; i++){\n        scanf("%d", &a[i]);\n        deg[a[i]]++;\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(deg[i] == 1)\n            Q.push(i);\n\n    for(int i = 0; i < N-2; i++){\n        int u = a[i];\n        int v = Q.top(); Q.pop();\n\n        deg[u]--; deg[v]--;\n        if(deg[u] == 1)\n            Q.push(u);\n\n        printf("%d %d\\n", u, v);\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(deg[i])\n            printf("%d ", i);\n}',
  "1135":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\nconst int logN = 20;\n\nint N, Q, a, b, p[maxN][logN];\nint timer, d[maxN], in[maxN], out[maxN];\nvector<int> G[maxN];\n\nvoid dfs(int u = 1, int par = 1){\n    in[u] = ++timer;\n    d[u] = d[par]+1;\n    p[u][0] = par;\n    for(int i = 1; i < logN; i++)\n        p[u][i] = p[p[u][i-1]][i-1];\n    for(int v : G[u])\n        if(v != par)\n            dfs(v, u);\n    out[u] = ++timer;\n}\n\nbool ancestor(int u, int v){\n    return in[u] <= in[v] && out[u] >= out[v];\n}\n\nint lca(int u, int v){\n    if(ancestor(u, v))  return u;\n    if(ancestor(v, u))  return v;\n    for(int i = logN-1; i >= 0; i--)\n        if(!ancestor(p[u][i], v))\n            u = p[u][i];\n    return p[u][0];\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs();\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &a, &b);\n        printf("%d\\n", d[a] + d[b] - 2*d[lca(a, b)]);\n    }\n}\n',
  "1136":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\nconst int logN = 20;\n\nint N, M, a, b, sub[maxN], p[maxN][logN];\nint timer, in[maxN], out[maxN];\nvector<int> G[maxN];\n\nvoid dfs1(int u = 1, int par = 1){\n    in[u] = ++timer;\n    p[u][0] = par;\n    for(int i = 1; i < logN; i++)\n        p[u][i] = p[p[u][i-1]][i-1];\n    for(int v : G[u])\n        if(v != par)\n            dfs1(v, u);\n    out[u] = ++timer;\n}\n\nvoid dfs2(int u = 1){\n    for(int v : G[u]){\n        if(v != p[u][0]){\n            dfs2(v);\n            sub[u] += sub[v];\n        }\n    }\n}\n\nbool ancestor(int u, int v){\n    return in[u] <= in[v] && out[u] >= out[v];\n}\n\nint lca(int u, int v){\n    if(ancestor(u, v))  return u;\n    if(ancestor(v, u))  return v;\n    for(int i = logN-1; i >= 0; i--)\n        if(!ancestor(p[u][i], v))\n            u = p[u][i];\n    return p[u][0];\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs1();\n\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        int l = lca(a, b);\n        sub[a]++; sub[b]++;\n        sub[l]--;\n        if(l != 1)\n            sub[p[l][0]]--;\n    }\n\n    dfs2();\n\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", sub[i], (" \\n")[i==N]);\n}\n',
  "1137":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, Q, a, b, t, s, timer;\nint in[maxN], out[maxN];\nll k[maxN], ds[2*maxN];\nvector<int> G[maxN];\n\nvoid update(int idx, ll val){\n    for(int i = idx; i < 2*maxN; i += i&-i)\n        ds[i] += val;\n}\n\nll query(int idx){\n    ll sum = 0;\n    for(int i = idx; i > 0; i -= i&-i)\n        sum += ds[i];\n    return sum;\n}\n\nvoid dfs(int u, int p = 0){\n    in[u] = ++timer;\n    for(int v : G[u])\n        if(v != p)\n            dfs(v, u);\n    out[u] = ++timer;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++)\n        scanf("%lld", &k[i]);\n\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    timer = 0;\n    dfs(1);\n\n    for(int i = 1; i <= N; i++)\n        update(out[i], k[i]);\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &t, &s);\n        if(t == 1){\n            update(out[s], -k[s]);\n            scanf("%lld", &k[s]);\n            update(out[s], k[s]);\n        } else if(t == 2){\n            printf("%lld\\n", query(out[s])-query(in[s]));\n        }\n    }\n}\n',
  "1138":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, Q, a, b, t, s;\nint timer, in[maxN], out[maxN];\nll x, v[maxN], ds[2*maxN];\nvector<int> G[maxN];\n\nvoid update(int idx, ll val){\n    for(int i = idx; i <= timer; i += -i&i)\n        ds[i] += val;\n}\n\nll query(int idx){\n    ll sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum += ds[i];\n    return sum;\n}\n\nvoid dfs(int u = 1, int p = 0){\n    in[u] = ++timer;\n    for(int c : G[u])\n        if(c != p)\n            dfs(c, u);\n    out[u] = ++timer;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++)\n        scanf("%lld", &v[i]);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs();\n    for(int i = 1; i <= N; i++){\n        update(in[i], v[i]);\n        update(out[i], -v[i]);\n    }\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &t, &s);\n        if(t == 1){\n            scanf("%lld", &x);\n            update(in[s], -v[s]);\n            update(out[s], v[s]);\n            update(in[s], x);\n            update(out[s], -x);\n            v[s] = x;\n        } else if(t == 2){\n            printf("%lld\\n", query(in[s]));\n        }\n    }\n}\n',
  "1139":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef array<int,3> triple;\nconst int maxN = 2e5+1;\n\nint N, a, b, c[maxN], x[2*maxN], ptr[2*maxN], ds[2*maxN], ans[maxN];\nint timer, in[maxN], out[maxN];\ntriple queries[maxN];\nvector<int> G[maxN];\nmap<int,int> mp;\nset<int> S;\n\nvoid dfs(int u = 1, int p = 0){\n    in[u] = ++ timer;\n    for(int v : G[u])\n        if(v != p)\n            dfs(v, u);\n    out[u] = ++timer;\n}\n\nvoid update(int idx, int val){\n    for(int i = idx; i <= 2*N; i += -i&i)\n        ds[i] += val;\n}\n\nint query(int idx){\n    int sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum += ds[i];\n    return sum;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &c[i]);\n\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    dfs();\n\n    for(int i = 1; i <= N; i++)\n        x[in[i]] = x[out[i]] = c[i];\n\n    for(int i = 2*N; i > 0; i--){\n        if(mp[x[i]])\n            ptr[i] = mp[x[i]];\n        mp[x[i]] = i;\n    }\n\n    for(int i = 1; i <= 2*N; i++){\n        if(S.count(x[i]) == 0)\n            update(i, 1);\n        S.insert(x[i]);\n    }\n\n    for(int i = 1; i <= N; i++)\n        queries[i-1] = {in[i], out[i], i-1};\n    sort(queries, queries+N);\n\n    int l = 1;\n    for(int i = 0; i < N; i++){\n        while(l < queries[i][0]){\n            if(ptr[l])\n                update(ptr[l], 1);\n            l++;\n        }\n        ans[queries[i][2]] = query(queries[i][1]) - query(queries[i][0]-1);\n    }\n\n    for(int i = 0; i < N; i++)\n        printf("%d%c", ans[i], (" \\n")[i==N-1]);\n}\n',
  "1140":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5+1;\n\nint N, a[maxN], b[maxN];\nll p[maxN], dp[2*maxN];\nstruct project {int time, id, type;} times[2*maxN];\nmap<int,int> mp;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++){\n        scanf("%d %d %lld", &a[i], &b[i], &p[i]);\n        times[2*i] = {a[i], i, 0};\n        times[2*i+1] = {b[i], i, 1};\n    }\n\n    sort(times+2, times+2*N+2, [](project A, project B){\n        return A.time == B.time ? A.id < B.id : A.time < B.time;\n    });\n\n    for(int i = 2; i <= 2*N+1; i++)\n        if(!mp[times[i].time])\n            mp[times[i].time] = i;\n\n    for(int i = 2; i <= 2*N+1; i++){\n        if(times[i].type == 0)  dp[i] = dp[i-1];\n        else dp[i] = max(dp[i-1], dp[mp[a[times[i].id]]-1] + p[times[i].id]);\n    }\n    printf("%lld\\n", dp[2*N+1]);\n}\n',
  "1141":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, k, l, ans;\nmap<int,int> mp;\n\nint main(){\n    scanf("%d", &N);\n\n    l = 1;\n    for(int r = 1; r <= N; r++){\n        scanf("%d", &k);\n        if(mp[k]){\n            ans = max(ans, r-l);\n            l = max(l, mp[k]+1);\n            mp[k] = r;\n        } else {\n            ans = max(ans, r-l+1);\n            mp[k] = r;\n        }\n    }\n\n    ans = max(N-l+1, ans);\n    printf("%d\\n", ans);\n}\n',
  "1142":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+5;\n\nint N, l[maxN], r[maxN];\nll best, a[maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++)\n        scanf("%lld", &a[i]);\n\n    for(int i = 1; i <= N; i++){\n        l[i] = i-1;\n        while(a[l[i]] >= a[i])\n            l[i] = l[l[i]];\n    }\n    for(int i = N; i >= 1; i--){\n        r[i] = i+1;\n        while(a[r[i]] >= a[i])\n            r[i] = r[r[i]];\n    }\n\n    for(int i = 1; i <= N; i++)\n        best = max(best, (r[i]-l[i]-1)*a[i]);\n    printf("%lld\\n", best);\n}\n',
  "1143":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, M, h[maxN], k, ans;\nint lo[4*maxN], hi[4*maxN], mx[4*maxN], mp[maxN];\n\nvoid pull(int i){\n    mx[i] = (h[mx[2*i]] >= h[mx[2*i+1]] ? mx[2*i] : mx[2*i+1]);\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        mp[l] = i;\n        mx[i] = l;\n        return;\n    }\n    int m = l+(r-l)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid update(int i, int v){\n    h[i] -= v;\n    i = mp[i];\n    i >>= 1;\n    while(i > 0){\n        pull(i);\n        i >>= 1;\n    }\n}\n\nint find(int i, int v){\n    if(lo[i] == hi[i])  return lo[i];\n    return (h[mx[2*i]] >= v ? find(2*i, v) : find(2*i+1, v));\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &h[i]);\n    init(1, 1, N);\n\n    for(int i = 0; i < M; i++){\n        scanf("%d", &k);\n        ans = h[mx[1]] < k ? 0 : find(1, k);\n        if(ans) update(ans, k);\n        printf("%d%c", ans, (" \\n")[i==M-1]);\n    }\n}\n',
  "1144":
    '#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5;\n\nchar c;\nint N, Q, a, b, p[maxN+1];\ntree<pii, null_type, less<pii>, rb_tree_tag,\ntree_order_statistics_node_update> T;\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &p[i]);\n        T.insert({p[i], i});\n    }\n\n    for(int i = 0; i < Q; i++){\n        scanf(" %c %d %d", &c, &a, &b);\n        if(c == \'!\'){\n            T.erase({p[a], a});\n            T.insert({b, a});\n            p[a] = b;\n        } else if(c == \'?\'){\n            printf("%ld\\n", T.order_of_key({b+1, 0}) - T.order_of_key({a, 0}));\n        }\n    }\n}\n',
  "1145":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, a;\nmultiset<int> S;\nmultiset<int>::iterator it;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &a);\n        S.insert(a);\n        it = S.lower_bound(a);\n        it++;\n        if(it != S.end())\n            S.erase(it);\n    }\n    printf("%d\\n", (int) S.size());\n}\n',
  "1146":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nll N;\nmap<ll,ll> dp;\n\nll f(ll a){\n    if(a == 0)  return 0;\n    if(dp[a])   return dp[a];\n    if(a&1)     return dp[a] = 2*f(a/2)+(a/2)+1;\n    else        return dp[a] = f(a/2)+f(a/2-1)+(a/2);\n}\n\nint main(){\n    scanf("%lld", &N);\n    printf("%lld\\n", f(N));\n}\n',
  "1147":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1002;\n\nint N, M, best, h[maxN], l[maxN], r[maxN];\nchar S[maxN][maxN];\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < N; i++)\n        scanf(" %s", S[i]);\n\n    h[0] = h[M+1] = -1;\n    for(int i = 1; i <= N; i++){\n        for(int j = 1; j <= M; j++)\n            h[j] = (S[i-1][j-1] == \'*\' ? 0 : h[j]+1);\n\n        int smaller;\n        for(int j = 1; j <= M; j++){\n            smaller = j-1;\n            while(h[smaller] >= h[j])\n                smaller = l[smaller];\n            l[j] = smaller;\n        }\n        for(int j = M; j >= 1; j--){\n            smaller = j+1;\n            while(h[smaller] >= h[j])\n                smaller = r[smaller];\n            r[j] = smaller;\n        }\n\n        for(int j = 1; j <= M; j++){\n            int base = r[j]-l[j]-1;\n            best = max(best, base * h[j]);\n        }\n    }\n\n    printf("%d\\n", best);\n}',
  "1149":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 5e5+5;\nconst ll MOD = 1e9+7;\n\nint N;\nll tot, dp[26];\nchar S[maxN];\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n    for(int i = 0; i < N; i++){\n        int c = (int) (S[i] - \'a\');\n        dp[c]++;\n        for(int j = 0; j < 26; j++)\n            if(j != c)\n                dp[c] = (dp[c] + dp[j]) % MOD;\n    }\n\n    for(int i = 0; i < 26; i++)\n        tot = (tot + dp[i]) % MOD;\n    printf("%lld\\n", tot);\n}',
  "1157":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint x, y;\n\nint main(){\n    scanf("%d %d", &x, &y);\n    printf("%d\\n", (x-1)^(y-1));\n}\n',
  "1158":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1000;\nconst int maxX = 1e5;\n\nint N, X, h[maxN], s[maxN], dp[maxX+1];\n\nint main(){\n    scanf("%d %d", &N, &X);\n    for(int i = 0; i < N; i++)  scanf("%d", &h[i]);\n    for(int i = 0; i < N; i++)  scanf("%d", &s[i]);\n\n    fill(dp+1, dp+X+1, -1);\n    for(int i = 0; i < N; i++)\n        for(int j = X-h[i]; j >= 0; j--)\n            if(dp[j] != -1)\n                dp[j+h[i]] = max(dp[j+h[i]], dp[j]+s[i]);\n\n    for(int i = 1; i <= X; i++)\n        dp[i] = max(dp[i], dp[i-1]);\n    printf("%d\\n", dp[X]);\n}\n',
  "1159":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 100, maxK = 1000, maxX = 1e5+1;\n\nint N, X, h[maxN], s[maxN], k[maxN];\nll dp[maxX];\n\nint main(){\n    scanf("%d %d", &N, &X);\n    for(int i = 0; i < N; i++)  scanf("%d", &h[i]);\n    for(int i = 0; i < N; i++)  scanf("%d", &s[i]);\n    for(int i = 0; i < N; i++)  scanf("%d", &k[i]);\n\n    fill(dp+1, dp+X+1, -1);\n    for(int i = 0; i < N; i++){\n        for(int b = 1; k[i] > 0; b++){\n            int amnt = min(b, k[i]);\n            k[i] -= b;\n            int price = amnt * h[i];\n            int pages = amnt * s[i];\n            for(int j = X; j >= price; j--)\n                if(dp[j-price] != -1)\n                    dp[j] = max(dp[j], dp[j-price] + pages);\n        }\n    }\n\n    for(int i = 1; i <= X; i++)\n        dp[i] = max(dp[i], dp[i-1]);\n    printf("%lld\\n", dp[X]);\n}',
  "1160":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1, logN = 20;\n\nbool vis[maxN];\nint N, Q, ds[maxN], d[maxN], comp[maxN], cyc[maxN], p[logN][maxN];\nvector<int> cycleSeeds, G[maxN];\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nvoid init_parents(){\n    for(int i = 1; i < logN; i++)\n        for(int j = 1; j <= N; j++)\n            p[i][j] = p[i-1][p[i-1][j]];\n}\n\nint travel(int u, int k){\n    int v = u;\n    for(int i = logN-1; i >= 0; i--)\n        if(k&(1<<i))\n            v = p[i][v];\n    return v;\n}\n\nvoid dfs(int u, int compID){\n    vis[u] = true;\n    comp[u] = compID;\n    for(int v : G[u]){\n        if(!vis[v]){\n            d[v] = d[u]+1;\n            dfs(v, compID);\n        } else cyc[u] = d[u]+1;\n        cyc[u] = max(cyc[u], cyc[v]);\n    }\n}\n\nint query(int a, int b){\n    if(a == b)  return 0;\n\n    // Start and end are on different components\n    if(comp[a] != comp[b])  return -1;\n\n    // Start is on cycle\n    if(cyc[a]){\n        if(!cyc[b]) return -1;\n        return (d[a]-d[b]+cyc[a]) % cyc[a];\n    }\n\n    // Start and end are on tree (must check if same tree)\n    if(!cyc[b]){\n        if(d[a] <= d[b])    return -1;\n        int dist = d[a]-d[b];\n        return (travel(a, dist) == b) ? dist : -1;\n    }\n\n    // Start is on tree and end is on cycle\n    int root = a;\n    for(int i = logN-1; i >= 0; i--){\n        int par = p[i][root];\n        if(!cyc[par])\n            root = par;\n    }\n    root = p[0][root];\n\n    return (d[a]-d[root]) + query(root, b);\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    fill(ds+1, ds+N+1, -1);\n    for(int i = 1, x; i <= N; i++){\n        scanf("%d", &x);\n        p[0][i] = x;\n        G[x].push_back(i);\n        if(!merge(x, i))\n            cycleSeeds.push_back(x);\n    }\n\n    init_parents();\n    int compID = 1;\n    for(int seed : cycleSeeds)\n        dfs(seed, compID++);\n\n    for(int i = 0, a, b; i < Q; i++){\n        scanf("%d %d", &a, &b);\n        printf("%d\\n", query(a, b));\n    }\n}',
  "1161":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N, x, d;\nll sum;\npriority_queue<int, vector<int>, greater<int>> sticks;\n\nint main(){\n    scanf("%d %d", &x, &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &d);\n        sticks.push(d);\n    }\n    while(sticks.size() > 1){\n        int a = sticks.top(); sticks.pop();\n        int b = sticks.top(); sticks.pop();\n        sticks.push(a+b);\n        sum += a + b;\n    }\n    printf("%lld\\n", sum);\n}\n',
  "1162":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+5;\n\nint N, x[maxN], ds[maxN];\nll bit[maxN], ans[4];\nset<int> S;\nset<int>::iterator it;\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nvoid update(int idx, int val){\n    for(int i = idx; i < maxN; i += -i&i)\n        bit[i] += val;\n}\n\nll query(int idx){\n    int sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum += bit[i];\n    return sum;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &x[i]);\n\n    int K = N;\n    ans[3] = N;\n    fill(ds+1, ds+N+1, -1);\n    for(int i = 1; i <= N; i++){\n        ans[0] += (i-query(x[i])-1);\n        update(x[i], 1);\n\n        if(!merge(i, x[i]))\n            ans[1] += (-ds[find(i)]-1);\n\n        S.insert(x[i]);\n        it = S.lower_bound(x[i]);\n        if(++it != S.end())\n            S.erase(it);\n\n        if(x[N-i+1] == K){\n            K--;\n            ans[3]--;\n        }\n    }\n    ans[2] = N - (int) S.size();\n\n    for(int i = 0; i < 4; i++)\n        printf("%lld%c", ans[i], (" \\n")[i==3]);\n}',
  "1163":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5;\n\nset<int> S;\nset<int>::iterator f, c, b;\nint N, X, a, best, ans[maxN];\nstruct light {int pos, id;} x[maxN+2];\n\nint main(){\n    scanf("%d %d", &X, &N);\n    x[0] = {0, 0}; x[N+1] = {X, 1};\n    S.insert(0); S.insert(X);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &a);\n        x[i+1] = {a, i+2};\n        S.insert(a);\n    }\n\n    sort(x, x+maxN+2, [](light A, light B){\n        return A.pos < B.pos;\n    });\n    for(int i = 1; i <= maxN+1; i++)\n        best = max(best, x[i].pos - x[i-1].pos);\n\n    sort(x, x+maxN+2, [](light A, light B){\n        return A.id > B.id;\n    });\n    for(int i = 0; i < N; i++){\n        ans[N-i-1] = best;\n        c = S.find(x[i].pos);\n        f = next(c, 1);\n        b = next(c, -1);\n        best = max(best, *f - *b);\n        S.erase(c);\n    }\n\n    for(int i = 0; i < N; i++)\n        printf("%d%c", ans[i], (" \\n")[i==N]);\n}\n',
  "1164":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5;\n\nset<int> S;\nint N, a, b, rooms, ans[maxN+1];\nstruct query {int type, time, id;} queries[2*maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        S.insert(i+1);\n        scanf("%d %d", &a, &b);\n        queries[2*i] = {0, a, i+1};\n        queries[2*i+1] = {1, b, i+1};\n    }\n\n    sort(queries, queries+2*N, [](query A, query B){\n        if(A.id == B.id)    return A.type < B.type;\n        return A.time == B.time ? A.type < B.type : A.time < B.time;\n    });\n\n    for(int i = 0; i < 2*N; i++){\n        if(queries[i].type == 0){\n            ans[queries[i].id] = *S.begin();\n            S.erase(S.begin());\n        } else if(queries[i].type == 1){\n            S.insert(ans[queries[i].id]);\n        }\n    }\n\n    for(int i = 1; i <= N; i++)\n        rooms = max(rooms, ans[i]);\n\n    printf("%d\\n", rooms);\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", ans[i], (" \\n")[i==N]);\n}\n',
  "1188":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\nconst int SIZE = 4*maxN;\n\nint N, M, mp[maxN], lo[SIZE], hi[SIZE], dp[3][SIZE];\nchar S[maxN];\n\nint len(int i){\n    return hi[i]-lo[i]+1;\n}\n\nint combine(int a, int b){\n    return ((a<0)^(b<0)) ? a : a+b;\n}\n\nbool allsame(int i){\n    return abs(dp[2][i]) == len(i);\n}\n\nvoid pull(int i){\n    dp[0][i] = (allsame(2*i) ? combine(dp[0][2*i], dp[0][2*i+1]) : dp[0][2*i]);\n    dp[1][i] = (allsame(2*i+1) ? combine(dp[1][2*i+1], dp[1][2*i]) : dp[1][2*i+1]);\n    dp[2][i] = max(abs(combine(dp[1][2*i], dp[0][2*i+1])), max(dp[2][2*i], dp[2][2*i+1]));\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        mp[l] = i;\n        dp[0][i] = dp[1][i] = (S[l-1] == \'0\' ? -1 : 1);\n        dp[2][i] = abs(dp[0][i]);\n        return;\n    }\n    int m = (l+r)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid update(int idx){\n    int i = mp[idx];\n    dp[0][i] *= -1;\n    dp[1][i] = dp[0][i];\n\n    i >>= 1;\n    while(i){\n        pull(i);\n        i >>= 1;\n    }\n}\n\nint query(){\n    return dp[2][1];\n}\n\nint main(){\n    scanf("%s %d", S, &M);\n    N = (int) strlen(S);\n    init(1, 1, N);\n    for(int i = 0, x; i < M; i++){\n        scanf("%d", &x);\n        update(x);\n        printf("%d%c", query(), (" \\n")[i==M-1]);\n    }\n}\n',
  "1189":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, A[maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++)  scanf("%d", &A[i]);\n    for(int i = 1, b; i <= N; i++){\n        scanf("%d", &b);\n        A[i] += (A[i-1] - b);\n    }\n    sort(A+1, A+N+1);\n\n    ll ans = 0;\n    for(int i = 1; i <= N; i++)\n        ans += abs(A[i] - A[(N+1)/2]);\n    printf("%lld\\n", ans);\n}',
  "1190":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int SIZE = 8e5;\n\nint N, Q, k, lo[SIZE], hi[SIZE], mp[SIZE];\nll x, sum[SIZE], dp[SIZE], dpl[SIZE], dpr[SIZE];\n\nvoid pull(int i){\n    dpl[i] = max(dpl[2*i], sum[2*i] + dpl[2*i+1]);\n    dpr[i] = max(dpr[2*i+1], sum[2*i+1] + dpr[2*i]);\n    dp[i] = max(dpr[2*i] + dpl[2*i+1], max(dp[2*i], dp[2*i+1]));\n    sum[i] = sum[2*i] + sum[2*i+1];\n}\n\nvoid build(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        scanf("%lld", &sum[i]);\n        dpl[i] = dpr[i] = dp[i] = sum[i];\n        mp[l] = i;\n        return;\n    }\n    int m = l+(r-l)/2;\n    build(2*i, l, m);\n    build(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid update(int a, ll b){\n    a = mp[a];\n\n    dpl[a] = dpr[a] = dp[a] = sum[a] = b;\n    a >>= 1;\n    while(a > 0){\n        pull(a);\n        a >>= 1;\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n\n    build(1, 1, N);\n    for(int q = 0; q < Q; q++){\n        scanf("%d %lld", &k, &x);\n        update(k, x);\n        printf("%lld\\n", max(0LL, dp[1]));\n    }\n}\n',
  "1191":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, last[maxN];\nll K, x[2*maxN];\n\nint main(){\n    scanf("%d %lld", &N, &K);\n    for(int i = 0; i < N; i++){\n        scanf("%lld", &x[i]);\n        x[i+N] = x[i];\n    }\n\n    int r = 0;\n    ll sum = 0;\n    for(int l = 0; l < N; l++){\n        while(r < l+N && sum + x[r] <= K){\n            sum += x[r];\n            r++;\n        }\n        last[l] = r % N;\n        sum -= x[l];\n    }\n\n    int opt = 0;\n    for(int i = 0; i < N; i++)\n        opt = last[opt];\n\n    int cnt = 1;\n    sum = x[opt];\n    for(int i = opt+1; i < N+opt; i++){\n        if(sum + x[i] <= K) sum += x[i];\n        else {\n            sum = x[i];\n            cnt++;\n        }\n    }\n\n    printf("%d\\n", cnt);\n}',
  "1192":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar c;\nint N, M, cnt;\nint h[] = {1, -1, 0, 0}, v[] = {0, 0, 1, -1};\nbool vis[1000][1000];\n\nvoid dfs(int x, int y){\n    vis[x][y] = true;\n    for(int i = 0; i < 4; i++){\n        int dx = x+h[i], dy = y+v[i];\n        if(0 <= dx && dx < N && 0 <= dy && dy < M && !vis[dx][dy])\n            dfs(dx, dy);\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < M; j++){\n            scanf(" %c", &c);\n            vis[i][j] = (c == \'#\');\n        }\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < M; j++){\n            if(!vis[i][j]){\n                dfs(i, j);\n                cnt++;\n            }\n        }\n    }\n    printf("%d\\n", cnt);\n}\n',
  "1193":
    "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n\nconst int h[] = {1, -1, 0, 0}, v[] = {0, 0, 1, -1};\n\nbool vis[1000][1000];\nchar c, par[1000][1000], ans[1000000];\nint N, M, sx, sy, ex, ey, dist[1000][1000];\nqueue<pii> Q;\n\n\nint main(){\n    scanf(\"%d %d\", &N, &M);\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < M; j++){\n            scanf(\" %c\", &c);\n            if(c == '#')    vis[i][j] = true;\n            else if(c == 'A'){\n                sx = i; sy = j;\n            } else if(c == 'B'){\n                ex = i; ey = j;\n            }\n        }\n    }\n\n    vis[sx][sy] = true;\n    Q.push({sx, sy});\n    while(!Q.empty()){\n        pii P = Q.front(); Q.pop();\n        for(int i = 0; i < 4; i++){\n            int dx = P.x+h[i];\n            int dy = P.y+v[i];\n            if(0 <= dx && dx < N && 0 <= dy && dy < M && !vis[dx][dy]){\n                if(i == 0)      par[dx][dy] = 'D';\n                else if(i == 1) par[dx][dy] = 'U';\n                else if(i == 2) par[dx][dy] = 'R';\n                else if(i == 3) par[dx][dy] = 'L';\n                dist[dx][dy] = dist[P.x][P.y]+1;\n                vis[dx][dy] = true;\n                Q.push({dx, dy});\n            }\n        }\n    }\n\n    if(!vis[ex][ey]){\n        printf(\"NO\\n\");\n        return 0;\n    }\n\n    printf(\"YES\\n%d\\n\", dist[ex][ey]);\n    pii P = {ex, ey};\n    for(int i = dist[ex][ey]; i > 0; i--){\n        ans[i] = par[P.x][P.y];\n        if(ans[i] == 'D')       P = {P.x-1, P.y};\n        else if(ans[i] == 'U')  P = {P.x+1, P.y};\n        else if(ans[i] == 'R')  P = {P.x, P.y-1};\n        else if(ans[i] == 'L')  P = {P.x, P.y+1};\n    }\n    for(int i = 1; i <= dist[ex][ey]; i++)\n        printf(\"%c\", ans[i]);\n    printf(\"\\n\");\n}\n",
  "1194":
    "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1000;\nconst int INF = 0x3f3f3f3f;\n\nint h[] = {1, -1, 0, 0};\nint v[] = {0, 0, 1, -1};\nstruct point { int x, y; };\n\nint N, M, sx, sy;\nbool vis[maxN][maxN];\nchar ans[maxN*maxN], c[maxN][maxN], p[maxN][maxN];\nint d1[maxN][maxN], d2[maxN][maxN];\nqueue<point> Q;\n\nbool inbounds(int x, int y){\n    return 0 <= x && x < N && 0 <= y && y < M;\n}\n\nvoid printsolution(int x, int y){\n    int D = d2[x][y];\n    printf(\"YES\\n%d\\n\", D);\n    for(int i = D-1; i >= 0; i--){\n        ans[i] = p[x][y];\n        if(ans[i] == 'D')       x--;\n        else if(ans[i] == 'U')  x++;\n        else if(ans[i] == 'R')  y--;\n        else if(ans[i] == 'L')  y++;\n    }\n    for(int i = 0; i < D; i++)\n        printf(\"%c\", ans[i]);\n    printf(\"\\n\");\n}\n\nint main(){\n    scanf(\"%d %d\", &N, &M);\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < M; j++){\n            scanf(\" %c\", &c[i][j]);\n            if(c[i][j] == '#')  vis[i][j] = true;\n            else if(c[i][j] == 'M'){\n                vis[i][j] = true;\n                Q.push({i, j});\n            } else if(c[i][j] == 'A'){\n                sx = i; sy = j;\n            }\n        }\n    }\n\n    while(!Q.empty()){\n        point P = Q.front(); Q.pop();\n        for(int i = 0; i < 4; i++){\n            int x = P.x + h[i];\n            int y = P.y + v[i];\n            if(inbounds(x, y) && !vis[x][y]){\n                d1[x][y] = d1[P.x][P.y] + 1;\n                vis[x][y] = true;\n                Q.push({x, y});\n            }\n        }\n    }\n\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < M; j++){\n            if(!vis[i][j])  d1[i][j] = INF;\n            vis[i][j] = (c[i][j] == '#');\n        }\n    }\n\n    vis[sx][sy] = true;\n    Q.push({sx, sy});\n    while(!Q.empty()){\n        point P = Q.front(); Q.pop();\n        for(int i = 0; i < 4; i++){\n            int x = P.x + h[i];\n            int y = P.y + v[i];\n            if(inbounds(x, y) && !vis[x][y] && d2[P.x][P.y]+1 < d1[x][y]){\n                if(i == 0)      p[x][y] = 'D';\n                else if(i == 1) p[x][y] = 'U';\n                else if(i == 2) p[x][y] = 'R';\n                else if(i == 3) p[x][y] = 'L';\n                d2[x][y] = d2[P.x][P.y] + 1;\n                vis[x][y] = true;\n                Q.push({x, y});\n            }\n        }\n    }\n\n    for(int i = 0; i < N; i++){\n        if(c[i][0] != '#' && c[i][0] != 'M' && vis[i][0]){\n            printsolution(i, 0);\n            return 0;\n        } else if(c[i][M-1] != '#' && c[i][M-1] != 'M' && vis[i][M-1]){\n            printsolution(i, M-1);\n            return 0;\n        }\n    }\n\n    for(int i = 0; i < M; i++){\n        if(c[0][i] != '#' && c[0][i] != 'M' && vis[0][i]){\n            printsolution(0, i);\n            return 0;\n        } else if(c[N-1][i] != '#' && c[N-1][i] != 'M' && vis[N-1][i]){\n            printsolution(N-1, i);\n            return 0;\n        }\n    }\n\n    printf(\"NO\\n\");\n}\n",
  "1195":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,ll> edge;\ntypedef tuple<ll,int,int> node;\nconst int maxN = 2e5+1;\n\nint N, M, a, b;\nll c, dist[2][maxN];\nvector<edge> G[maxN];\npriority_queue<node, vector<node>, greater<node>> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    memset(dist, 0x3f, sizeof(dist));\n    for(int i = 0; i < M; i++){\n        scanf("%d %d %lld", &a, &b, &c);\n        G[a].push_back({b, c});\n    }\n\n    dist[0][1] = dist[1][1] = 0;\n    Q.push({0, 1, 1});\n    while(!Q.empty()){\n        ll d = get<0>(Q.top());\n        int u = get<1>(Q.top());\n        int coupon = get<2>(Q.top());\n        Q.pop();\n\n        if(dist[!coupon][u] < d)    continue;\n\n        for(edge e : G[u]){\n            int v = e.first;\n            ll w = e.second;\n\n            if(coupon){\n                if(dist[0][v] > d + w){\n                    dist[0][v] = d + w;\n                    Q.push({d+w, v, 1});\n                }\n                if(dist[1][v] > d + w/2){\n                    dist[1][v] = d + w/2;\n                    Q.push({d+w/2, v, 0});\n                }\n            } else {\n                if(dist[1][v] > d + w){\n                    dist[1][v] = d + w;\n                    Q.push({d+w, v, 0});\n                }\n            }\n        }\n    }\n\n    printf("%lld\\n", min(dist[0][N], dist[1][N]));\n}\n',
  "1196":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,ll> edge;\ntypedef pair<ll,int> node;\nconst int maxN = 2e5+1;\n\nint N, M, K, cnt[maxN];\nvector<edge> G[maxN];\npriority_queue<node, vector<node>, greater<node>> Q;\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n    for(int i = 0, a, b, c; i < M; i++){\n        scanf("%d %d %d", &a, &b, &c);\n        G[a].push_back({b, c});\n    }\n\n    Q.push({0, 1});\n    while(!Q.empty()){\n        ll d = get<0>(Q.top());\n        int u = get<1>(Q.top());\n        Q.pop();\n\n        cnt[u]++;\n        if(u == N){\n            printf("%lld%c", d, (" \\n")[cnt[u]==K]);\n            if(cnt[u] == K) return 0;\n        }\n\n        if(cnt[u] <= K){\n            for(edge e : G[u]){\n                int v = e.first;\n                ll w = e.second;\n                Q.push({d+w, v});\n            }\n        }\n    }\n}\n',
  "1197":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2501;\nconst int maxM = 5001;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nstruct Edge {\n    int a, b; ll c;\n} edges[maxM];\n\nint N, M, ptr, p[maxN];\nll dp[maxN];\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        ll c;\n        scanf("%d %d %lld", &a, &b, &c);\n        edges[i] = {a, b, c};\n    }\n\n    ptr = -1;\n    fill(dp+2, dp+N+1, INF);\n    for(int iter = 0; iter < N && ptr; iter++){\n        ptr = 0;\n        for(int i = 0; i < M; i++){\n            int u = edges[i].a;\n            int v = edges[i].b;\n            ll w = edges[i].c;\n\n            if(dp[v] > dp[u]+w){\n                dp[v] = dp[u]+w;\n                p[v] = u;\n                ptr = v;\n            }\n        }\n    }\n\n    if(!ptr){\n        printf("NO\\n");\n        return 0;\n    }\n\n    for(int i = 0; i < N; i++)\n        ptr = p[ptr];\n\n    vector<int> cycle;\n    for(int v = ptr;; v = p[v]){\n        cycle.push_back(v);\n        if(v == ptr && (int) cycle.size() > 1)\n            break;\n    }\n    reverse(cycle.begin(), cycle.end());\n\n    printf("YES\\n");\n    int K = (int) cycle.size();\n    for(int i = 0; i < K; i++)\n        printf("%d%c", cycle[i], (" \\n")[i==K-1]);\n}',
  "1202":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,ll> edge;\ntypedef pair<ll,int> node;\nconst int maxN = 1e5+1;\nconst ll MOD = 1e9+7;\nconst ll INF = 0x3f3f3f3f3f3f;\n\nint N, M, a, b, minR[maxN], maxR[maxN];\nll c, dist[maxN], ways[maxN];\nvector<edge> G[maxN];\n\nstruct Comparator {\n    bool operator() (int x, int y) const {\n        return dist[x] == dist[y] ? x < y : dist[x] < dist[y];\n    }\n};\nset<int, Comparator> PQ;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    memset(dist, 0x3f, sizeof(dist));\n    for(int i = 0; i < M; i++){\n        scanf("%d %d %lld", &a, &b, &c);\n        G[a].push_back({b, c});\n    }\n\n    PQ.insert(1);\n    ways[1] = 1;\n    dist[1] = 0;\n    while(!PQ.empty()){\n        int u = *PQ.begin();\n        ll d = dist[u];\n        PQ.erase(PQ.begin());\n\n        for(edge e : G[u]){\n            int v = e.first;\n            ll w = e.second;\n            if(d + w <= dist[v]){\n                if(dist[v] != INF)  PQ.erase(v);\n                if(d + w == dist[v]){\n                    ways[v] = (ways[u] + ways[v]) % MOD;\n                    minR[v] = min(minR[v], minR[u]+1);\n                    maxR[v] = max(maxR[v], maxR[u]+1);\n                }\n                if(d + w < dist[v]){\n                    dist[v] = d+w;\n                    ways[v] = ways[u];\n                    minR[v] = minR[u]+1;\n                    maxR[v] = maxR[u]+1;\n                }\n                PQ.insert(v);\n            }\n        }\n    }\n\n    printf("%lld %lld %d %d\\n", dist[N], ways[N], minR[N], maxR[N]);\n}\n',
  "1203":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,ll> edge;\ntypedef pair<ll,int> node;\nconst int maxN = 1e5+1;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nuniform_int_distribution<ll> distrib((ll) 1e9, (ll) 2e9);\nconst ll MOD1 = distrib(rng);\nconst ll MOD2 = distrib(rng);\n\nint N, M;\nll dist[2][maxN], ways[2][2][maxN];\nvector<edge> G[2][maxN];\nvector<int> ans;\n\nvoid init(){\n    for(int t = 0; t < 2; t++)\n        for(int i = 1; i <= N; i++)\n            dist[t][i] = INF;\n}\n\nvoid dijkstra(int type, int source){\n    priority_queue<node, vector<node>, greater<node>> Q;\n    dist[type][source] = 0;\n    ways[type][0][source] = 1;\n    ways[type][1][source] = 1;\n    Q.push({0, source});\n    while(!Q.empty()){\n        int u = Q.top().second;\n        ll d = Q.top().first;\n        Q.pop();\n\n        if(d > dist[type][u])   continue;\n        for(edge e : G[type][u]){\n            int v = e.first;\n            ll w = e.second;\n            if(dist[type][v] > d+w){\n                ways[type][0][v] = ways[type][0][u];\n                ways[type][1][v] = ways[type][1][u];\n                dist[type][v] = d+w;\n                Q.push({d+w, v});\n            } else if(dist[type][v] == d+w){\n                ways[type][0][v] += ways[type][0][u];\n                ways[type][0][v] %= MOD1;\n                ways[type][1][v] += ways[type][1][u];\n                ways[type][1][v] %= MOD2;\n            }\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b, c; i < M; i++){\n        scanf("%d %d %d", &a, &b, &c);\n        G[0][a].push_back({b, c});\n        G[1][b].push_back({a, c});\n    }\n    init();\n    dijkstra(0, 1);\n    dijkstra(1, N);\n\n    ll tot1 = ways[0][0][N], tot2 = ways[0][1][N];\n    for(int u = 1; u <= N; u++){\n        ll ways1 = ways[0][0][u] * ways[1][0][u] % MOD1;\n        ll ways2 = ways[0][1][u] * ways[1][1][u] % MOD2;\n        if(ways1 == tot1 && ways2 == tot2 && dist[0][u] + dist[1][u] == dist[0][N])\n            ans.push_back(u);\n    }\n\n    int K = (int) ans.size();\n    printf("%d\\n", K);\n    for(int i = 0; i < K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K-1]);\n}',
  "1617":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nint N;\n\nll fastpow2(int x){\n    ll res = 1;\n    ll a = 2;\n    while(x > 0){\n        if(x&1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        x >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    scanf("%d", &N);\n    printf("%lld\\n", fastpow2(N));\n}\n',
  "1618":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, ans;\n\nint main(){\n    scanf("%d", &N);\n    while(N > 0){\n        N /= 5;\n        ans += N;\n    }\n    printf("%d\\n", ans);\n}\n',
  "1619":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 4e5;\n\nint N, a, b, cur, ans;\nstruct event {int time, type;} events[maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d %d", &a, &b);\n        events[2*i] = {a, 1};\n        events[2*i+1] = {b, -1};\n    }\n    sort(events, events+2*N, [](event A, event B){\n        return A.time == B.time ? A.type < B.type : A.time < B.time;\n    });\n\n    for(int i = 0; i < 2*N; i++){\n        cur += events[i].type;\n        ans = max(ans, cur);\n    }\n    printf("%d\\n", ans);\n}\n',
  "1620":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N;\nll T, cnt, k[maxN];\n\nbool check(ll t){\n    cnt = 0;\n    for(int i = 0; i < N; i++){\n        cnt += t/k[i];\n        if(cnt >= T)\n            return true;\n    }\n    return false;\n}\n\nint main(){\n    scanf("%d %lld", &N, &T);\n    for(int i = 0; i < N; i++)\n        scanf("%lld", &k[i]);\n\n    ll lo = 0, hi = 1e18;\n    while(lo <= hi){\n        ll mid = lo + (hi-lo)/2;\n        if(check(mid))  hi = mid-1;\n        else            lo = mid+1;\n    }\n    printf("%lld\\n", lo);\n}\n',
  "1621":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, x;\nset<int> S;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &x);\n        S.insert(x);\n    }\n    printf("%d\\n", (int) S.size());\n}\n',
  "1622":
    "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nchar S[9];\nset<string> perms;\n\nint main(){\n    scanf(\"%s\", S);\n    N = (int) strlen(S);\n    sort(S, S+N);\n\n    perms.insert(S);\n    while(next_permutation(S, S+N))\n        perms.insert(string(S, S+N));\n\n    cout << perms.size() << '\\n';\n    for(string perm : perms)\n        cout << perm << '\\n';\n}\n",
  "1623":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nint N, p[20];\nll a, b, best;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &p[i]);\n\n    best = INF;\n    for(int i = 0; i < (1<<N); i++){\n        a = 0; b = 0;\n        for(int j = 0; j < N; j++){\n            if(i&(1<<j))    a += p[j];\n            else            b += p[j];\n        }\n        best = min(best, abs(a-b));\n    }\n    printf("%lld\\n", best);\n}\n',
  "1624":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 8;\n\nchar c;\nint ans;\nbool b[N][N], input[N][N];\n\nbool place(int x, int y){\n    bool yes = true;\n    for(int i = 0; i < N; i++)\n        if(b[x][i] || b[i][y])\n            yes = false;\n    for(int i = 0; x-i >= 0 && y-i >= 0; i++)\n        if(b[x-i][y-i])\n            yes = false;\n    for(int i = 0; x-i >= 0 && y+i < N; i++)\n        if(b[x-i][y+i])\n            yes = false;\n    return yes;\n}\n\nbool check(){\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            if(b[i][j] && input[i][j])\n                return false;\n    return true;\n}\n\nvoid dfs(int i){\n    if(i == N){\n        if(check())\n            ans++;\n        return;\n    }\n    for(int j = 0; j < N; j++){\n        if(place(i, j)){\n            b[i][j] = true;\n            dfs(i+1);\n            b[i][j] = false;\n        }\n    }\n}\n\nint main(){\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            scanf(" %c", &c);\n            input[i][j] = (c == \'*\');\n        }\n    }\n    dfs(0);\n    printf("%d\\n", ans);\n}\n',
  "1625":
    "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 7;\n\nint ans;\nchar c[N*N+1];\nbool vis[N+1][N+1];\n\nbool inbounds(int x, int y){\n    return 1 <= x && x <= N && 1 <= y && y <= N;\n}\n\nvoid dfs(int x, int y, int i){\n    if(i == N*N-1 || (x == N && y == 1)){\n        ans += (i == N*N-1 && (x == N && y == 1));\n        return;\n    }\n\n    if((!inbounds(x+1, y) || vis[x+1][y]) && (!inbounds(x-1, y) || vis[x-1][y]))\n        if(inbounds(x, y-1) && !vis[x][y-1] && inbounds(x, y+1) && !vis[x][y+1])\n            return;\n    if((!inbounds(x, y+1) || vis[x][y+1]) && (!inbounds(x, y-1) || vis[x][y-1]))\n        if(inbounds(x+1, y) && !vis[x+1][y] && inbounds(x-1, y) && !vis[x-1][y])\n            return;\n\n    vis[x][y] = true;\n    if(c[i] == 'D' || c[i] == '?')\n        if(inbounds(x+1, y) && !vis[x+1][y])\n            dfs(x+1, y, i+1);\n    if(c[i] == 'U' || c[i] == '?')\n        if(inbounds(x-1, y) && !vis[x-1][y])\n            dfs(x-1, y, i+1);\n    if(c[i] == 'R' || c[i] == '?')\n        if(inbounds(x, y+1) && !vis[x][y+1])\n            dfs(x, y+1, i+1);\n    if(c[i] == 'L' || c[i] == '?')\n        if(inbounds(x, y-1) && !vis[x][y-1])\n            dfs(x, y-1, i+1);\n    vis[x][y] = false;\n}\n\nint main(){\n    scanf(\" %s\", c);\n    dfs(1, 1, 0);\n    printf(\"%d\\n\", ans);\n}\n",
  "1628":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 40;\n\nint N, t[maxN];\nll x, sum, cnt;\nunordered_map<ll,int> freq;\n\nint main(){\n    scanf("%d %lld", &N, &x);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &t[i]);\n    sort(t, t+N);\n\n    if(N == 1){\n        printf("%d\\n", x == t[0]);\n        return 0;\n    }\n\n    freq.reserve(1<<(N/2-1));\n    for(int i = 0; i < (1<<(N/2-1)); i++){\n        sum = 0;\n        for(int j = 0; j < N/2-1; j++)\n            if(i&(1<<j))\n                sum += t[j];\n        freq[sum]++;\n    }\n\n    for(int i = 0; i < (1<<((N+1)/2+1)); i++){\n        sum = 0;\n        for(int j = 0; j < (N+1)/2+1; j++)\n            if(i&(1<<j))\n                sum += t[N/2-1+j];\n        if(freq.find(x-sum) != freq.end())\n            cnt += freq[x-sum];\n    }\n\n    printf("%lld\\n", cnt);\n}\n',
  "1629":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5+1;\n\nint N, a[maxN], b[maxN], dp[2*maxN];\nstruct Movie {int t, id, type;} movies[2*maxN];\nmap<int,int> mp;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d %d", &a[i], &b[i]);\n        movies[2*i] = {a[i], i, 0};\n        movies[2*i+1] = {b[i], i, 1};\n    }\n\n    sort(movies, movies+2*N, [](Movie A, Movie B){\n        return A.t == B.t ? A.id < B.id : A.t < B.t;\n    });\n\n    for(int i = 0; i < 2*N; i++)\n        mp[movies[i].t] = i;\n\n    for(int i = 0; i < 2*N; i++){\n        if(movies[i].type == 0) dp[i] = dp[i-1];\n        else dp[i] = max(dp[i-1], dp[mp[a[movies[i].id]]]+1);\n    }\n    printf("%d\\n", dp[2*N-1]);\n}\n',
  "1630":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5;\n\nint N, a, d;\nlong long timer, reward;\nstruct task {int a, d;} tasks[maxN];\n\nint main (){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d %d", &a, &d);\n        tasks[i] = {a, d};\n    }\n\n    sort(tasks, tasks+N, [](task x, task y){\n        return x.a == y.a ? x.d < y.d : x.a < y.a;\n    });\n\n    for(int i = 0; i < N; i++){\n        timer += tasks[i].a;\n        reward += (tasks[i].d - timer);\n    }\n    printf("%lld\\n", reward);\n}\n',
  "1631":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll t, mx, sum;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%lld", &t);\n        mx = max(mx, t);\n        sum += t;\n    }\n    printf("%lld\\n", max(sum, 2*mx));\n}\n',
  "1632":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5, SIZE = 5e6;\nconst int INF = 0x3f3f3f3f;\n\nint N, K, ans, A[maxN], B[maxN], lo[SIZE], hi[SIZE], d[SIZE], mx[SIZE];\nstruct Movie { int t, id, type; } movies[2*maxN];\nmap<int,int> mp;\n\nvoid push(int i){\n    if(d[i]){\n        d[2*i] += d[i];\n        d[2*i+1] += d[i];\n        d[i] = 0;\n    }\n}\n\nvoid pull(int i){\n    mx[i] = max(mx[2*i]+d[2*i], mx[2*i+1]+d[2*i+1]);\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r)  return;\n    int m = l+(r-l)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid increment(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        d[i]++; return;\n    }\n    push(i);\n    increment(2*i, l, r);\n    increment(2*i+1, l, r);\n    pull(i);\n}\n\nint maximum(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])      return -INF;\n    if(l <= lo[i] && hi[i] <= r)    return mx[i]+d[i];\n\n    push(i);\n    int lmax = maximum(2*i, l, r);\n    int rmax = maximum(2*i+1, l, r);\n    pull(i);\n\n    return max(lmax, rmax);\n}\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 0; i < N; i++){\n        scanf("%d %d", &A[i], &B[i]);\n        movies[2*i] = {A[i], i, 0};\n        movies[2*i+1] = {B[i], i, 1};\n    }\n    sort(movies, movies+2*N, [](Movie a, Movie b){\n        return a.t == b.t ? A[a.id] > A[b.id] : a.t < b.t;\n    });\n\n    for(int i = 0; i < 2*N; i++)\n        mp[movies[i].t] = i+1;\n\n    init(1, 1, 2*N);\n    for(int i = 0; i < 2*N; i++){\n        if(movies[i].type == 1){\n            int id = movies[i].id;\n            int a = mp[A[id]];\n            int b = mp[B[id]];\n\n            if(maximum(1, a+1, b) < K){\n                increment(1, a, b);\n                ans++;\n            }\n        }\n    }\n    printf("%d\\n", ans);\n}',
  "1633":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6;\nconst int MOD = 1e9+7;\n\nint N, dp[maxN+1];\n\nint main(){\n    scanf("%d", &N);\n\n    dp[0] = 1;\n    for(int i = 1; i <= N; i++)\n        for(int j = 1; j <= 6 && i-j >= 0; j++)\n            dp[i] = (dp[i] + dp[i-j]) % MOD;\n\n    printf("%d\\n", dp[N]);\n}\n',
  "1634":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxX = 1e6;\nconst int INF = 0x3f3f3f3f;\n\nint N, X, c, dp[maxX+1];\n\nint main(){\n    scanf("%d %d", &N, &X);\n    fill(dp+1, dp+X+1, INF);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &c);\n        for(int j = 0; j <= X-c; j++)\n            if(dp[j] != INF)\n                dp[j+c] = min(dp[j+c], dp[j]+1);\n    }\n    printf("%d\\n", dp[X] == INF ? -1 : dp[X]);\n}\n',
  "1635":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 100;\nconst int maxX = 1e6;\nconst ll MOD = 1e9+7;\n\nint N, X, c[maxN];\nll dp[maxX+1];\n\nint main(){\n    scanf("%d %d", &N, &X);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &c[i]);\n\n    dp[0] = 1;\n    for(int i = 0; i < X; i++)\n        if(dp[i] != 0)\n            for(int j = 0; j < N; j++)\n                if(i+c[j] <= X)\n                    dp[i+c[j]] = (dp[i+c[j]] + dp[i]) % MOD;\n\n    printf("%lld\\n", dp[X]);\n}\n',
  "1636":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxX = 1e6;\nconst ll MOD = 1e9+7;\n\nint N, X, c;\nll dp[maxX+1];\n\nint main(){\n    scanf("%d %d", &N, &X);\n\n    dp[0] = 1;\n    for(int i = 0; i < N; i++){\n        scanf("%d", &c);\n        for(int j = 0; j <= X-c; j++)\n            dp[j+c] = (dp[j+c] + dp[j]) % MOD;\n    }\n\n    printf("%lld\\n", dp[X]);\n}\n',
  "1637":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6;\nconst int INF = 0x3f3f3f3f;\n\nint N, dp[maxN+1];\n\nint main(){\n    scanf("%d", &N);\n    fill(dp+1, dp+N+1, INF);\n\n    for(int i = 1; i <= N; i++){\n        int d = i;\n        while(d > 0){\n            if(d%10 != 0)\n                dp[i] = min(dp[i], dp[i-(d%10)]+1);\n            d /= 10;\n        }\n    }\n\n    printf("%d\\n", dp[N]);\n}\n',
  "1638":
    "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 7;\n\nint ans;\nchar c[N*N+1];\nbool vis[N+1][N+1];\n\nbool inbounds(int x, int y){\n    return 1 <= x && x <= N && 1 <= y && y <= N;\n}\n\nvoid dfs(int x, int y, int i){\n    if(i == N*N-1 || (x == N && y == 1)){\n        ans += (i == N*N-1 && (x == N && y == 1));\n        return;\n    }\n\n    if((!inbounds(x+1, y) || vis[x+1][y]) && (!inbounds(x-1, y) || vis[x-1][y]))\n        if(inbounds(x, y-1) && !vis[x][y-1] && inbounds(x, y+1) && !vis[x][y+1])\n            return;\n    if((!inbounds(x, y+1) || vis[x][y+1]) && (!inbounds(x, y-1) || vis[x][y-1]))\n        if(inbounds(x+1, y) && !vis[x+1][y] && inbounds(x-1, y) && !vis[x-1][y])\n            return;\n\n    vis[x][y] = true;\n    if(c[i] == 'D' || c[i] == '?')\n        if(inbounds(x+1, y) && !vis[x+1][y])\n            dfs(x+1, y, i+1);\n    if(c[i] == 'U' || c[i] == '?')\n        if(inbounds(x-1, y) && !vis[x-1][y])\n            dfs(x-1, y, i+1);\n    if(c[i] == 'R' || c[i] == '?')\n        if(inbounds(x, y+1) && !vis[x][y+1])\n            dfs(x, y+1, i+1);\n    if(c[i] == 'L' || c[i] == '?')\n        if(inbounds(x, y-1) && !vis[x][y-1])\n            dfs(x, y-1, i+1);\n    vis[x][y] = false;\n}\n\nint main(){\n    scanf(\" %s\", c);\n    dfs(1, 1, 0);\n    printf(\"%d\\n\", ans);\n}\n",
  "1639":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 5e3+5;\n\nint N, M, dp[maxN][maxN];\nchar a[maxN], b[maxN];\n\nint main(){\n    scanf("%s %s", a, b);\n    N = (int) strlen(a);\n    M = (int) strlen(b);\n\n    memset(dp, 0x3f, sizeof(dp));\n    for(int i = 0; i <= N; i++){\n        for(int j = 0; j <= M; j++){\n            if(i == 0)      dp[i][j] = j;\n            else if(j == 0) dp[i][j] = i;\n            else if(a[i-1] == b[j-1])   dp[i][j] = dp[i-1][j-1];\n            else dp[i][j] = 1 + min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});\n        }\n    }\n\n    printf("%d\\n", dp[N][M]);\n}\n',
  "1640":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5+1;\n\nint N, x, a;\npii p[maxN];\n\nint find(int val){\n    int l = 1, r = N;\n    while(l <= r){\n        int m = l+(r-l)/2;\n        if(p[m].first == val)       return p[m].second;\n        else if(p[m].first < val)   l = m+1;\n        else                        r = m-1;\n    }\n    return 0;\n}\n\nint main(){\n    scanf("%d %d", &N, &x);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &a);\n        p[i] = {a, i};\n    }\n    sort(p+1, p+N+1);\n\n    for(int i = 1; i <= N; i++){\n        int other = find(x-p[i].first);\n        if(other != 0 && other != p[i].second){\n            printf("%d %d\\n", p[i].second, other);\n            return 0;\n        }\n    }\n    printf("IMPOSSIBLE\\n");\n}\n',
  "1641":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 5000;\n\nint N, X, v, r;\npii a[maxN];\n\nint main(){\n    scanf("%d %d", &N, &X);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &v);\n        a[i] = {v, i+1};\n    }\n\n    sort(a, a+N);\n    for(int i = 0; i < N; i++){\n        v = X - a[i].first;\n        r = N-1;\n        for(int l = i+1; l < r; l++){\n            while(l+1 < r && a[l].first + a[r].first > v)   r--;\n            if(a[l].first + a[r].first == v){\n                printf("%d %d %d\\n", a[i].second, a[l].second, a[r].second);\n                return 0;\n            }\n        }\n    }\n    printf("IMPOSSIBLE\\n");\n}\n',
  "1642":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxN = 1001;\n\nint N;\nll X, a[maxN];\nunordered_map<ll,vector<pii>> mp;\n\nint main(){\n    scanf("%d %lld", &N, &X);\n    mp.reserve(maxN*maxN);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &a[i]);\n        for(int j = 1; j < i; j++){\n            ll psum = a[i] + a[j];\n            if(psum >= X)   continue;\n            if(mp.find(X-psum) != mp.end()){\n                for(pii P : mp[X-psum]){\n                    if(P.first != j && P.second != j && P.first != i && P.second != i){\n                        printf("%d %d %d %d\\n", P.first, P.second, j, i);\n                        return 0;\n                    }\n                }\n            } else mp[psum].push_back({j, i});\n        }\n    }\n    printf("IMPOSSIBLE\\n");\n}\n',
  "1643":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nint N;\nll maxSum, curSum, x[maxN];\n\nint main(){\n    scanf("%d", &N);\n    maxSum = -INF;\n    for(int i = 0; i < N; i++){\n        scanf("%lld", &x[i]);\n        maxSum = max(maxSum, x[i]);\n    }\n\n    for(int i = 0; i < N; i++){\n        curSum += x[i];\n        maxSum = max(maxSum, curSum);\n        if(curSum < 0)  curSum = 0;\n    }\n    printf("%lld\\n", maxSum);\n}\n',
  "1644":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, A, B;\nll pre[maxN];\nmultiset<ll> S;\n\nint main(){\n    scanf("%d %d %d", &N, &A, &B);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &pre[i]);\n        pre[i] += pre[i-1];\n    }\n\n    for(int i = A; i <= B; i++)\n        S.insert(pre[i]);\n\n    ll best = *S.rbegin();\n    for(int i = 1; i+A <= N; i++){\n        S.erase(pre[i+A-1]);\n        S.insert(pre[min(i+B, N)]);\n        best = max(best, *S.rbegin()-pre[i]);\n    }\n\n    printf("%lld\\n", best);\n}',
  "1645":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, x[maxN], ds[maxN];\n\nint main(){\n    scanf("%d ", &N);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &x[i]);\n        int k = i-1;\n        while(x[k] >= x[i])\n            k = ds[k];\n        ds[i] = k;\n        printf("%d%c", ds[i], (" \\n")[i==N]);\n    }\n}\n',
  "1646":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, Q, a, b;\nll x[maxN+1];\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &x[i]);\n        x[i] += x[i-1];\n    }\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &a, &b);\n        printf("%lld\\n", x[b]-x[a-1]);\n    }\n}\n',
  "1647":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\nconst int logN = 19;\n\nint N, Q, a, b, l, k, x[maxN][logN];\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &x[i][0]);\n\n    for(int i = 1; i < logN; i++)\n        for(int j = 0; j <= N-(1<<i); j++)\n            x[j][i] = min(x[j][i-1], x[j+(1<<(i-1))][i-1]);\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &a, &b);\n        a--; b--;\n        l = b-a+1;\n        k = log2(l);\n        printf("%d\\n", min(x[a][k], x[b-(1<<k)+1][k]));\n    }\n}\n',
  "1648":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, Q, t, a, b;\nll x[maxN+1], ds[maxN+1];\n\nvoid update(int idx, ll val){\n    ll diff = val - x[idx];\n    for(int i = idx; i <= N; i += -i&i)\n        ds[i] += diff;\n    x[idx] = val;\n}\n\nll query(int idx){\n    ll sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum += ds[i];\n    return sum;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &x[0]);\n        update(i, x[0]);\n    }\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d %d", &t, &a, &b);\n        if(t == 1)  update(a, b);\n        else        printf("%lld\\n", query(b)-query(a-1));\n    }\n}\n',
  "1649":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5, SIZE = 4*maxN;\nconst int INF = 0x3f3f3f3f;\n\nint N, Q, t, a, b, lo[SIZE], hi[SIZE], mn[SIZE];\n\nvoid push(int i){\n\n}\n\nvoid pull(int i){\n    mn[i] = min(mn[2*i], mn[2*i+1]);\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        scanf("%d", &mn[i]);\n        return;\n    }\n    int m = l+(r-l)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid assign(int i, int l, int r, int v){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        mn[i] = v; return;\n    }\n\n    push(i);\n    assign(2*i, l, r, v);\n    assign(2*i+1, l, r, v);\n    pull(i);\n}\n\nint minimum(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])      return INF;\n    if(l <= lo[i] && hi[i] <= r)    return mn[i];\n\n    push(i);\n    int lmin = minimum(2*i, l, r);\n    int rmin = minimum(2*i+1, l, r);\n    pull(i);\n\n    return min(lmin, rmin);\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n\n    init(1, 1, N);\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d %d", &t, &a, &b);\n        if(t == 1)      assign(1, a, a, b);\n        else if(t == 2) printf("%d\\n", minimum(1, a, b));\n    }\n}\n',
  "1650":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, Q, a, b;\nll x[maxN+1];\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &x[i]);\n        x[i] ^= x[i-1];\n    }\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &a, &b);\n        printf("%lld\\n", x[b]^x[a-1]);\n    }\n}\n',
  "1651":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, Q, t, a, b, k;\nll x, ds[maxN];\n\nvoid update(int idx, ll val){\n    for(int i = idx; i <= N; i += -i&i)\n        ds[i] += val;\n}\n\nll query(int idx){\n    ll sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum += ds[i];\n    return sum;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &x);\n        update(i, x);\n        update(i+1, -x);\n    }\n    for(int q = 0; q < Q; q++){\n        scanf("%d", &t);\n        if(t == 1){\n            scanf("%d %d %lld", &a, &b, &x);\n            update(b+1, -x);\n            update(a, x);\n        } else if(t == 2){\n            scanf("%d", &k);\n            printf("%lld\\n", query(k));\n        }\n    }\n}\n',
  "1652":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1001;\n\nchar c;\nint N, Q, a[maxN][maxN];\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        for(int j = 1; j <= N; j++){\n            scanf(" %c", &c);\n            a[i][j] = a[i-1][j]+a[i][j-1]-a[i-1][j-1];\n            if(c == \'*\')    a[i][j]++;\n        }\n    }\n    for(int q = 0; q < Q; q++){\n        int x1, y1, x2, y2;\n        scanf("%d %d %d %d", &x1, &y1, &x2, &y2);\n        printf("%d\\n", a[x2][y2]-a[x2][y1-1]-a[x1-1][y2]+a[x1-1][y1-1]);\n    }\n}\n',
  "1653":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\nconst int maxN = 20;\nconst int INF = maxN+1;\n\nint N;\npii dp[1<<maxN];\nll X, w[maxN];\n\nint main(){\n    scanf("%d %lld", &N, &X);\n    for(int i = 0; i < N; i++)\n        scanf("%lld", &w[i]);\n\n    dp[0] = {1, 0};\n    for(int mask = 1; mask < (1<<N); mask++){\n        dp[mask] = {INF, 0};\n        for(int i = 0; i < N; i++){\n            if(mask&(1<<i)){\n                pii can = dp[mask^(1<<i)];\n                if(can.second + w[i] <= X){\n                    can.second += w[i];\n                } else {\n                    can.first++;\n                    can.second = w[i];\n                }\n                dp[mask] = min(dp[mask], can);\n            }\n        }\n    }\n\n    printf("%d\\n", dp[(1<<N)-1].first);\n}\n',
  "1655":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    Node *c[2];\n};\n\nint N, xum, best;\nNode *root;\n\nvoid update(int x){\n    Node *cur = root;\n    for(int i = 30; i >= 0; i--){\n        if(x&(1<<i)){\n            if(!cur->c[1])  cur->c[1] = new Node();\n            cur = cur->c[1];\n        } else {\n            if(!cur->c[0])  cur->c[0] = new Node();\n            cur = cur->c[0];\n        }\n    }\n}\n\nint query(int x){\n    int res = 0;\n    Node *cur = root;\n    for(int i = 30; i >= 0; i--){\n        if(x&(1<<i)){\n            if(cur->c[0]){\n                res += (1<<i);\n                cur = cur->c[0];\n            } else cur = cur->c[1];\n        } else {\n            if(cur->c[1]){\n                res += (1<<i);\n                cur = cur->c[1];\n            } else cur = cur->c[0];\n        }\n    }\n    return res;\n}\n\nint main(){\n    scanf("%d", &N);\n    root = new Node();\n    update(0);\n    for(int i = 0, x; i < N; i++){\n        scanf("%d", &x);\n        xum ^= x;\n        update(xum);\n        best = max(best, query(xum));\n    }\n    printf("%d\\n", best);\n}\n',
  "1660":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5;\n\nint N, x, l, sum, cnt, a[maxN+1];\n\nint main(){\n    scanf("%d %d", &N, &x);\n    for(int r = 1; r <= N; r++){\n        scanf("%d", &a[r]);\n        sum += a[r];\n        while(sum > x)\n            sum -= a[l++];\n        if(sum == x)    cnt++;\n    }\n    printf("%d\\n", cnt);\n}\n',
  "1661":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll X, a, cnt, pre;\nmap<ll,int> freq;\n\nint main(){\n    scanf("%d %lld", &N, &X);\n    freq[0] = 1;\n    for(int i = 0; i < N; i++){\n        scanf("%lld", &a);\n        pre += a;\n        cnt += freq[pre-X];\n        freq[pre]++;\n    }\n    printf("%lld\\n", cnt);\n}\n',
  "1662":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, pre, a, freq[maxN];\nll cnt;\n\nint mod(int x){\n    return (x % N + N) % N;\n}\n\nint main(){\n    scanf("%d", &N);\n    freq[0] = 1;\n    for(int i = 0; i < N; i++){\n        scanf("%d", &a);\n        pre = mod(pre+a);\n        cnt += freq[pre];\n        freq[pre]++;\n    }\n    printf("%lld\\n", cnt);\n}\n',
  "1664":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int logN = 17, maxT = 1e6;\n\nint N, Q, dp[maxT+1][logN+1];\nvector<int> movies[maxT+1];\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 0, a, b; i < N; i++){\n        scanf("%d %d", &a, &b);\n        movies[a].push_back(b);\n    }\n\n    priority_queue<int, vector<int>, greater<int>> ends;\n    for(int t = maxT; t >= 0; t--){\n        for(int b : movies[t])\n            ends.push(b);\n\n        dp[t][0] = ends.empty() ? maxT+1 : ends.top();\n    }\n    for(int k = 1; k <= logN; k++)\n        for(int t = 0; t <= maxT; t++)\n            dp[t][k] = dp[t][k-1] > maxT ? maxT+1 : dp[dp[t][k-1]][k-1];\n\n    for(int q = 0, a, b; q < Q; q++){\n        scanf("%d %d", &a, &b);\n        int ans = 0;\n        for(int k = logN; k >= 0; k--){\n            if(dp[a][k] <= b){\n                a = dp[a][k];\n                ans += (1<<k);\n            }\n        }\n        printf("%d\\n", ans);\n    }\n}',
  "1665":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 101, maxX = 5e3+1;\nconst ll MOD = 1e9+7;\n\nint N, X, t[maxN];\nll dp[maxN][maxN][maxX];\n\nint main(){\n    scanf("%d %d", &N, &X);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &t[i]);\n    sort(t+1, t+N+1);\n    t[0] = t[1];\n\n    dp[0][0][0] = 1;\n    for(int i = 1; i <= N; i++){\n        for(int j = N; j >= 0; j--){\n            for(int k = X; k >= 0; k--){\n                ll cnt = dp[i-1][j][k];\n                int newk = k + j * (t[i]-t[i-1]);\n                if(newk > X)    continue;\n\n                dp[i][j][newk] = (dp[i][j][newk] + (j+1) * cnt) % MOD;\n                if(j != N)  dp[i][j+1][newk] = (dp[i][j+1][newk] + cnt) % MOD;\n                if(j != 0)  dp[i][j-1][newk] = (dp[i][j-1][newk] + j * cnt) % MOD;\n            }\n        }\n    }\n\n    ll tot = 0;\n    for(int i = 0; i <= X; i++)\n        tot = (tot + dp[N][0][i]) % MOD;\n    printf("%lld\\n", tot);\n}',
  "1666":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint N, M, a, b, ds[100001];\nvector<pii> ans;\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 1; i <= N; i++) ds[i] = -1;\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        merge(a, b);\n    }\n\n    for(int i = 1; i < N; i++)\n        if(merge(i, i+1))\n            ans.push_back({i, i+1});\n\n    printf("%d\\n", (int) ans.size());\n    for(pii P : ans)\n        printf("%d %d\\n", P.first, P.second);\n}\n',
  "1667":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, M, K, a, b, p[maxN], dist[maxN];\nbool vis[maxN];\nvector<int> G[maxN];\nqueue<int> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    Q.push(1);\n    vis[1] = true;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        for(int v : G[u]){\n            if(!vis[v]){\n                dist[v] = dist[u]+1;\n                vis[v] = true;\n                p[v] = u;\n                Q.push(v);\n            }\n        }\n    }\n\n    if(!vis[N]){\n        printf("IMPOSSIBLE\\n");\n        return 0;\n    }\n\n    int u = N;\n    K = dist[N];\n    vector<int> ans(K+1);\n    for(int i = K; i >= 0; i--){\n        ans[i] = u;\n        u = p[u];\n    }\n\n    printf("%d\\n", K+1);\n    for(int i = 0; i <= K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K]);\n}\n',
  "1668":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, M, a, b;\nbool possible, vis[maxN], team[maxN];\nvector<int> G[maxN];\n\nvoid dfs(int u, int p = 0){\n    for(int v : G[u]){\n        if(v != p){\n            if(!vis[v]){\n                team[v] = !team[u];\n                vis[v] = true;\n                dfs(v, u);\n            } else\n                if(team[v] == team[u])\n                    possible = false;\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    possible = true;\n    for(int i = 1; i <= N; i++){\n        if(!vis[i]){\n            vis[i] = true;\n            dfs(i);\n        }\n    }\n\n    if(!possible)\n        printf("IMPOSSIBLE\\n");\n    else\n        for(int i = 1; i <= N; i++)\n            printf("%d%c", (team[i] ? 1 : 2), (" \\n")[i==N]);\n}\n',
  "1669":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, M, a, b, p[maxN], ds[maxN];\nvector<int> ans, G[maxN];\n\nvoid dfs(int u){\n    for(int v : G[u]){\n        if(v != p[u]){\n            p[v] = u;\n            dfs(v);\n        }\n    }\n}\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    fill(ds+1, ds+N+1, -1);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        if(!merge(a, b)){\n            dfs(a);\n\n            int u = b;\n            while(u != 0){\n                ans.push_back(u);\n                u = p[u];\n            }\n\n            int K = ans.size();\n            printf("%d\\n", K+1);\n            for(int j = 0; j < K; j++)\n                printf("%d ", ans[j]);\n            printf("%d\\n", b);\n\n            return 0;\n        } else {\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n    }\n    printf("IMPOSSIBLE\\n");\n}\n',
  "1670":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 9;\nconst int x[] = {0, 1, 2, 3, 4, 5, 1, 2, 4, 5, 7, 8};\nconst int y[] = {3, 4, 5, 6, 7, 8, 0, 1, 3, 4, 6, 7};\n\nunordered_map<string,int> dist;\nqueue<string> Q;\nstring perm;\n\nvoid init(){\n    perm = "123456789";\n\n    dist[perm] = 1;\n    Q.push(perm);\n    while(!Q.empty()){\n        perm = Q.front(); Q.pop();\n        int d = dist[perm];\n        for(int i = 0; i < 12; i++){\n            swap(perm[x[i]], perm[y[i]]);\n            if(!dist[perm]){\n                dist[perm] = d+1;\n                Q.push(perm);\n            }\n            swap(perm[x[i]], perm[y[i]]);\n        }\n    }\n}\n\nint main(){\n    init();\n    for(int i = 0; i < N; i++)\n        scanf(" %c", &perm[i]);\n    printf("%d\\n", dist[perm]-1);\n}\n',
  "1671":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5;\n\nstruct Edge { int v; ll w; };\nstruct Node {\n    int id; ll dist;\n    friend bool operator<(const Node &a, const Node &b){\n        return a.dist > b.dist;\n    }\n};\n\nint N, M, a, b;\nll dist[maxN+1], c;\nvector<Edge> G[maxN+1];\npriority_queue<Node> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d %lld", &a, &b, &c);\n        G[a].push_back({b, c});\n    }\n\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    Q.push({1, 0});\n    while(!Q.empty()){\n        ll d = Q.top().dist;\n        int u = Q.top().id;\n        Q.pop();\n\n        if(d > dist[u]) continue;\n\n        for(Edge e : G[u]){\n            if(dist[e.v] > d+e.w){\n                dist[e.v] = d+e.w;\n                Q.push({e.v, d+e.w});\n            }\n        }\n    }\n\n    for(int i = 1; i <= N; i++)\n        printf("%lld%c", dist[i], (" \\n")[i==N]);\n}\n',
  "1672":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 500;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nint N, M, Q, a, b;\nll dist[maxN+1][maxN+1], c;\n\nint main(){\n    scanf("%d %d %d", &N, &M, &Q);\n    memset(dist, 0x3f, sizeof(dist));\n    for(int i = 0; i < M; i++){\n        scanf("%d %d %lld", &a, &b, &c);\n        dist[a][b] = min(dist[a][b], c);\n        dist[b][a] = min(dist[b][a], c);\n    }\n\n    for(int i = 1; i <= N; i++) dist[i][i] = 0;\n    for(int k = 1; k <= N; k++)\n        for(int i = 1; i <= N; i++)\n            for(int j = 1; j <= N; j++)\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &a, &b);\n        printf("%lld\\n", (dist[a][b] >= INF ? -1 : dist[a][b]));\n    }\n}\n',
  "1673":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2501;\nconst int maxM = 5001;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nstruct Edge {\n    int a, b; ll c;\n} edges[maxM];\n\nint N, M;\nll dp[maxN];\nbool vis[maxN], visR[maxN];\nvector<int> G[maxN], GR[maxN];\n\nvoid dfs(int u){\n    vis[u] = true;\n    for(int v : G[u])\n        if(!vis[v])\n            dfs(v);\n}\n\nvoid dfsR(int u){\n    visR[u] = true;\n    for(int v : GR[u])\n        if(!visR[v])\n            dfsR(v);\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        ll c;\n        scanf("%d %d %lld", &a, &b, &c);\n        edges[i] = {a, b, -c};\n        G[a].push_back(b);\n        GR[b].push_back(a);\n    }\n    dfs(1); dfsR(N);\n\n    fill(dp+2, dp+N+1, INF);\n    bool improvement = true;\n    for(int iter = 0; iter < N && improvement; iter++){\n        improvement = false;\n        for(int i = 0; i < M; i++){\n            int u = edges[i].a;\n            int v = edges[i].b;\n            ll w = edges[i].c;\n\n            if(dp[v] > dp[u]+w){\n                dp[v] = dp[u]+w;\n                improvement = true;\n\n                if(iter == N-1 && vis[v] && visR[v]){\n                    printf("-1\\n");\n                    return 0;\n                }\n            }\n        }\n    }\n\n    printf("%lld\\n", -dp[N]);\n}',
  "1674":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5;\n\nint N, p[maxN+1], sz[maxN+1];\nvector<int> G[maxN+1];\n\nvoid dfs(int u){\n    sz[u] = 1;\n    for(int v : G[u]){\n        dfs(v);\n        sz[u] += sz[v];\n    }\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 2; i <= N; i++){\n        scanf("%d", &p[i]);\n        G[p[i]].push_back(i);\n    }\n\n    dfs(1);\n\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", sz[i]-1, (" \\n")[i==N]);\n}\n',
  "1675":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n#define f first\n#define s second\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> edge;\nconst int maxN = 1e5+1;\nconst int maxM = 2e5+1;\n\nint N, M, a, b, c, ds[maxN];\nlong long sum;\nedge edges[maxM];\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    fill(ds+1, ds+N+1, -1);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d %d", &a, &b, &c);\n        edges[i] = {c, {a, b}};\n    }\n    sort(edges, edges+M);\n\n    for(int i = 0; i < M; i++){\n        edge e = edges[i];\n        if(merge(e.s.f, e.s.s)){\n            sum += e.f;\n            N--;\n        }\n    }\n\n    if(N == 1)  printf("%lld\\n", sum);\n    else        printf("IMPOSSIBLE\\n");\n}\n',
  "1676":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5;\n\nint N, M, a, b, components, largest, ds[maxN+1];\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    fill(ds+1, ds+N+1, -1);\n\n    components = N;\n    largest = 1;\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        if(merge(a, b)){\n            components--;\n            largest = max(largest, -ds[find(a)]);\n        }\n        printf("%d %d\\n", components, largest);\n    }\n}\n',
  "1677":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\nconst int maxM = 2e5;\ntypedef pair<int,int> pii;\n\nint N, M, K, a, b, cnt, ds[maxN], ans[maxM];\npii edges[maxM], queries[maxM];\nset<pii> S;\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n    fill(ds+1, ds+N+1, -1);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        if(b > a)   swap(a, b);\n        edges[i] = {a, b};\n    }\n    for(int i = 0; i < K; i++){\n        scanf("%d %d", &a, &b);\n        if(b > a)   swap(a, b);\n        queries[i] = {a, b};\n        S.insert({a, b});\n    }\n\n    cnt = N;\n    for(int i = 0; i < M; i++)\n        if(S.find(edges[i]) == S.end())\n            if(merge(edges[i].first, edges[i].second))\n                cnt--;\n\n    for(int i = K-1; i >= 0; i--){\n        ans[i] = cnt;\n        if(merge(queries[i].first, queries[i].second))\n            cnt--;\n    }\n\n    for(int i = 0; i < K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K-1]);\n}\n',
  "1678":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, M, start, finish, p[maxN], vis[maxN];\nvector<int> ans, G[maxN];\n\nvoid dfs(int u){\n    vis[u] = 1;\n    for(int v : G[u]){\n        if(vis[v] == 0){\n            p[v] = u;\n            dfs(v);\n            if(start)\n                return;\n        } else if(vis[v] == 1){\n            finish = u;\n            start = v;\n            return;\n        }\n    }\n    vis[u] = 2;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n    }\n\n    for(int i = 1; i <= N && !start; i++)\n        if(vis[i] == 0)\n            dfs(i);\n\n    if(!start){\n        printf("IMPOSSIBLE\\n");\n        return 0;\n    }\n\n    ans.push_back(start);\n    for(int u = finish; u != start; u = p[u])\n        ans.push_back(u);\n    ans.push_back(start);\n    reverse(ans.begin(), ans.end());\n\n    int K = (int) ans.size();\n    printf("%d\\n", K);\n    for(int i = 0; i < K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K-1]);\n}\n',
  "1679":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, M, a, b, cnt, in[maxN];\nvector<int> ans, G[maxN];\nqueue<int> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        in[b]++;\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(in[i] == 0)\n            Q.push(i);\n\n    cnt = N;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        ans.push_back(u);\n        cnt--;\n\n        for(int v : G[u]){\n            in[v]--;\n            if(in[v] == 0)\n                Q.push(v);\n        }\n    }\n\n    if(cnt)\n        printf("IMPOSSIBLE\\n");\n    else\n        for(int i = 0; i < N; i++)\n            printf("%d%c", ans[i], (" \\n")[i==N-1]);\n}\n',
  "1680":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nbool vis[maxN];\nint N, M, K, a, b, in[maxN], p[maxN], l[maxN], ans[maxN];\nvector<int> G[maxN];\nqueue<int> Q;\n\nvoid dfs(int u, int par = 0){\n    vis[u] = true;\n    for(int v : G[u])\n        if(v != par && !vis[v])\n            dfs(v, u);\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        in[b]++;\n    }\n\n    dfs(1);\n    if(!vis[N]){\n        printf("IMPOSSIBLE\\n");\n        return 0;\n    }\n\n    fill(l+2, l+maxN, -1);\n    for(int i = 1; i <= N; i++)\n        if(in[i] == 0)\n            Q.push(i);\n\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        for(int v : G[u]){\n            if(l[u] != -1 && l[v] < l[u]+1){\n                l[v] = l[u] + 1;\n                p[v] = u;\n            }\n            in[v]--;\n            if(in[v] == 0)\n                Q.push(v);\n        }\n    }\n\n    K = l[N] - l[1];\n    printf("%d\\n", K+1);\n    for(int i = K, u = N; i >= 0; i--){\n        ans[i] = u;\n        u = p[u];\n    }\n    for(int i = 0; i <= K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K]);\n}\n',
  "1681":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+1;\nconst ll MOD = 1e9+7;\n\nint N, M, a, b, cnt, in[maxN];\nll dp[maxN];\nvector<int> G[maxN];\nqueue<int> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        in[b]++;\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(in[i] == 0)\n            Q.push(i);\n\n    dp[1] = 1;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        for(int v : G[u]){\n            dp[v] = (dp[v] + dp[u]) % MOD;\n            in[v]--;\n            if(in[v] == 0)\n                Q.push(v);\n        }\n    }\n\n    printf("%lld\\n", dp[N]);\n}\n',
  "1682":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, M, a, b;\nbool vis1[maxN], vis2[maxN];\nvector<int> G1[maxN], G2[maxN];\n\nvoid dfs1(int u = 1, int p = 0){\n    vis1[u] = true;\n    for(int v : G1[u])\n        if(v != p && !vis1[v])\n            dfs1(v, u);\n}\n\nvoid dfs2(int u = 1, int p = 0){\n    vis2[u] = true;\n    for(int v : G2[u])\n        if(v != p && !vis2[v])\n            dfs2(v, u);\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G1[a].push_back(b);\n        G2[b].push_back(a);\n    }\n    dfs1();\n    dfs2();\n    for(int i = 1; i <= N; i++){\n        if(!vis1[i] || !vis2[i]){\n            printf("NO\\n");\n            if(!vis1[i])    printf("1 %d\\n", i);\n            else            printf("%d 1\\n", i);\n            return 0;\n        }\n    }\n    printf("YES\\n");\n}\n',
  "1683":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nbool vis[maxN];\nint N, M, rt[maxN];\nvector<int> ord, comp, G[maxN], GR[maxN];\n\nvoid dfs1(int u){\n    vis[u] = true;\n    for(int v : G[u])\n        if(!vis[v])\n            dfs1(v);\n    ord.push_back(u);\n}\n\nvoid dfs2(int u){\n    vis[u] = true;\n    comp.push_back(u);\n    for(int v : GR[u])\n        if(!vis[v])\n            dfs2(v);\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        GR[b].push_back(a);\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(!vis[i])\n            dfs1(i);\n\n    int K = 0;\n    fill(vis+1, vis+N+1, false);\n    reverse(ord.begin(), ord.end());\n    for(int u : ord){\n        if(!vis[u]){\n            dfs2(u);\n            K++;\n            for(int v : comp)\n                rt[v] = K;\n            comp.clear();\n        }\n    }\n\n    printf("%d\\n", K);\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", rt[i], (" \\n")[i==N]);\n}',
  "1684":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nbool vis[maxN];\nchar ans[maxN];\nint N, M, K, in[maxN], rt[maxN];\nvector<int> ord, comp, G[maxN], GR[maxN], C[maxN], SCC[maxN];\n\nint flip(int x){\n    return (x&1 ? x+1 : x-1);\n}\n\nvoid add_edge(char c1, int a, char c2, int b){\n    a = 2*a - (c1 == \'-\');\n    b = 2*b - (c2 == \'-\');\n    G[flip(a)].push_back(b);\n    G[flip(b)].push_back(a);\n    GR[a].push_back(flip(b));\n    GR[b].push_back(flip(a));\n}\n\nvoid dfs1(int u){\n    vis[u] = true;\n    for(int v : G[u])\n        if(!vis[v])\n            dfs1(v);\n    ord.push_back(u);\n}\n\nvoid dfs2(int u){\n    vis[u] = true;\n    comp.push_back(u);\n    for(int v : GR[u])\n        if(!vis[v])\n            dfs2(v);\n}\n\nint main(){\n    scanf("%d %d", &M, &N);\n    for(int i = 0, a, b; i < M; i++){\n        char c1, c2;\n        scanf(" %c %d %c %d", &c1, &a, &c2, &b);\n        add_edge(c1, a, c2, b);\n    }\n\n    for(int i = 1; i <= 2*N; i++)\n        if(!vis[i])\n            dfs1(i);\n\n    fill(vis+1, vis+2*N+1, false);\n    reverse(ord.begin(), ord.end());\n    for(int u : ord){\n        if(!vis[u]){\n            dfs2(u);\n            K++;\n            for(int v : comp){\n                rt[v] = K;\n                C[K].push_back(v);\n            }\n            comp.clear();\n        }\n    }\n\n    // Impossible iff x and not(x) belong to same SCC\n    for(int i = 1; i <= N; i++){\n        if(rt[2*i] == rt[2*i-1]){\n            printf("IMPOSSIBLE\\n");\n            return 0;\n        }\n    }\n\n    for(int u = 1; u <= 2*N; u++){\n        for(int v : G[u]){\n            if(rt[u] != rt[v]){\n                SCC[rt[u]].push_back(rt[v]);\n                in[rt[v]]++;\n            }\n        }\n    }\n\n    queue<int> Q;\n    ord.clear();\n    for(int u = 1; u <= K; u++){\n        if(in[u] == 0){\n            ord.push_back(u);\n            Q.push(u);\n        }\n    }\n\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        for(int v : SCC[u]){\n            in[v]--;\n            if(in[v] == 0){\n                ord.push_back(v);\n                Q.push(v);\n            }\n        }\n    }\n\n    fill(vis+1, vis+N+1, false);\n    reverse(ord.begin(), ord.end());\n    for(int k : ord){\n        for(int u : C[k]){\n            int i = (u+1)/2;\n            if(!vis[i]){\n                ans[i] = (u&1 ? \'-\' : \'+\');\n                vis[i] = true;\n            }\n        }\n    }\n\n    for(int i = 1; i <= N; i++)\n        printf("%c%c", ans[i], (" \\n")[i==N]);\n}',
  "1686":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+1;\n\nbool vis[maxN];\nint N, M, K, rt[maxN];\nll k[maxN], ck[maxN], dp[maxN];\nvector<int> ord, comp, G[maxN], GR[maxN], SCC[maxN];\n\nvoid dfs1(int u){\n    vis[u] = true;\n    for(int v : G[u])\n        if(!vis[v])\n            dfs1(v);\n    ord.push_back(u);\n}\n\nvoid dfs2(int u){\n    vis[u] = true;\n    comp.push_back(u);\n    for(int v : GR[u])\n        if(!vis[v])\n            dfs2(v);\n}\n\nvoid dfs3(int u){\n    vis[u] = true;\n    dp[u] = ck[u];\n    for(int v : SCC[u]){\n        if(!vis[v])\n            dfs3(v);\n        dp[u] = max(dp[u], dp[v]+ck[u]);\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &k[i]);\n\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        GR[b].push_back(a);\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(!vis[i])\n            dfs1(i);\n\n    fill(vis+1, vis+N+1, false);\n    reverse(ord.begin(), ord.end());\n    for(int u : ord){\n        if(!vis[u]){\n            dfs2(u);\n            K++;\n            for(int v : comp){\n                ck[K] += k[v];\n                rt[v] = K;\n            }\n            comp.clear();\n        }\n    }\n\n    for(int u = 1; u <= N; u++)\n        for(int v : G[u])\n            if(rt[v] != rt[u])\n                SCC[rt[u]].push_back(rt[v]);\n\n    fill(vis+1, vis+K+1, false);\n    for(int i = 1; i <= K; i++)\n        if(!vis[i])\n            dfs3(i);\n\n    ll best = 0;\n    for(int i = 1; i <= K; i++)\n        best = max(best, dp[i]);\n    printf("%lld\\n", best);\n}',
  "1687":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\nconst int logK = 20;\n\nint N, Q, x, k, p[maxN][logK];\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 2; i <= N; i++)\n        scanf("%d", &p[i][0]);\n    for(int j = 1; j < logK; j++)\n        for(int i = 1; i <= N; i++)\n            p[i][j] = p[p[i][j-1]][j-1];\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &x, &k);\n        for(int i = 0; i < logK; i++)\n            if(k&(1<<i))\n                x = p[x][i];\n        printf("%d\\n", x ? x : -1);\n    }\n}\n',
  "1688":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\nconst int logN = 20;\n\nint N, Q, e, a, b, p[maxN][logN];\nint timer, in[maxN], out[maxN];\nvector<int> G[maxN];\n\nvoid dfs(int u = 1, int par = 1){\n    in[u] = ++timer;\n    p[u][0] = par;\n    for(int i = 1; i < logN; i++)\n        p[u][i] = p[p[u][i-1]][i-1];\n    for(int v : G[u])\n        if(v != par)\n            dfs(v, u);\n    out[u] = ++timer;\n}\n\nbool ancestor(int u, int v){\n    return in[u] <= in[v] && out[u] >= out[v];\n}\n\nint lca(int u, int v){\n    if(ancestor(u, v))  return u;\n    if(ancestor(v, u))  return v;\n    for(int i = logN-1; i >= 0; i--)\n        if(!ancestor(p[u][i], v))\n            u = p[u][i];\n    return p[u][0];\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 2; i <= N; i++){\n        scanf("%d", &e);\n        G[e].push_back(i);\n        G[i].push_back(e);\n    }\n\n    dfs();\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &a, &b);\n        printf("%d\\n", lca(a, b));\n    }\n}\n',
  "1689":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef array<int,3> triple;\nconst int N = 8;\nconst int h[] = {-2, -1, 1, 2, 2, 1, -1, -2};\nconst int v[] = {1, 2, 2, 1, -1, -2, -2, -1};\n\nbool vis[N][N];\nint ans[N][N], deg[N][N];\n\nbool inBounds(int x, int y){\n    return 0 <= x && x < N && 0 <= y && y < N;\n}\n\nvoid init(){\n    for(int x = 0; x < N; x++){\n        for(int y = 0; y < N; y++){\n            for(int i = 0; i < N; i++){\n                int dx = x + h[i];\n                int dy = y + v[i];\n                if(inBounds(dx, dy))\n                    deg[x][y]++;\n            }\n        }\n    }\n}\n\nvoid mark(int id, int x, int y){\n    ans[x][y] = id;\n    vis[x][y] = true;\n    for(int i = 0; i < N; i++){\n        int dx = x + h[i];\n        int dy = y + v[i];\n        if(inBounds(dx, dy) && !vis[dx][dy])\n            deg[dx][dy]--;\n    }\n}\n\nvoid unmark(int x, int y){\n    ans[x][y] = -1;\n    vis[x][y] = false;\n    for(int i = 0; i < N; i++){\n        int dx = x + h[i];\n        int dy = y + v[i];\n        if(inBounds(dx, dy) && !vis[dx][dy])\n            deg[dx][dy]++;\n    }\n}\n\nbool solve(int id, int x, int y){\n    mark(id, x, y);\n    if(id >= 64)    return true;\n\n    vector<triple> options;\n    for(int i = 0; i < N; i++){\n        int dx = x + h[i];\n        int dy = y + v[i];\n        if(inBounds(dx, dy) && !vis[dx][dy])\n            options.push_back({deg[dx][dy], dx, dy});\n    }\n    sort(options.begin(), options.end());\n\n    for(triple T : options)\n        if(solve(id+1, T[1], T[2]))\n            return true;\n\n    unmark(x, y);\n    return false;\n}\n\nint main(){\n    init();\n    int x, y;\n    scanf("%d %d", &x, &y);\n    assert(solve(1, y-1, x-1));\n\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            printf("%d%c", ans[i][j], (" \\n")[j==N-1]);\n}\n',
  "1690":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxN = 20;\nconst int SIZE = 1<<maxN;\nconst ll MOD = 1e9+7;\n\nint N, M;\nbool inqueue[maxN][SIZE];\nll dp[maxN][SIZE];\nvector<int> G[maxN];\nqueue<pii> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a-1].push_back(b-1);\n    }\n\n    dp[0][1] = 1;\n    Q.push({0, 1});\n    inqueue[0][1] = true;\n    while(!Q.empty()){\n        int u = Q.front().first;\n        int mask = Q.front().second;\n        Q.pop();\n\n        if(u != N-1){\n            for(int v : G[u]){\n                int newMask = mask|(1<<v);\n                if((mask&(1<<v)) == 0){\n                    dp[v][newMask] += dp[u][mask];\n                    dp[v][newMask] %= MOD;\n                    if(!inqueue[v][newMask]){\n                        Q.push({v, newMask});\n                        inqueue[v][newMask] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    printf("%lld\\n", dp[N-1][(1<<N)-1]);\n}',
  "1691":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 1e5+1;\nconst int maxM = 2e5+1;\n\nint N, M, deg[maxN];\nbool tour_exists, used[maxM];\nvector<pii> G[maxN];\nvector<int> tour;\nstack<int> S;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back({b, i});\n        G[b].push_back({a, i});\n        deg[a]++; deg[b]++;\n    }\n\n    tour_exists = true;\n    for(int i = 1; i <= N; i++)\n        if(deg[i]&1)\n            tour_exists = false;\n\n    if(!tour_exists){\n        printf("IMPOSSIBLE\\n");\n        return 0;\n    }\n\n    S.push(1);\n    while(!S.empty()){\n        int u = S.top();\n        if(deg[u]){\n            while(!G[u].empty()){\n                int v = G[u].back().first;\n                int id = G[u].back().second;\n                G[u].pop_back();\n\n                if(!used[id]){\n                    deg[u]--; deg[v]--;\n                    used[id] = true;\n                    S.push(v);\n                    break;\n                }\n            }\n        } else {\n            tour.push_back(u);\n            S.pop();\n        }\n    }\n\n    // Should be M+1 nodes in the Euler tour\n    // If not, it means the graph was not connected\n    if((int) tour.size() != M+1)\n        printf("IMPOSSIBLE\\n");\n    else\n        for(int i = 0; i <= M; i++)\n            printf("%d%c", tour[i], (" \\n")[i==M]);\n}\n',
  "1692":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 15;\nconst int SIZE = (1<<maxN)+maxN;\n\nchar ans[SIZE];\nint N, ansptr;\nvector<int> G[SIZE];\nstack<int> S;\n\nvoid init(){\n    for(int u = 0; u < 1<<(N-1); u++){\n        int v = (u<<1)%(1<<(N-1));\n        G[u].push_back(v);\n        G[u].push_back(v|1);\n    }\n}\n\nvoid solve(){\n    S.push(0);\n    while(!S.empty()){\n        int u = S.top();\n        if(!G[u].empty()){\n            int v = G[u].back();\n            G[u].pop_back();\n            S.push(v);\n        } else {\n            ans[ansptr++] = (char) (u&1) + \'0\';\n            S.pop();\n        }\n    }\n    for(int i = 0; i < N-2; i++)\n        ans[ansptr++] = \'0\';\n}\n\nint main(){\n    scanf("%d", &N);\n    if(N == 1){\n        printf("01");\n        return 0;\n    }\n\n    init();\n    solve();\n    for(int i = 0; i < ansptr; i++)\n        printf("%c", ans[i]);\n}',
  "1693":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nbool vis[maxN];\nint N, M, in[maxN];\nvector<int> tour, G[maxN];\nstack<int> S;\n\nvoid dfs(int u = 1, int p = -1){\n    vis[u] = true;\n    for(int v : G[u])\n        if(v != p && !vis[v])\n            dfs(v, u);\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        in[b]++;\n    }\n\n    dfs();\n    bool exists = vis[N];\n    exists &= (in[1]+1 == (int) G[1].size());\n    exists &= (in[N]-1 == (int) G[N].size());\n    for(int i = 2; i < N; i++){\n        exists &= (in[i] == (int) G[i].size());\n        if(!vis[i]) exists &= (in[i] == 0 && G[i].size() == 0);\n    }\n\n    if(!exists){\n        printf("IMPOSSIBLE\\n");\n        return 0;\n    }\n\n    S.push(1);\n    while(!S.empty()){\n        int u = S.top();\n        if(!G[u].empty()){\n            int v = G[u].back();\n            G[u].pop_back();\n            S.push(v);\n        } else {\n            tour.push_back(u);\n            S.pop();\n        }\n    }\n\n    reverse(tour.begin(), tour.end());\n    for(int i = 0; i < M+1; i++)\n        printf("%d%c", tour[i], (" \\n")[i==M]);\n}',
  "1694":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,ll> pil;\nconst int maxN = 501;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nint N, M, p[maxN];\nll cap[maxN][maxN];\nvector<int> G[maxN];\n\nll bfs(int s = 1, int t = N){\n    fill(p+1, p+N+1, -1);\n    p[s] = -2;\n\n    queue<pil> Q;\n    Q.push({s, INF});\n    while(!Q.empty()){\n        int u = Q.front().first;\n        ll f = Q.front().second;\n        Q.pop();\n\n        for(int v : G[u]){\n            if(p[v] == -1 && cap[u][v]){\n                p[v] = u;\n                ll aug = min(f, cap[u][v]);\n                if(v == t)  return aug;\n                Q.push({v, aug});\n            }\n        }\n    }\n\n    return 0;\n}\n\nll maxflow(int s = 1, int t = N){\n    ll flow = 0, aug = 0;\n    while(aug = bfs()){\n        flow += aug;\n        int u = t;\n        while(u != s){\n            int v = p[u];\n            cap[v][u] -= aug;\n            cap[u][v] += aug;\n            u = v;\n        }\n    }\n    return flow;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        ll c;\n        scanf("%d %d %lld", &a, &b, &c);\n        G[a].push_back(b);\n        G[b].push_back(a);\n        cap[a][b] += c;\n    }\n    printf("%lld\\n", maxflow());\n}',
  "1695":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 501;\nconst int INF = 0x3f3f3f3f;\n\nint N, M, p[maxN], cap[maxN][maxN];\nbool vis[maxN];\nvector<int> G[maxN];\n\nint bfs(int s = 1, int t = N){\n    fill(p+1, p+N+1, -1);\n    p[s] = -2;\n\n    queue<pii> Q;\n    Q.push({s, INF});\n    while(!Q.empty()){\n        int u = Q.front().first;\n        int f = Q.front().second;\n        Q.pop();\n\n        for(int v : G[u]){\n            if(p[v] == -1 && cap[u][v]){\n                p[v] = u;\n                int aug = min(f, cap[u][v]);\n                if(v == t)  return aug;\n                Q.push({v, aug});\n            }\n        }\n    }\n\n    return 0;\n}\n\nvoid dfs(int u = 1){\n    vis[u] = true;\n    for(int v : G[u])\n        if(!vis[v] && cap[u][v])\n            dfs(v);\n}\n\nint maxflow(int s = 1, int t = N){\n    int flow = 0, aug = 0;\n    while(aug = bfs()){\n        flow += aug;\n        int u = t;\n        while(u != s){\n            int v = p[u];\n            cap[v][u] -= aug;\n            cap[u][v] += aug;\n            u = v;\n        }\n    }\n    return flow;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n        cap[a][b]++;\n        cap[b][a]++;\n    }\n    printf("%d\\n", maxflow());\n\n    dfs();\n    for(int u = 1; u <= N; u++){\n        if(!vis[u]) continue;\n        for(int v : G[u])\n            if(!vis[v])\n                printf("%d %d\\n", u, v);\n    }\n}',
  "1696":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 505;\n\nbool used[maxN];\nint N, M, K, cnt, mt[maxN];\nvector<int> G[maxN];\nvector<pii> pairs;\n\nbool kuhns(int u){\n    if(used[u]) return false;\n\n    used[u] = true;\n    for(int v : G[u]){\n        if(!mt[v] || kuhns(mt[v])){\n            mt[v] = u;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n    for(int i = 0, a, b; i < K; i++){\n        scanf("%d %d", &a, &b);\n        G[b].push_back(a);\n    }\n\n    for(int i = 1; i <= M; i++){\n        fill(used+1, used+N+1, false);\n        kuhns(i);\n    }\n\n    cnt = 0;\n    for(int i = 1; i <= N; i++){\n        if(mt[i]){\n            pairs.push_back({i, mt[i]});\n            cnt++;\n        }\n    }\n\n    printf("%d\\n", cnt);\n    for(pii P : pairs)\n        printf("%d %d\\n", P.first, P.second);\n}',
  "1697":
    '#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef pair<int,int> pii;\n\nint N, K;\nvector<pii> added, ans;\ntree<pii, null_type, less<pii>, rb_tree_tag,\ntree_order_statistics_node_update> T;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1, x; i <= N; i++){\n        scanf("%d", &x);\n        T.insert({x, i});\n    }\n\n    for(int i = N-1; i >= 0; i--){\n        pii P = *T.find_by_order(i);\n        T.erase(T.find_by_order(i));\n        int degu = P.first;\n        int u = P.second;\n\n        added.clear();\n        for(int j = 1; j <= degu; j++){\n            if(i-j < 0 || (*T.find_by_order(i-j)).first == 0){\n                printf("IMPOSSIBLE\\n");\n                return 0;\n            }\n\n            pii Q = *T.find_by_order(i-j);\n            T.erase(T.find_by_order(i-j));\n            int degv = Q.first;\n            int v = Q.second;\n\n            ans.push_back({min(u, v), max(u, v)});\n            added.push_back({degv-1, v});\n        }\n\n        for(pii Q : added)\n            T.insert({Q.first, Q.second});\n    }\n\n    sort(ans.begin(), ans.end());\n    K = (int) ans.size();\n    printf("%d\\n", K);\n    for(int i = 0; i < K; i++)\n        printf("%d %d\\n", ans[i].first, ans[i].second);\n}',
  "1698":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5+1;\n\nbool vis[maxN];\nint N, a[maxN];\nvector<int> cycle;\nvector<pii> ans;\n\nbool zero_rounds(){\n    for(int i = 1; i <= N; i++)\n        if(a[i] != i)\n            return false;\n\n    printf("0\\n");\n    return true;\n}\n\nbool one_round(bool second = false){\n    for(int i = 1; i <= N; i++){\n        if(a[i] != i){\n            if(i != a[a[i]])    { ans.clear(); return false; }\n            else if(i < a[i])   ans.push_back({i, a[i]});\n        }\n    }\n\n    if(!second) printf("1\\n");\n    printf("%d\\n", (int) ans.size());\n    for(pii p : ans){\n        printf("%d %d\\n", p.first, p.second);\n        swap(a[p.first], a[p.second]);\n    }\n    return true;\n}\n\nvoid dfs(int u){\n    vis[u] = true;\n    cycle.push_back(u);\n    if(!vis[a[u]])  dfs(a[u]);\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &a[i]);\n\n    if(!zero_rounds() && !one_round()){\n        printf("2\\n");\n\n        for(int i = 1; i <= N; i++){\n            if(!vis[i]){\n                dfs(i);\n                int K = (int) cycle.size();\n                for(int u = 0; u < K/2; u++){\n                    ans.push_back({cycle[u], cycle[K-u-1]});\n                    swap(a[cycle[u]], a[cycle[K-u-1]]);\n                }\n                cycle.clear();\n            }\n        }\n\n        printf("%d\\n", (int) ans.size());\n        for(pii p : ans)\n            printf("%d %d\\n", p.first, p.second);\n\n        ans.clear();\n        one_round(true);\n    }\n}',
  "1699":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, M, ds[maxN], vis[maxN];\nvector<int> G[maxN], CC[maxN];\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nbool dfs(int u){\n    vis[u] = -1;\n    bool hascycle = false;\n    for(int v : G[u]){\n        if(vis[v] == -1)        return true;\n        else if(vis[v] == 0)    hascycle |= dfs(v);\n    }\n    vis[u] = 1;\n    return hascycle;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n\n    fill(ds+1, ds+N+1, -1);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        merge(a, b);\n    }\n\n    int K = 0;\n    unordered_map<int,int> getID;\n    for(int u = 1; u <= N; u++){\n        int rep = find(u);\n        if(!getID[rep])\n            getID[rep] = ++K;\n        CC[getID[rep]].push_back(u);\n    }\n\n    int ans = 0;\n    for(int k = 1; k <= K; k++){\n        int sz = (int) CC[k].size();\n        bool hascycle = false;\n        for(int u : CC[k])\n            if(!hascycle && vis[u] == 0)\n                hascycle |= dfs(u);\n        ans += (hascycle ? sz : sz-1);\n    }\n    printf("%d\\n", ans);\n}',
  "1700":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, treeID, name[2][maxN];\nvector<int> G[2][maxN];\nmap<vector<int>,int> mp;\n\nvoid reset(){\n    for(int t = 0; t < 2; t++)\n        for(int i = 1; i <= N; i++)\n            G[t][i].clear();\n}\n\nvoid dfs(int t, int u, int p){\n    vector<int> childNames;\n    for(int v : G[t][u]){\n        if(v != p){\n            dfs(t, v, u);\n            childNames.push_back(name[t][v]);\n        }\n    }\n    sort(childNames.begin(), childNames.end());\n    if(!mp[childNames]) mp[childNames] = ++treeID;\n    name[t][u] = mp[childNames];\n}\n\nvoid solve_case(){\n    scanf("%d", &N);\n    reset();\n    for(int t = 0; t < 2; t++){\n        for(int i = 0, a, b; i < N-1; i++){\n            scanf("%d %d", &a, &b);\n            G[t][a].push_back(b);\n            G[t][b].push_back(a);\n        }\n        dfs(t, 1, -1);\n    }\n    printf("%s\\n", name[0][1] == name[1][1] ? "YES" : "NO");\n}\n\nint main(){\n    int T;\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        solve_case();\n    }\n}',
  "1701":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, treeID, sz[2][maxN], name[2][maxN];\nvector<int> centroids[2], G[2][maxN];\nmap<vector<int>,int> mp;\n\nvoid reset(){\n    mp.clear();\n    treeID = 0;\n    for(int t = 0; t < 2; t++){\n        centroids[t].clear();\n        for(int i = 1; i <= N; i++){\n            sz[t][i] = name[t][i] = 0;\n            G[t][i].clear();\n        }\n    }\n}\n\nvoid dfs1(int t, int u, int p){\n    sz[t][u] = 1;\n    bool is_centroid = true;\n    for(int v : G[t][u]){\n        if(v != p){\n            dfs1(t, v, u);\n            sz[t][u] += sz[t][v];\n            if(sz[t][v] > N/2)  is_centroid = false;\n        }\n    }\n    if(N-sz[t][u] > N/2)    is_centroid = false;\n    if(is_centroid)         centroids[t].push_back(u);\n}\n\nvoid dfs2(int t, int u, int p){\n    vector<int> childNames;\n    for(int v : G[t][u]){\n        if(v != p){\n            dfs2(t, v, u);\n            childNames.push_back(name[t][v]);\n        }\n    }\n    sort(childNames.begin(), childNames.end());\n    if(!mp[childNames]) mp[childNames] = ++treeID;\n    name[t][u] = mp[childNames];\n}\n\nvoid solve_case(){\n    scanf("%d", &N);\n    reset();\n\n    for(int t = 0; t < 2; t++){\n        for(int i = 0, a, b; i < N-1; i++){\n            scanf("%d %d", &a, &b);\n            G[t][a].push_back(b);\n            G[t][b].push_back(a);\n        }\n        dfs1(t, 1, -1);\n    }\n\n    for(int root1 : centroids[0]){\n        for(int root2 : centroids[1]){\n            dfs2(0, root1, -1);\n            dfs2(1, root2, -1);\n            if(name[0][root1] == name[1][root2]){\n                printf("YES\\n");\n                return;\n            }\n        }\n    }\n    printf("NO\\n");\n}\n\nint main(){\n    int T;\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        solve_case();\n    }\n}',
  "1702":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+5;\n\nint N, timer, A[maxN], B[maxN], C[maxN], idx[maxN];\nint L[maxN], R[maxN];\n\nint solve(int l1 = 0, int r1 = N-1, int l2 = 0, int r2 = N-1){\n    if(l1 > r1 || l2 > r2)  return 0;\n    int root = A[l1];\n    int m2 = idx[root];\n    int len = m2-l2;\n    L[root] = solve(l1+1, l1+len, l2, m2-1);\n    R[root] = solve(l1+len+1, r1, m2+1, r2);\n    return root;\n}\n\nvoid dfs(int u){\n    if(L[u])    dfs(L[u]);\n    if(R[u])    dfs(R[u]);\n    C[timer++] = u;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)  scanf("%d", &A[i]);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &B[i]);\n        idx[B[i]] = i;\n    }\n\n    int root = solve();\n    dfs(root);\n    for(int i = 0; i < N; i++)\n        printf("%d%c", C[i], (" \\n")[i==N-1]);\n}',
  "1703":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, M, p[maxN], sdom[maxN], idom[maxN], label[maxN];\nint timer, tin[maxN], inv[maxN], dsu[maxN];\nvector<int> ans, G[maxN], GR[maxN], DT[maxN], bucket[maxN];\n\nvoid dfs(int u = 1){\n    tin[u] = ++timer;\n    inv[timer] = u;\n    label[timer] = sdom[timer] = dsu[timer] = timer;\n    for(int v : G[u]){\n        if(!tin[v]){\n            dfs(v);\n            p[tin[v]] = tin[u];\n        }\n        GR[tin[v]].push_back(tin[u]);\n    }\n}\n\nint find(int u, bool x = false){\n    if(u == dsu[u]) return x ? -1 : u;\n    int v = find(dsu[u], true);\n    if(v < 0)   return u;\n\n    if(sdom[label[dsu[u]]] < sdom[label[u]])\n        label[u] = label[dsu[u]];\n\n    dsu[u] = v;\n    return x ? v : label[u];\n}\n\nvoid build_dominator_tree(){\n    dfs();\n\n    for(int u = N; u > 0; u--){\n        for(int v : GR[u])\n            sdom[u] = min(sdom[u], sdom[find(v)]);\n        if(u > 1)   bucket[sdom[u]].push_back(u);\n        for(int v : bucket[u])\n            idom[v] = (sdom[find(v)] == sdom[v] ? sdom[v] : find(v));\n        if(u > 1)   dsu[u] = p[u];\n    }\n\n    for(int u = 2; u <= N; u++){\n        if(idom[u] != sdom[u])\n            idom[u] = idom[idom[u]];\n        DT[inv[u]].push_back(inv[idom[u]]);\n        DT[inv[idom[u]]].push_back(inv[u]);\n    }\n}\n\nbool dfs_dominator_tree(int u = 1, int p = -1){\n    bool good = (u == N);\n    for(int v : DT[u])\n        if(v != p)\n            good |= dfs_dominator_tree(v, u);\n    if(good)    ans.push_back(u);\n    return good;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n    }\n\n    build_dominator_tree();\n    dfs_dominator_tree();\n\n    sort(ans.begin(), ans.end());\n    int K = (int) ans.size();\n    printf("%d\\n", K);\n    for(int i = 0; i < K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K-1]);\n}',
  "1704":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, K;\nvector<int> leaves, G[maxN];\n\nvoid dfs(int u = 1, int p = -1){\n    if((int) G[u].size() == 1)  leaves.push_back(u);\n    for(int v : G[u])\n        if(v != p)\n            dfs(v, u);\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0, a, b; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs();\n\n    int K = (int) leaves.size();\n    printf("%d\\n", (K+1)/2);\n    for(int i = 0; i < (K+1)/2; i++)\n        printf("%d %d\\n", leaves[i], leaves[i+K/2]);\n}',
  "1706":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\n\nint N, M, a, b, ds[maxN];\nmultiset<int> sizes;\nbitset<maxN> dp;\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    fill(ds+1, ds+N+1, -1);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        merge(a, b);\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(find(i) == i)\n            sizes.insert(-ds[i]);\n\n    dp[0] = 1;\n    for(int sz : sizes)\n        dp |= (dp<<sz);\n\n    for(int i = 1; i <= N; i++)\n        printf("%d", dp[i] ? 1 : 0);\n    printf("\\n");\n}\n',
  "1707":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2501;\n\nbool vis[maxN];\nint N, M, best, p[maxN], dist[maxN];\nvector<int> G[maxN];\n\nvoid reset(){\n    fill(vis+1, vis+N+1, false);\n    fill(dist+1, dist+N+1, 0);\n    fill(p+1, p+N+1, 0);\n}\n\nvoid bfs(int start){\n    queue<int> Q;\n    Q.push(start);\n    vis[start] = true;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        for(int v : G[u]){\n            if(!vis[v]){\n                dist[v] = dist[u]+1;\n                vis[v] = true;\n                p[v] = u;\n                Q.push(v);\n            } else if(v != u[p]){\n                best = min(best, dist[u]+dist[v]+1);\n            }\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    best = N+1;\n    for(int start = 1; start <= N; start++){\n        reset();\n        bfs(start);\n    }\n\n    printf("%d\\n", best == N+1 ? -1 : best);\n}',
  "1709":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 105;\n\nchar S[maxN];\nbool used[maxN], inZ[2][maxN];\nint N, cnt, mt[maxN];\nvector<int> G[maxN];\n\nbool kuhns(int u){\n    if(used[u]) return false;\n\n    used[u] = true;\n    for(int v : G[u]){\n        if(!mt[v] || kuhns(mt[v])){\n            mt[v] = u;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvoid dfs(int t, int u){\n    inZ[t][u] = true;\n    if(t == 0 && !inZ[1][mt[u]]){\n        dfs(1, mt[u]);\n    } else if(t == 1){\n        for(int v : G[u])\n            if(!inZ[0][v])\n                dfs(0, v);\n    }\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++){\n        scanf(" %s", S);\n        for(int j = 1; j <= N; j++)\n            if(S[j-1] == \'o\')\n                G[j].push_back(i);\n    }\n\n    for(int i = 1; i <= N; i++){\n        kuhns(i);\n        fill(used+1, used+N+1, false);\n    }\n\n    cnt = 0;\n    for(int i = 1; i <= N; i++){\n        if(mt[i]){\n            cnt++;\n            used[mt[i]] = true;\n        }\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(!used[i])\n            dfs(1, i);\n\n    printf("%d\\n", cnt);\n    for(int i = 1; i <= N; i++)\n        if(inZ[0][i])\n            printf("1 %d\\n", i);\n    for(int i = 1; i <= N; i++)\n        if(!inZ[1][i])\n            printf("2 %d\\n", i);\n}',
  "1711":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 501, maxM = 1001;\nconst int INF = 0x3f3f3f3f;\n\nint N, M, p[maxN], cap[maxN][maxN];\nbool vis[maxM];\nvector<int> path, F[maxN];\nvector<pii> G[maxN];\n\nint bfs(int s = 1, int t = N){\n    fill(p+1, p+N+1, -1);\n    p[s] = -2;\n\n    queue<pii> Q;\n    Q.push({s, INF});\n    while(!Q.empty()){\n        int u = Q.front().first;\n        int f = Q.front().second;\n        Q.pop();\n\n        for(int v : F[u]){\n            if(p[v] == -1 && cap[u][v]){\n                p[v] = u;\n                int aug = min(f, cap[u][v]);\n                if(v == t)  return aug;\n                Q.push({v, aug});\n            }\n        }\n    }\n\n    return 0;\n}\n\nvoid dfs(int u = 1){\n    path.push_back(u);\n    if(u == N)  return;\n    for(pii e : G[u]){\n        int v = e.first;\n        int id = e.second;\n        if(cap[u][v] == 0 && !vis[id]){\n            vis[id] = true;\n            dfs(v);\n            return;\n        }\n    }\n}\n\nint maxflow(int s = 1, int t = N){\n    int flow = 0, aug = 0;\n    while(aug = bfs()){\n        flow += aug;\n        int u = t;\n        while(u != s){\n            int v = p[u];\n            cap[v][u] -= aug;\n            cap[u][v] += aug;\n            u = v;\n        }\n    }\n    return flow;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back({b, i});\n        F[a].push_back(b);\n        F[b].push_back(a);\n        cap[a][b]++;\n    }\n\n    int K = maxflow();\n    printf("%d\\n", K);\n    for(int k = 0; k < K; k++){\n        path.clear();\n\n        dfs();\n        int sz = (int) path.size();\n        printf("%d\\n", sz);\n        for(int i = 0; i < sz; i++)\n            printf("%d%c", path[i], (" \\n")[i==sz-1]);\n    }\n}',
  "1712":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nint N;\nll A, B, C;\n\nll fastpow(ll a, ll b, ll mod){\n    ll res = 1;\n    while(b > 0){\n        if(b&1)\n            res = (res * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%lld %lld %lld", &A, &B, &C);\n        printf("%lld\\n", fastpow(A, fastpow(B, C, MOD-1), MOD));\n    }\n}\n',
  "1713":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxX = 1e6;\n\nint N, x, d[maxX+1];\n\nvoid init(){\n    for(int i = 1; i <= maxX; i++)\n        for(int j = i; j <= maxX; j += i)\n            d[j]++;\n}\n\nint main(){\n    scanf("%d", &N);\n\n    init();\n    for(int i = 0; i < N; i++){\n        scanf("%d", &x);\n        printf("%d\\n", d[x]);\n    }\n}\n',
  "1715":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e6+5;\nconst ll MOD = 1e9+7;\n\nint N, freq[26];\nchar S[maxN];\nll fact[maxN], inv[maxN];\n\nll inverse(ll x){\n    ll res = 1;\n    ll expo = MOD-2;\n    while(expo > 0){\n        if(expo&1)\n            res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        expo >>= 1;\n    }\n    return res;\n}\n\nvoid init(){\n    fact[0] = inv[0] = 1;\n    for(int i = 1; i < maxN; i++){\n        fact[i] = i * fact[i-1] % MOD;\n        inv[i] = inverse(fact[i]);\n    }\n}\n\nint main(){\n    scanf("%s", S);\n    N = (int) strlen(S);\n    init();\n\n    for(int i = 0; i < N; i++)\n        freq[(int) (S[i]-\'a\')]++;\n\n    ll ans = fact[N];\n    for(int i = 0; i < 26; i++)\n        ans = ans * inv[freq[i]] % MOD;\n    printf("%lld\\n", ans);\n}\n',
  "1716":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e6;\nconst ll MOD = 1e9+7;\n\nint N, M;\nll fact[maxN], inv[maxN];\n\nll inverse(ll x){\n    ll res = 1;\n    ll expo = MOD-2;\n    while(expo > 0){\n        if(expo&1)\n            res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        expo >>= 1;\n    }\n    return res;\n}\n\nvoid init(){\n    fact[0] = inv[0] = 1;\n    for(int i = 1; i < maxN; i++){\n        fact[i] = i * fact[i-1] % MOD;\n        inv[i] = inverse(fact[i]);\n    }\n}\n\nll choose(int n, int k){\n    return fact[n] * inv[k] % MOD * inv[n-k] % MOD;\n}\n\nint main(){\n    init();\n    scanf("%d %d", &N, &M);\n    printf("%lld\\n", choose(N+M-1, M));\n}\n',
  "1717":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e6;\nconst ll MOD = 1e9+7;\n\nint N;\nll dp[maxN+1];\n\nvoid init(){\n    dp[2] = 1;\n    for(int i = 3; i <= maxN; i++)\n        dp[i] = (i-1) * (dp[i-1] + dp[i-2]) % MOD;\n}\n\nint main(){\n    init();\n    scanf("%d", &N);\n    printf("%lld\\n", dp[N]);\n}\n',
  "1722":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nll N, x[2][2], y[2][2];\n\nvoid mult(ll A[2][2], ll B[2][2]){\n    ll C[2][2];\n    memset(C, 0, sizeof(C));\n    for(int i = 0; i < 2; i++){\n        for(int j = 0; j < 2; j++){\n            for(int k = 0; k < 2; k++){\n                C[i][j] += A[i][k] * B[k][j];\n                C[i][j] %= MOD;\n            }\n        }\n    }\n    for(int i = 0; i < 2; i++)\n        for(int j = 0; j < 2; j++)\n            A[i][j] = C[i][j];\n}\n\nint main(){\n    x[0][1] = x[1][0] = x[1][1] = y[0][0] = y[1][1] = 1;\n\n    scanf("%lld", &N);\n    while(N){\n        if(N&1)\n            mult(y, x);\n        mult(x, x);\n        N >>= 1;\n    }\n\n    printf("%lld\\n", y[0][1]);\n}\n',
  "1723":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 100;\nconst ll MOD = 1e9+7;\n\nint N, M, K, a, b;\nll X[maxN][maxN], Y[maxN][maxN];\n\nvoid mult(ll A[maxN][maxN], ll B[maxN][maxN]){\n    ll C[N][N];\n    memset(C, 0, sizeof(C));\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            for(int k = 0; k < N; k++){\n                C[i][j] += A[i][k] * B[k][j];\n                C[i][j] %= MOD;\n            }\n        }\n    }\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            A[i][j] = C[i][j];\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        X[a-1][b-1]++;\n    }\n    for(int i = 0; i < N; i++)\n        Y[i][i] = 1;\n\n    while(K){\n        if(K&1)\n            mult(Y, X);\n        mult(X, X);\n        K >>= 1;\n    }\n\n    printf("%lld\\n", Y[0][N-1]);\n}\n',
  "1724":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef unsigned long long ull;\nconst int maxN = 100;\nconst ull INF = 1e19;\n\nint N, M, K, a, b;\null c, X[maxN][maxN], Y[maxN][maxN];\n\nvoid combine(ull A[maxN][maxN], ull B[maxN][maxN]){\n    ull C[maxN][maxN];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            C[i][j] = INF;\n\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            for(int k = 0; k < N; k++)\n                if(A[i][k] != INF && B[k][j] != INF)\n                    C[i][j] = min(C[i][j], A[i][k] + B[k][j]);\n\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            A[i][j] = C[i][j];\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++)\n            X[i][j] = Y[i][j] = INF;\n        Y[i][i] = 0;\n    }\n\n    for(int i = 0; i < M; i++){\n        scanf("%d %d %llu", &a, &b, &c);\n        X[a-1][b-1] = min(X[a-1][b-1], c);\n    }\n\n    while(K){\n        if(K&1)\n            combine(Y, X);\n        combine(X, X);\n        K >>= 1;\n    }\n\n    if(Y[0][N-1] == INF)    printf("-1\\n");\n    else                    printf("%llu\\n", Y[0][N-1]);\n}\n',
  "1725":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 100;\n\nint N, a, b;\ndouble sum, dp[maxN+1][6*maxN+1];\n\nint main(){\n    scanf("%d %d %d", &N, &a, &b);\n    dp[0][0] = 1;\n    for(int i = 1; i <= N; i++)\n        for(int j = 1; j <= 6*maxN; j++)\n            for(int k = 1; k <= 6; k++)\n                if(j-k >= 0)\n                    dp[i][j] += dp[i-1][j-k]/6;\n    for(int i = a; i <= b; i++)\n        sum += dp[N][i];\n    printf("%.6f\\n", sum);\n}\n',
  "1726":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxK = 101;\nconst int N = 8, SZ = N*N;\n\nint K;\ndouble expected, ans[SZ], dp[maxK][SZ];\n\nint main(){\n    scanf("%d", &K);\n    for(int i = 0; i < SZ; i++)\n        ans[i] = 1.0;\n\n    for(int start = 0; start < SZ; start++){\n        memset(dp, 0, sizeof(dp));\n        dp[0][start] = 1.0;\n\n        for(int k = 0; k < K; k++){\n            for(int u = 0; u < SZ; u++){\n                vector<int> V;\n                if(N <= u)          V.push_back(u-N);\n                if(u < N*(N-1))     V.push_back(u+N);\n                if(u % N != 0)      V.push_back(u-1);\n                if(u % N != N-1)    V.push_back(u+1);\n\n                for(int v : V)\n                    dp[k+1][v] += (dp[k][u] / V.size());\n            }\n        }\n\n        for(int u = 0; u < SZ; u++)\n            ans[u] *= (1 - dp[K][u]);\n    }\n\n    for(int i = 0; i < SZ; i++)\n        expected += ans[i];\n    printf("%.6f\\n", expected);\n}',
  "1727":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, K;\ndouble ans, a, b;\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 1; i <= K; i++){\n        a = b = 1.0;\n        for(int j = 1; j <= N; j++){\n            a *= (double) i / K;\n            b *= (double) (i-1) / K;\n        }\n        ans += (a-b) * i;\n    }\n    printf("%.6f\\n", ans);\n}\n',
  "1728":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 101;\n\nint N, r[maxN];\nlong double ans;\n\nint f(int x){\n    return x * (x-1) / 2;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &r[i]);\n        for(int j = 0; j < i; j++){\n            int tot = (r[j] <= r[i]) ? f(r[j]) : (f(r[i]) + (r[j]-r[i]) * r[i]);\n            ans += (long double) tot / (r[i] * r[j]);\n        }\n    }\n    printf("%.6Lf\\n", ans);\n}',
  "1729":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6;\nconst int maxK = 100;\n\nint N, K, p[maxK];\nbool dp[maxN+1];\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 0; i < K; i++)\n        scanf("%d", &p[i]);\n\n    for(int i = 1; i <= N; i++){\n        for(int j = 0; j < K; j++)\n            if(i-p[j] >= 0 && !dp[i-p[j]])\n                dp[i] = true;\n        printf("%c", ("LW")[dp[i]]);\n    }\n}\n',
  "1730":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T, N, x, xum;\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        scanf("%d", &N);\n        xum = 0;\n        for(int i = 0; i < N; i++){\n            scanf("%d", &x);\n            xum ^= x;\n        }\n        printf("%s\\n", (xum ? "first" : "second"));\n    }\n}\n',
  "1731":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 5005, K = 26;\nconst ll MOD = 1e9+7;\n\nstruct Node {\n    int next[K];\n    bool leaf = false;\n    Node(){ fill(next, next+K, -1); }\n};\n\nint N, M;\nll dp[maxN];\nchar S[maxN], word[maxN];\nvector<Node> trie(1);\n\nvoid add_word(){\n    scanf(" %s", word);\n    int v = 0;\n    M = (int) strlen(word);\n    for(int i = 0; i < M; i++){\n        int c = (int) (word[i] - \'a\');\n        if(trie[v].next[c] == -1){\n            trie[v].next[c] = trie.size();\n            trie.emplace_back();\n        }\n        v = trie[v].next[c];\n    }\n    trie[v].leaf = true;\n}\n\nint main(){\n    scanf(" %s %d", S, &N);\n    for(int i = 0; i < N; i++)\n        add_word();\n\n    M = (int) strlen(S);\n    dp[M] = 1;\n    for(int i = M-1; i >= 0; i--){\n        int v = 0;\n        for(int j = i; j < M; j++){\n            int c = (int) (S[j] - \'a\');\n            if(trie[v].next[c] == -1)   break;\n            v = trie[v].next[c];\n\n            if(trie[v].leaf)\n                dp[i] = (dp[i] + dp[j+1]) % MOD;\n        }\n    }\n    printf("%lld\\n", dp[0]);\n}',
  "1732":
    "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\nconst ll p1 = 31;\nconst ll p2 = 37;\nconst int maxN = 1e6+5;\n\nint N;\nll pow1[maxN], pow2[maxN], ph1, ph2, sh1, sh2;\nchar S[maxN];\n\nint main(){\n    scanf(\"%s\", S);\n    N = (int) strlen(S);\n\n    pow1[0] = pow2[0] = 1;\n    for(int i = 1; i < N; i++){\n        pow1[i] = (pow1[i-1] * p1) % MOD;\n        pow2[i] = (pow2[i-1] * p2) % MOD;\n    }\n\n    for(int i = 0; i < N-1; i++){\n        int l = (S[i] - 'a' + 1);\n        int r = (S[N-i-1] - 'a' + 1);\n\n        ph1 = (ph1 + l * pow1[i]) % MOD;\n        ph2 = (ph2 + l * pow2[i]) % MOD;\n        sh1 = (sh1 * p1 + r) % MOD;\n        sh2 = (sh2 * p2 + r) % MOD;\n\n        if(ph1 == sh1 && ph2 == sh2)\n            printf(\"%d \", i+1);\n    }\n}",
  "1733":
    "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\nconst ll p1 = 31, p2 = 37;\nconst int maxN = 1e6+5;\n\nint N;\nchar S[maxN];\nll pow1[maxN], pow2[maxN], h1[maxN], h2[maxN];\n\nvoid init(){\n    pow1[0] = pow2[0] = 1;\n    h1[0] = h2[0] = (int) (S[0] - 'a' + 1);\n    for(int i = 1; i < maxN; i++){\n        int c = (int) (S[i] - 'a' + 1);\n        pow1[i] = (pow1[i-1] * p1) % MOD;\n        pow2[i] = (pow2[i-1] * p2) % MOD;\n        h1[i] = (h1[i-1] * p1 + c) % MOD;\n        h2[i] = (h2[i-1] * p2 + c) % MOD;\n    }\n}\n\nint main(){\n    scanf(\" %s\", S);\n    N = (int) strlen(S);\n    init();\n\n    for(int len = 1; len <= N; len++){\n        ll hash1 = h1[len-1], hash2 = h2[len-1];\n        for(int i = 0; i < (N/len)-1; i++){\n            hash1 = (hash1 * pow1[len] + h1[len-1]) % MOD;\n            hash2 = (hash2 * pow2[len] + h2[len-1]) % MOD;\n        }\n        hash1 = (hash1 * pow1[N%len] + h1[N%len-1]) % MOD;\n        hash2 = (hash2 * pow2[N%len] + h2[N%len-1]) % MOD;\n        if(hash1 == h1[N-1] && hash2 == h2[N-1])    printf(\"%d \", len);\n    }\n}",
  "1734":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef array<int,3> triple;\nconst int maxN = 2e5+1;\n\nint N, Q, a, b, x[maxN], ptr[maxN], ds[maxN], ans[maxN];\ntriple queries[maxN];\nmap<int,int> mp;\nset<int> S;\n\nvoid update(int idx, int val){\n    for(int i = idx; i <= N; i += -i&i)\n        ds[i] += val;\n}\n\nint query(int idx){\n    int sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum += ds[i];\n    return sum;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &x[i]);\n\n    for(int i = N; i > 0; i--){\n        if(mp[x[i]])\n            ptr[i] = mp[x[i]];\n        mp[x[i]] = i;\n    }\n\n    for(int i = 1; i <= N; i++){\n        if(S.count(x[i]) == 0)\n            update(i, 1);\n        S.insert(x[i]);\n    }\n\n    for(int i = 0; i < Q; i++){\n        scanf("%d %d", &a, &b);\n        queries[i] = {a, b, i};\n    }\n    sort(queries, queries+Q);\n\n    int l = 1;\n    for(int q = 0; q < Q; q++){\n        while(l < queries[q][0]){\n            if(ptr[l])\n                update(ptr[l], 1);\n            l++;\n        }\n        ans[queries[q][2]] = query(queries[q][1]) - query(queries[q][0]-1);\n    }\n\n    for(int q = 0; q < Q; q++)\n        printf("%d\\n", ans[q]);\n}\n',
  "1735":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, Q, t, a, b, lo[4*maxN], hi[4*maxN];\nll x, del[4*maxN], ass[4*maxN], sum[4*maxN];\n\nint len(int i){\n    return hi[i]-lo[i]+1;\n}\n\nvoid increment(int i, ll v){\n    del[i] += v;\n    sum[i] += len(i) * v;\n}\n\nvoid assign(int i, ll v){\n    ass[i] = v;\n    del[i] = 0;\n    sum[i] = len(i) * v;\n}\n\nvoid push(int i){\n    if(ass[i]){\n        assign(2*i, ass[i]);\n        assign(2*i+1, ass[i]);\n        ass[i] = 0;\n    }\n    if(del[i]){\n        increment(2*i, del[i]);\n        increment(2*i+1, del[i]);\n        del[i] = 0;\n    }\n}\n\nvoid pull(int i){\n    sum[i] = sum[2*i] + sum[2*i+1];\n}\n\nvoid build(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        scanf("%lld", &sum[i]);\n        return;\n    }\n    int m = l+(r-l)/2;\n    build(2*i, l, m);\n    build(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid increment(int i, int l, int r, ll v){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        increment(i, v); return;\n    }\n\n    push(i);\n    increment(2*i, l, r, v);\n    increment(2*i+1, l, r, v);\n    pull(i);\n}\n\nvoid assign(int i, int l, int r, ll v){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        assign(i, v); return;\n    }\n\n    push(i);\n    assign(2*i, l, r, v);\n    assign(2*i+1, l, r, v);\n    pull(i);\n}\n\nll query(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])  return 0;\n    if(l <= lo[i] && hi[i] <= r){\n        return sum[i];\n    }\n\n    push(i);\n    ll lsum = query(2*i, l, r);\n    ll rsum = query(2*i+1, l, r);\n    pull(i);\n\n    return lsum + rsum;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n\n    build(1, 1, N);\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d %d", &t, &a, &b);\n        if(t == 1){\n            scanf("%lld", &x);\n            increment(1, a, b, x);\n        } else if(t == 2){\n            scanf("%lld", &x);\n            assign(1, a, b, x);\n        } else if(t == 3){\n            printf("%lld\\n", query(1, a, b));\n        }\n    }\n}\n',
  "1736":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int SIZE = 8e5;\n\nint N, Q, t, a, b, lo[SIZE], hi[SIZE];\nll d1[SIZE], d2[SIZE], s1[SIZE], s2[SIZE];\n\nint len(int i){\n    return hi[i]-lo[i]+1;\n}\n\nll sigma(int i){\n    return ((ll) hi[i] * (hi[i]+1))/2 - ((ll) lo[i] * (lo[i]-1))/2;\n}\n\nvoid push(int i){\n    if(d1[i]){\n        d1[2*i] += d1[i];\n        d1[2*i+1] += d1[i];\n        d1[i] = 0;\n    }\n    if(d2[i]){\n        d2[2*i] += d2[i];\n        d2[2*i+1] += d2[i];\n        d2[i] = 0;\n    }\n}\n\nvoid pull(int i){\n    ll l1 = s1[2*i] + (d1[2*i] * len(2*i));\n    ll r1 = s1[2*i+1] + (d1[2*i+1] * len(2*i+1));\n    s1[i] = l1 + r1;\n    ll l2 = s2[2*i] + (d2[2*i] * sigma(2*i));\n    ll r2 = s2[2*i+1] + (d2[2*i+1] * sigma(2*i+1));\n    s2[i] = l2 + r2;\n}\n\nvoid build(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        scanf("%lld", &s1[i]);\n        return;\n    }\n    int m = l+(r-l)/2;\n    build(2*i, l, m);\n    build(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid increment(int type, int i, int l, int r, ll v){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        if(type == 1)   d1[i] += v;\n        if(type == 2)   d2[i] += v;\n        return;\n    }\n\n    push(i);\n    increment(type, 2*i, l, r, v);\n    increment(type, 2*i+1, l, r, v);\n    pull(i);\n}\n\nll sum(int type, int i, int l, int r){\n    if(l > hi[i] || r < lo[i])  return 0;\n    if(l <= lo[i] && hi[i] <= r){\n        if(type == 1)   return s1[i] + (d1[i] * len(i));\n        if(type == 2)   return s2[i] + (d2[i] * sigma(i));\n        return 0;\n    }\n\n    push(i);\n    ll lsum = sum(type, 2*i, l, r);\n    ll rsum = sum(type, 2*i+1, l, r);\n    pull(i);\n\n    return lsum + rsum;\n}\n\nvoid update(int l, int r){\n    increment(1, 1, l, r, -l+1);\n    increment(2, 1, l, r, 1);\n}\n\nll query(int l, int r){\n    return sum(1, 1, l, r) + sum(2, 1, l, r);\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n\n    build(1, 1, N);\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d %d", &t, &a, &b);\n        if(t == 1)      update(a, b);\n        else if(t == 2) printf("%lld\\n", query(a, b));\n    }\n}\n',
  "1737":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nstruct Node {\n    Node *l, *r;\n    int lo, hi;\n    ll sum;\n    Node(int low, int high, int val) : l(nullptr), r(nullptr), lo(low), hi(high), sum(val) {}\n    Node(Node *left, Node *right) : l(left), r(right), sum(0) {\n        if(left){\n            sum += left->sum;\n            lo = left->lo;\n        }\n        if(right){\n            sum += right->sum;\n            hi = right->hi;\n        }\n    }\n};\n\nint N, Q, type, k, a, b, x, cnt, t[maxN];\nNode* seg[maxN];\n\nNode* build(int l, int r){\n    if(l == r)  return new Node(l, r, t[l]);\n    int m = (l+r)/2;\n    return new Node(build(l, m), build(m+1, r));\n}\n\nNode* update(Node* node, int idx, int val){\n    if(node->lo == node->hi)    return new Node(idx, idx, val);\n    int m = (node->lo+node->hi)/2;\n    if(idx <= m)    return new Node(update(node->l, idx, val), node->r);\n    else            return new Node(node->l, update(node->r, idx, val));\n}\n\nll query(Node* node, int l, int r){\n    if(l > node->hi || r < node->lo)    return 0;\n    if(l <= node->lo && node->hi <= r)  return node->sum;\n    return query(node->l, l, r) + query(node->r, l, r);\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &t[i]);\n\n    cnt = 1;\n    seg[cnt++] = build(1, N);\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &type, &k);\n        if(type == 1){\n            scanf("%d %d", &a, &x);\n            seg[k] = update(seg[k], a, x);\n        } else if(type == 2){\n            scanf("%d %d", &a, &b);\n            printf("%lld\\n", query(seg[k], a, b));\n        } else if(type == 3){\n            seg[cnt++] = new Node(seg[k]->l, seg[k]->r);\n        }\n    }\n}\n',
  "1739":
    "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1000;\n\nint N, Q;\nchar c[maxN+1][maxN+1];\nll ds[maxN+1][maxN+1];\n\nvoid update(int x, int y, ll val){\n    for(int i = x; i <= N; i += -i&i)\n        for(int j = y; j <= N; j += -j&j)\n            ds[i][j] += val;\n}\n\nll query(int x, int y){\n    ll sum = 0;\n    for(int i = x; i > 0; i -= -i&i)\n        for(int j = y; j > 0; j -= -j&j)\n            sum += ds[i][j];\n    return sum;\n}\n\nint main(){\n    scanf(\"%d %d\", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        for(int j = 1; j <= N; j++){\n            scanf(\" %c\", &c[i][j]);\n            if(c[i][j] == '*')\n                update(i, j, 1);\n        }\n    }\n    for(int q = 0, t, x1, y1, x2, y2; q < Q; q++){\n        scanf(\"%d %d %d\", &t, &x1, &y1);\n        if(t == 1){\n            if(c[x1][y1] == '*'){\n                update(x1, y1, -1);\n                c[x1][y1] = '.';\n            } else if(c[x1][y1] == '.'){\n                update(x1, y1, 1);\n                c[x1][y1] = '*';\n            }\n        } else if(t == 2){\n            scanf(\"%d %d\", &x2, &y2);\n            printf(\"%lld\\n\", query(x2, y2)-query(x2,y1-1)-query(x1-1,y2)+query(x1-1,y1-1));\n        }\n    }\n}\n",
  "1740":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+1;\nconst int maxX = 1e6+5;\nconst int SIZE = 2*maxX;\n\nstruct Operation {\n    int type, y, a, b;\n};\n\nint N, ds[SIZE];\nvector<Operation> ops;\n\nvoid update(int idx, int val){\n    for(int i = idx; i < SIZE; i += -i&i)\n        ds[i] += val;\n}\n\nint query(int idx){\n    int sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum += ds[i];\n    return sum;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0, a, b, c, d; i < N; i++){\n        scanf("%d %d %d %d", &a, &b, &c, &d);\n        if(a == c){\n            // Vertical\n            ops.push_back({2, b, a+maxX, -1});\n            ops.push_back({3, d, a+maxX, -1});\n        } else {\n            // Horizontal\n            ops.push_back({1, b, a+maxX, c+maxX});\n        }\n    }\n    sort(ops.begin(), ops.end(), [](Operation A, Operation B){\n        return A.y < B.y;\n    });\n\n    ll ans = 0;\n    for(Operation O : ops){\n        if(O.type == 1)         ans += query(O.b) - query(O.a-1);\n        else if(O.type == 2)    update(O.a, 1);\n        else if(O.type == 3)    update(O.a, -1);\n    }\n    printf("%lld\\n", ans);\n}',
  "1741":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef array<int,4> Operation;\nconst int maxN = 1e5;\nconst int SZ = 9e6;\n\nint N, lo[SZ], hi[SZ];\nll area, delta[SZ], score[SZ];\nOperation op[2*maxN];\n\nint len(int i){\n    return hi[i]-lo[i]+1;\n}\n\nvoid pull(int i){\n    if(lo[i] == hi[i])  score[i] = (delta[i] > 0 ? 1 : 0);\n    else                score[i] = (delta[i] > 0 ? len(i) : score[2*i] + score[2*i+1]);\n}\n\nvoid build(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r)  return;\n    int m = l+(r-l)/2;\n    build(2*i, l, m);\n    build(2*i+1, m+1, r);\n}\n\nvoid increment(int i, int l, int r, ll val){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        delta[i] += val;\n        pull(i);\n        return;\n    }\n    increment(2*i, l, r, val);\n    increment(2*i+1, l, r, val);\n    pull(i);\n}\n\nll query(){\n    return score[1];\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0, a, b, c, d; i < N; i++){\n        scanf("%d %d %d %d", &a, &b, &c, &d);\n        op[2*i] = {1, b, a+1, c};\n        op[2*i+1] = {-1, d, a+1, c};\n    }\n    sort(op, op+2*N, [](Operation A, Operation B){\n       return (A[1] == B[1] ? A[0] < B[0] : A[1] < B[1]);\n    });\n\n    build(1, -1e6-5, 1e6+5);\n    int lst = -1e6;\n    for(int i = 0; i < 2*N; i++){\n        int t = op[i][0], y = op[i][1], x1 = op[i][2], x2 = op[i][3];\n        area += (y-lst) * query();\n        increment(1, x1, x2, t);\n        lst = y;\n    }\n\n    printf("%lld\\n", area);\n}',
  "1743":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6+5;\n\nint freq[26];\nchar S[maxN], ans[maxN];\n\nbool possible(int current){\n    int mode = 0, total = 0;\n    for(int c = 0; c < 26; c++){\n        if(freq[mode] < freq[c])\n            mode = c;\n        total += freq[c];\n    }\n    return (freq[mode] <= (total+1)/2) && (freq[current] <= total/2);\n}\n\nint main(){\n    scanf(" %s", S);\n    const int N = (int) strlen(S);\n    for(int i = 0; i < N; i++)\n        freq[(int) (S[i] - \'A\')]++;\n\n    int lastchar = -1;\n    for(int i = 0; i < N; i++){\n        bool filled = false;\n        for(int c = 0; c < 26 && !filled; c++){\n            if(freq[c] > 0 && c != lastchar){\n                freq[c]--;\n                if(possible(c)){\n                    ans[i] = (char) (c + \'A\');\n                    lastchar = c;\n                    filled = true;\n                } else freq[c]++;\n            }\n        }\n\n        if(!filled){\n            printf("-1\\n");\n            return 0;\n        }\n    }\n\n    for(int i = 0; i < N; i++)\n        printf("%c", ans[i]);\n    printf("\\n");\n}',
  "1744":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\n\nint A, B, dp[501][501];\n\nint solve(int a, int b){\n    if(a > b)   swap(a, b);\n    if(dp[a][b] != INF)     return dp[a][b];\n    if(a == b)              return dp[a][b] = 0;\n    if(a == 1 || b == 1)    return dp[a][b] = (a == 1 ? b-1 : a-1);\n    for(int i = 1; i < a; i++)\n        dp[a][b] = min(dp[a][b], solve(i, b) + solve(a-i, b) + 1);\n    for(int i = 1; i < b; i++)\n        dp[a][b] = min(dp[a][b], solve(a, i) + solve(a, b-i) + 1);\n    return dp[a][b];\n}\n\nint main(){\n    memset(dp, 0x3f, sizeof(dp));\n    scanf("%d %d", &A, &B);\n    printf("%d\\n", solve(A, B));\n}\n',
  "1745":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxX = 1e5;\n\nint N, x, cnt, largest;\nbool dp[maxX+1];\n\nint main(){\n    scanf("%d", &N);\n\n    dp[0] = true;\n    for(int i = 0; i < N; i++){\n        scanf("%d", &x);\n        for(int j = maxX-x; j >= 0; j--)\n            if(dp[j])\n                dp[j+x] = true;\n    }\n\n    for(int i = 1; i <= maxX; i++){\n        if(dp[i]){\n            largest = i;\n            cnt++;\n        }\n    }\n\n    printf("%d\\n", cnt++);\n    for(int i = 1; i <= maxX; i++)\n        if(dp[i])\n            printf("%d%c", i, (" \\n")[i==largest]);\n}\n',
  "1746":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5;\nconst int maxM = 100;\nconst ll MOD = 1e9+7;\n\nint N, M, x[maxN+1];\nll ans, dp[maxN+1][maxM+1];\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &x[i]);\n\n    if(x[1])\n        dp[1][x[1]] = 1;\n    else\n        for(int i = 1; i <= M; i++)\n            dp[1][i] = 1;\n\n    for(int i = 2; i <= N; i++){\n        for(int j = 1; j <= M; j++){\n            dp[i][j] = dp[i-1][j];\n            if(j != 1)  dp[i][j] += dp[i-1][j-1];\n            if(j != M)  dp[i][j] += dp[i-1][j+1];\n            dp[i][j] %= MOD;\n        }\n\n        if(x[i])\n            for(int j = 0; j <= M; j++)\n                if(j != x[i])\n                    dp[i][j] = 0;\n    }\n\n    for(int i= 1; i <= M; i++)\n        ans = (ans + dp[N][i]) % MOD;\n    printf("%lld\\n", ans);\n}\n',
  "1747":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5+1;\n\nint N, ds[maxN];\npii X[maxN];\n\nvoid update(int idx){\n    for(int i = idx; i <= N; i += -i&i) ds[i]++;\n}\n\nint query(int idx){\n    int cnt = 0;\n    for(int i = idx; i; i -= -i&i)\n        cnt += ds[i];\n    return cnt;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0, x; i < N; i++){\n        scanf("%d", &x);\n        X[i] = {x, i+1};\n    }\n    sort(X, X+N, [](pii a, pii b){\n        return a.first > b.first;\n    });\n\n    long long ans = 0;\n    for(int k = 0; k < N; k++){\n        int idx = X[k].second;\n        int l = query(idx);\n        ans += min(l, k-l);\n        update(idx);\n    }\n    printf("%lld\\n", ans);\n}',
  "1748":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+5;\nconst ll MOD = 1e9+7;\n\nint N;\nll ans, ds[maxN];\nstruct Operation { int x, idx; } ops[maxN];\n\nvoid update(int idx, ll val){\n    for(int i = idx; i < maxN; i += -i&i)\n        ds[i] = (ds[i] + val) % MOD;\n}\n\nll query(int idx){\n    ll sum = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        sum = (sum + ds[i]) % MOD;\n    return sum;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0, x; i < N; i++){\n        scanf("%d", &x);\n        ops[i] = {x, i+1};\n    }\n    sort(ops, ops+N, [](Operation A, Operation B){\n        return A.x == B.x ? B.idx < A.idx : A.x < B.x;\n    });\n\n    for(int i = 0; i < N; i++){\n        int idx = ops[i].idx;\n        ll amnt = query(idx)+1;\n        ans = (ans + amnt) % MOD;\n        update(idx, amnt);\n    }\n    printf("%lld\\n", ans);\n}',
  "1749":
    '#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nconst int maxN = 2e5;\n\nint N, p, x[maxN+1];\ntree<int, null_type, less<int>, rb_tree_tag,\ntree_order_statistics_node_update> T;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &x[i]);\n        T.insert(i);\n    }\n\n    for(int i = 0; i < N; i++){\n        scanf("%d", &p);\n        printf("%d%c", x[*T.find_by_order(p-1)], (" \\n")[i==N-1]);\n        T.erase(T.find_by_order(p-1));\n    }\n}\n',
  "1750":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\nconst int logK = 31;\n\nint N, Q, x, k, p[maxN][logK];\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &p[i][0]);\n    for(int j = 1; j < logK; j++)\n        for(int i = 1; i <= N; i++)\n            p[i][j] = p[p[i][j-1]][j-1];\n\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &x, &k);\n        for(int i = 0; i < logK; i++)\n            if(k&(1<<i))\n                x = p[x][i];\n        printf("%d\\n", x);\n    }\n}\n',
  "1751":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nbool vis[maxN];\nint N, t[maxN], in[maxN], ans[maxN];\nvector<int> G[maxN];\nqueue<int> Q;\n\nvoid dfs1(int u){\n    for(int v : G[u]){\n        if(!vis[v]){\n            ans[v] = ans[u]+1;\n            vis[v] = true;\n            dfs1(v);\n        }\n    }\n}\n\nvoid dfs2(int u, int d = 1){\n    vis[u] = true;\n    int v = t[u];\n    if(vis[v]){\n        ans[u] = d;\n    } else {\n        dfs2(v, d+1);\n        ans[u] = ans[v];\n    }\n    dfs1(u);\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &t[i]);\n        G[t[i]].push_back(i);\n        in[t[i]]++;\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(in[i] == 0)\n            Q.push(i);\n\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        int v = t[u];\n        in[v]--;\n        if(in[v] == 0)\n            Q.push(v);\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(in[i] && !vis[i])\n            dfs2(i);\n\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", ans[i], (" \\n")[i==N]);\n}',
  "1752":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1, logN = 20;\nconst int INF = 0x3f3f3f3f;\n\nint N, D, ct[maxN], sz[maxN], best[maxN];\nint timer, p[maxN][logN], d[maxN], in[maxN], out[maxN];\nbool vis[maxN];\nvector<int> G[maxN];\n\nvoid dfs(int u = 1, int par = 1){\n    in[u] = ++timer;\n    d[u] = d[par]+1;\n    p[u][0] = par;\n    for(int i = 1; i < logN; i++)\n        p[u][i] = p[p[u][i-1]][i-1];\n    for(int v : G[u])\n        if(v != par)\n            dfs(v, u);\n    out[u] = ++timer;\n}\n\nbool ancestor(int u, int v){\n    return in[u] <= in[v] && out[u] >= out[v];\n}\n\nint lca(int u, int v){\n    if(ancestor(u, v))  return u;\n    if(ancestor(v, u))  return v;\n    for(int i = logN-1; i >= 0; i--)\n        if(!ancestor(p[u][i], v))\n            u = p[u][i];\n    return p[u][0];\n}\n\nint dist(int u, int v){\n    return d[u] + d[v] - 2*d[lca(u, v)];\n}\n\nint find_size(int u, int p = -1){\n    if(vis[u])  return 0;\n\n    sz[u] = 1;\n    for(int v : G[u])\n        if(v != p)\n            sz[u] += find_size(v, u);\n\n    return sz[u];\n}\n\nint find_centroid(int u, int p, int n){\n    for(int v : G[u])\n        if(v != p)\n            if(!vis[v] && sz[v] > n/2)\n                return find_centroid(v, u, n);\n\n    return u;\n}\n\nvoid build_centroid_tree(int u = 1, int p = -1){\n    find_size(u);\n\n    int c = find_centroid(u, -1, sz[u]);\n    vis[c] = true;\n    ct[c] = p;\n\n    for(int v : G[c])\n        if(!vis[v])\n            build_centroid_tree(v, c);\n}\n\nvoid update(int u){\n    best[u] = 0;\n    int v = u;\n    while(ct[v] != -1){\n        v = ct[v];\n        best[v] = min(best[v], dist(u, v));\n    }\n}\n\nint query(int u){\n    int ans = best[u];\n    int v = u;\n    while(ct[v] != -1){\n        v = ct[v];\n        ans = min(ans, best[v] + dist(u, v));\n    }\n    return ans;\n}\n\nint main(){\n    scanf("%d %d", &N, &D);\n    for(int i = 0, a, b; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs();\n    build_centroid_tree();\n    fill(best+1, best+N+1, INF);\n\n    vector<int> order(N);\n    for(int i = 0; i < N; i++)\n        order[i] = i+1;\n    sort(order.begin(), order.end(), [](int a, int b){\n        return d[a] == d[b] ? a < b : d[a] > d[b];\n    });\n\n    vector<int> ans;\n    for(int u : order){\n        int dist_to_office = query(u);\n        if(dist_to_office >= D){\n            ans.push_back(u);\n            update(u);\n        }\n    }\n\n    sort(ans.begin(), ans.end());\n    int K = (int) ans.size();\n    printf("%d\\n", K);\n    for(int i = 0; i < K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K-1]);\n}',
  "1753":
    "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e6+5, numP = 3;\nconst ll MOD = 1e9+7;\nconst ll prime[numP] = {31, 37, 43};\n\nint N, M, cnt;\nll sh[numP], th[numP], pw[numP][maxN];\nchar S[maxN], T[maxN];\n\nbool hashes_equal(){\n    for(int p = 0; p < numP; p++)\n        if(sh[p] != th[p])\n            return false;\n    return true;\n}\n\nint main(){\n    scanf(\"%s %s\", S, T);\n    N = (int) strlen(S); M = (int) strlen(T);\n\n    if(M > N){\n        printf(\"0\\n\");\n        return 0;\n    }\n\n    for(int p = 0; p < numP; p++){\n        pw[p][0] = 1;\n        for(int i = 1; i < maxN; i++)\n            pw[p][i] = (pw[p][i-1] * prime[p]) % MOD;\n    }\n\n    for(int i = 0; i < M; i++){\n        for(int p = 0; p < numP; p++){\n            sh[p] = (sh[p] + (S[i] - 'a' + 1) * pw[p][M-i-1]) % MOD;\n            th[p] = (th[p] + (T[i] - 'a' + 1) * pw[p][M-i-1]) % MOD;\n        }\n    }\n\n    if(hashes_equal())  cnt++;\n    for(int i = M; i < N; i++){\n        for(int p = 0; p < numP; p++){\n            sh[p] = (sh[p] * prime[p] - (S[i-M] - 'a' + 1) * pw[p][M]) % MOD;\n            sh[p] = (sh[p] + (S[i] - 'a' + 1) + MOD) % MOD;\n        }\n        if(hashes_equal())  cnt++;\n    }\n    printf(\"%d\\n\", cnt);\n}\n",
  "1754":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T, a, b;\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        scanf("%d %d", &a, &b);\n        printf(((a+b)%3 != 0 || a > 2*b || b > 2*a) ? "NO\\n" : "YES\\n");\n    }\n}\n',
  "1755":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar S[1000001];\nint N, odd, freq[26];\n\nint main(){\n    scanf("%s", S);\n    N = (int) strlen(S);\n    for(int i = 0; i < N; i++)\n        freq[(int) (S[i]-\'A\')]++;\n\n    odd = -1;\n    for(int i = 0; i < 26; i++){\n        if(freq[i]&1){\n            if(odd != -1){\n                printf("NO SOLUTION\\n");\n                return 0;\n            } else {\n                odd = i;\n            }\n        }\n    }\n\n    for(int i = 0; i < 26; i++)\n        for(int j = 0; j < freq[i]/2; j++)\n            printf("%c", (char) (i+\'A\'));\n    if(odd != -1)\n        printf("%c", (char) (odd+\'A\'));\n    for(int i = 25; i >= 0; i--)\n        for(int j = 0; j < freq[i]/2; j++)\n            printf("%c", (char) (i+\'A\'));\n}\n',
  "1756":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nint N, M, a, b;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        printf("%d %d\\n", min(a, b), max(a, b));\n    }\n}\n',
  "1757":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5;\n\nint N, M, a, b, idx, in[maxN], ans[maxN];\nvector<int> G[maxN];\npriority_queue<int> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[b].push_back(a);\n        in[a]++;\n    }\n\n    for(int i = 1; i <= N; i++)\n        if(in[i] == 0)\n            Q.push(i);\n\n    idx = N;\n    while(!Q.empty()){\n        int u = Q.top(); Q.pop();\n        ans[idx--] = u;\n        for(int v : G[u]){\n            in[v]--;\n            if(in[v] == 0)\n                Q.push(v);\n        }\n    }\n\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", ans[i], (" \\n")[i==N]);\n}\n',
  "2064":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nll N, numerator, denominator;\n\nll fastpow(ll a, ll b){\n    ll res = 1;\n    while(b > 0){\n        if(b&1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll inverse(ll a){\n    return fastpow(a, MOD-2);\n}\n\nint main(){\n    scanf("%lld", &N);\n    if(N&1) printf("0\\n");\n    else {\n        numerator = 1;\n        for(int i = 1; i <= N; i++)\n            numerator = (numerator * i) % MOD;\n\n        denominator = 1;\n        for(int i = 1; i <= N/2; i++)\n            denominator = (denominator * i) % MOD;\n        denominator = (denominator * denominator) % MOD;\n        denominator = (denominator * (N/2+1)) % MOD;\n\n        printf("%lld\\n", (numerator*inverse(denominator))%MOD);\n    }\n}\n',
  "2072":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nuniform_int_distribution<int> dist(1, (int) 2e9);\n\nstruct Node {\n    char ch;\n    int prior, sz;\n    Node *l, *r;\n\n    Node(){}\n    Node(char c, int p){\n        prior = p;\n        ch = c;\n        sz = 1;\n        l = r = nullptr;\n    }\n};\n\nint N, M, a, b;\nchar S[maxN];\nNode *root;\n\nint sz(Node *t){ return t ? t->sz : 0; }\n\nvoid pull(Node *t){\n    if(!t)  return;\n    t->sz = sz(t->l) + sz(t->r) + 1;\n}\n\nvoid push(Node *t){\n    if(!t)  return;\n}\n\nNode* merge(Node *x, Node *y){\n    if(!x || !y)    return x ? x : y;\n\n    push(x); push(y);\n    if(x->prior < y->prior){\n        x->r = merge(x->r, y);\n        pull(x);\n        return x;\n    } else {\n        y->l = merge(x, y->l);\n        pull(y);\n        return y;\n    }\n}\n\npair<Node*,Node*> split(Node *x, int k){\n    if(!x)  return {nullptr, nullptr};\n\n    pair<Node*,Node*> y = {nullptr, nullptr};\n    push(x);\n    if(k <= sz(x->l)){\n        y = split(x->l, k);\n        x->l = y.second;\n        pull(x);\n        y.second = x;\n    } else {\n        y = split(x->r, k-sz(x->l)-1);\n        x->r = y.first;\n        pull(x);\n        y.first = x;\n    }\n    return y;\n}\n\nvoid heapify(Node *t){\n    if(!t)  return;\n\n    Node *mx = t;\n    if(t->l && t->l->prior > mx->prior) mx = t->l;\n    if(t->r && t->r->prior > mx->prior) mx = t->r;\n    if(mx != t){\n        swap(t->prior, mx->prior);\n        heapify(mx);\n    }\n}\n\nNode* build(int x, int k){\n    if(k == 0)  return nullptr;\n\n    int mid = k/2;\n    Node *t = new Node(S[x+mid], dist(rng));\n    t->l = build(x, mid);\n    t->r = build(x+mid+1, k-mid-1);\n    heapify(t);\n    pull(t);\n    return t;\n}\n\nvoid cut(int x, int k){\n    pair<Node*,Node*> y, z;\n    y = split(root, x-1);\n    z = split(y.second, k);\n    y.second = merge(z.second, z.first);\n    root = merge(y.first, y.second);\n}\n\nvoid print(Node *t){\n    if(!t)  return;\n    push(t);\n    print(t->l);\n    printf("%c", t->ch);\n    print(t->r);\n}\n\nint main(){\n    scanf("%d %d %s", &N, &M, S);\n    root = build(0, N);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        int len = (b-a+1);\n        cut(a, len);\n    }\n    print(root);\n}\n',
  "2073":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nuniform_int_distribution<int> dist(1, (int) 2e9);\n\nstruct Node {\n    bool rev;\n    char ch;\n    int prior, sz;\n    Node *l, *r;\n\n    Node(){}\n    Node(char c, int p){\n        prior = p;\n        ch = c;\n        sz = 1;\n        l = r = nullptr;\n    }\n};\n\nint N, M, a, b;\nchar S[maxN];\nNode *root;\n\nint sz(Node *t){ return t ? t->sz : 0; }\n\nvoid flip(Node *t){\n    if(!t)  return;\n    t->rev ^= true;\n}\n\nvoid pull(Node *t){\n    if(!t)  return;\n    t->sz = sz(t->l) + sz(t->r) + 1;\n}\n\nvoid push(Node *t){\n    if(!t)  return;\n    if(t->rev){\n        swap(t->l, t->r);\n        flip(t->l); flip(t->r);\n        t->rev = false;\n    }\n}\n\nNode* merge(Node *x, Node *y){\n    if(!x || !y)    return x ? x : y;\n\n    push(x); push(y);\n    if(x->prior < y->prior){\n        x->r = merge(x->r, y);\n        pull(x);\n        return x;\n    } else {\n        y->l = merge(x, y->l);\n        pull(y);\n        return y;\n    }\n}\n\npair<Node*,Node*> split(Node *x, int k){\n    if(!x)  return {nullptr, nullptr};\n\n    pair<Node*,Node*> y = {nullptr, nullptr};\n    push(x);\n    if(k <= sz(x->l)){\n        y = split(x->l, k);\n        x->l = y.second;\n        pull(x);\n        y.second = x;\n    } else {\n        y = split(x->r, k-sz(x->l)-1);\n        x->r = y.first;\n        pull(x);\n        y.first = x;\n    }\n    return y;\n}\n\nvoid heapify(Node *t){\n    if(!t)  return;\n\n    Node *mx = t;\n    if(t->l && t->l->prior > mx->prior) mx = t->l;\n    if(t->r && t->r->prior > mx->prior) mx = t->r;\n    if(mx != t){\n        swap(t->prior, mx->prior);\n        heapify(mx);\n    }\n}\n\nNode* build(int x, int k){\n    if(k == 0)  return nullptr;\n\n    int mid = k/2;\n    Node *t = new Node(S[x+mid], dist(rng));\n    t->l = build(x, mid);\n    t->r = build(x+mid+1, k-mid-1);\n    heapify(t);\n    pull(t);\n    return t;\n}\n\nvoid reverse(int x, int k){\n    pair<Node*,Node*> y, z;\n    y = split(root, x-1);\n    z = split(y.second, k);\n    flip(z.first);\n    y.second = merge(z.first, z.second);\n    root = merge(y.first, y.second);\n}\n\nvoid print(Node *t){\n    if(!t)  return;\n    push(t);\n    print(t->l);\n    printf("%c", t->ch);\n    print(t->r);\n}\n\nint main(){\n    scanf("%d %d %s", &N, &M, S);\n    root = build(0, N);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        int len = (b-a+1);\n        reverse(a, len);\n    }\n    print(root);\n}\n',
  "2074":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nuniform_int_distribution<int> dist(1, (int) 2e9);\n\nstruct Node {\n    bool rev;\n    int prior, sz;\n    ll val, sum;\n    Node *l, *r;\n\n    Node(){}\n    Node(ll v, int p){\n        prior = p;\n        sum = val = v;\n        sz = 1;\n        l = r = nullptr;\n    }\n};\n\nint N, M, type, a, b;\nll val[maxN];\nNode *root;\n\nint sz(Node *t){ return t ? t->sz : 0; }\nll sum(Node *t){ return t ? t->sum : 0; }\n\nvoid flip(Node *t){\n    if(!t)  return;\n    t->rev ^= true;\n}\n\nvoid pull(Node *t){\n    if(!t)  return;\n    t->sz = sz(t->l) + sz(t->r) + 1;\n    t->sum = sum(t->l) + sum(t->r) + t->val;\n}\n\nvoid push(Node *t){\n    if(!t)  return;\n    if(t->rev){\n        swap(t->l, t->r);\n        flip(t->l); flip(t->r);\n        t->rev = false;\n    }\n}\n\nNode* merge(Node *x, Node *y){\n    if(!x || !y)    return x ? x : y;\n\n    push(x); push(y);\n    if(x->prior < y->prior){\n        x->r = merge(x->r, y);\n        pull(x);\n        return x;\n    } else {\n        y->l = merge(x, y->l);\n        pull(y);\n        return y;\n    }\n}\n\npair<Node*,Node*> split(Node *x, int k){\n    if(!x)  return {nullptr, nullptr};\n\n    pair<Node*,Node*> y = {nullptr, nullptr};\n    push(x);\n    if(k <= sz(x->l)){\n        y = split(x->l, k);\n        x->l = y.second;\n        pull(x);\n        y.second = x;\n    } else {\n        y = split(x->r, k-sz(x->l)-1);\n        x->r = y.first;\n        pull(x);\n        y.first = x;\n    }\n    return y;\n}\n\nvoid heapify(Node *t){\n    if(!t)  return;\n\n    Node *mx = t;\n    if(t->l && t->l->prior > mx->prior) mx = t->l;\n    if(t->r && t->r->prior > mx->prior) mx = t->r;\n    if(mx != t){\n        swap(t->prior, mx->prior);\n        heapify(mx);\n    }\n}\n\nNode* build(int x, int k){\n    if(k == 0)  return nullptr;\n\n    int mid = k/2;\n    Node *t = new Node(val[x+mid], dist(rng));\n    t->l = build(x, mid);\n    t->r = build(x+mid+1, k-mid-1);\n    heapify(t);\n    pull(t);\n    return t;\n}\n\nvoid reverse(int x, int k){\n    pair<Node*,Node*> y, z;\n    y = split(root, x-1);\n    z = split(y.second, k);\n    flip(z.first);\n    y.second = merge(z.first, z.second);\n    root = merge(y.first, y.second);\n}\n\nll getSum(int x, int k){\n    pair<Node*,Node*> y, z;\n    y = split(root, x-1);\n    z = split(y.second, k);\n    ll ans = sum(z.first);\n    y.second = merge(z.first, z.second);\n    root = merge(y.first, y.second);\n    return ans;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < N; i++)\n        scanf("%lld", &val[i]);\n    root = build(0, N);\n\n    for(int i = 0; i < M; i++){\n        scanf("%d %d %d", &type, &a, &b);\n        int len = (b-a+1);\n        if(type == 1)\n            reverse(a, len);\n        else if(type == 2)\n            printf("%lld\\n", getSum(a, len));\n    }\n}\n',
  "2075":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nuniform_int_distribution<int> dist(1, (int) 2e9);\n\nstruct Node {\n    bool rev;\n    int value, prior, sz;\n    Node *p, *l, *r;\n\n    Node(){}\n    Node(int val, int pri){\n        prior = pri;\n        value = val;\n        sz = 1;\n        p = l = r = nullptr;\n    }\n};\n\nint N, X[maxN];\nNode *root, *ndptr[maxN];\n\nint sz(Node *t){    return t ? t->sz : 0;       }\nint val(Node *t){   return t ? t->value : -1;   }\n\nvoid flip(Node *t){\n    if(!t)\treturn;\n    t->rev ^= true;\n}\n\nvoid pull(Node *t){\n    if(!t)\treturn;\n    if(t->l)    t->l->p = t;\n    if(t->r)    t->r->p = t;\n    t->sz = sz(t->l) + sz(t->r) + 1;\n}\n\nvoid push(Node *t){\n    if(!t)\treturn;\n    if(t->rev){\n        swap(t->l, t->r);\n        flip(t->l); flip(t->r);\n        t->rev = false;\n    }\n}\n\nNode* merge(Node *x, Node *y){\n    if(!x || !y)\treturn x ? x : y;\n\n    push(x); push(y);\n    if(x->prior < y->prior){\n        x->r = merge(x->r, y);\n        pull(x);\n        return x;\n    } else {\n        y->l = merge(x, y->l);\n        pull(y);\n        return y;\n    }\n}\n\npair<Node*,Node*> split(Node *x, int k){\n    if(!x)\treturn {nullptr, nullptr};\n\n    pair<Node*,Node*> y = {nullptr, nullptr};\n    push(x);\n    if(k <= sz(x->l)){\n        y = split(x->l, k);\n        x->l = y.second;\n        pull(x);\n        y.second = x;\n    } else {\n        y = split(x->r, k-sz(x->l)-1);\n        x->r = y.first;\n        pull(x);\n        y.first = x;\n    }\n    return y;\n}\n\nvoid heapify(Node *t){\n    if(!t)\treturn;\n\n    Node *mx = t;\n    if(t->l && t->l->prior > mx->prior)\tmx = t->l;\n    if(t->r && t->r->prior > mx->prior)\tmx = t->r;\n    if(mx != t){\n        swap(t->prior, mx->prior);\n        heapify(mx);\n    }\n}\n\nNode* build(int x, int k){\n    if(k == 0)\treturn nullptr;\n\n    int mid = k/2;\n    Node *t = new Node(X[x+mid], dist(rng));\n    ndptr[X[x+mid]] = t;\n    t->l = build(x, mid);\n    t->r = build(x+mid+1, k-mid-1);\n    heapify(t);\n    pull(t);\n    return t;\n}\n\nvoid reverse(int x, int k){\n    pair<Node*,Node*> y, z;\n    y = split(root, x-1);\n    z = split(y.second, k);\n    flip(z.first);\n    y.second = merge(z.first, z.second);\n    root = merge(y.first, y.second);\n    root->p = nullptr;\n}\n\nint orderOf(int v){\n    Node* t = ndptr[v];\n\n    vector<Node*> walk;\n    while(t){\n        walk.push_back(t);\n        t = t->p;\n    }\n    reverse(walk.begin(), walk.end());\n    for(Node* nd : walk){\n        push(nd);\n        pull(nd);\n    }\n\n    t = ndptr[v];\n    int idx = sz(t->l);\n    while(t){\n        if(t->p && t == t->p->r)\n            idx += sz(t->p->l) + 1;\n        t = t->p;\n    }\n    return idx;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &X[i]);\n\n    root = build(0, N);\n\n    printf("%d\\n", N);\n    for(int l = 1; l <= N; l++){\n        int r = orderOf(l)+1;\n        reverse(l, r-l+1);\n        printf("%d %d\\n", l, r);\n    }\n}',
  "2076":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 1e5+1;\n\nint N, M, timer, tin[maxN], low[maxN];\nbool vis[maxN];\nvector<int> G[maxN];\nvector<pii> bridges;\n\nvoid dfs(int u = 1, int p = 0){\n    vis[u] = true;\n    tin[u] = low[u] = ++timer;\n    for(int v : G[u]){\n        if(v != p){\n            if(vis[v])  low[u] = min(low[u], tin[v]);\n            else {\n                dfs(v, u);\n                low[u] = min(low[u], low[v]);\n                if(low[v] > tin[u])\n                    bridges.push_back({u, v});\n            }\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs();\n\n    printf("%d\\n", (int) bridges.size());\n    for(pii P : bridges)\n        printf("%d %d\\n", P.first, P.second);\n}\n',
  "2077":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 1e5+1;\n\nbool vis[maxN], is_artic[maxN];\nint N, M, timer, tin[maxN], low[maxN];\nvector<int> ans, G[maxN];\n\nvoid dfs(int u = 1, int p = -1){\n    vis[u] = true;\n    tin[u] = low[u] = ++timer;\n\n    int children = 0;\n    for(int v : G[u]){\n        if(v != p){\n            if(vis[v])  low[u] = min(low[u], tin[v]);\n            else {\n                dfs(v, u);\n                low[u] = min(low[u], low[v]);\n                if(low[v] >= tin[u] && p != -1){\n                    if(!is_artic[u]){\n                        ans.push_back(u);\n                        is_artic[u] = true;\n                    }\n                }\n                children++;\n            }\n        }\n    }\n\n    if(p == -1 && children > 1){\n        if(!is_artic[u]){\n            ans.push_back(u);\n            is_artic[u] = true;\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs();\n\n    int K = (int) ans.size();\n    printf("%d\\n", K);\n    for(int i = 0; i < K; i++)\n        printf("%d%c", ans[i], (" \\n")[i==K-1]);\n}',
  "2078":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+1;\nconst int MOD = 1e9+7;\n\nint N, M, ans, ds[maxN];\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v])   swap(u, v);\n    ds[v] += ds[u];\n    ds[u] = v;\n    return true;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    fill(ds+1, ds+N+1, -1);\n    ans = 1;\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        if(!merge(a, b))\n            ans = (2 * ans) % MOD;\n    }\n    printf("%d\\n", ans);\n}',
  "2079":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\n\nint N, a, b, p[maxN], sz[maxN];\nvector<int> G[maxN];\n\nvoid dfs(int u = 1){\n    sz[u] = 1;\n    for(int v : G[u]){\n        if(v != p[u]){\n            p[v] = u;\n            dfs(v);\n            sz[u] += sz[v];\n        }\n    }\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    dfs();\n\n    for(int i = 1; i <= N; i++){\n        bool centroid = true;\n\n        if(p[i] != 0 && N-sz[i] > N/2)\n            centroid = false;\n\n        for(int v : G[i])\n            if(v != p[i] && sz[v] > N/2)\n                centroid = false;\n\n        if(centroid){\n            printf("%d\\n", i);\n            return 0;\n        }\n    }\n}\n',
  "2080":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, K, deepest, sz[maxN], cnt[maxN];\nbool vis[maxN];\nll ans;\nvector<int> G[maxN];\n\nint getSize(int u = 1, int p = -1){\n    sz[u] = 1;\n    for(int v : G[u])\n        if(v != p && !vis[v])\n            sz[u] += getSize(v, u);\n\n    return sz[u];\n}\n\nint centroid(int u, int p, int n){\n    for(int v : G[u])\n        if(v != p && !vis[v] && sz[v] > n/2)\n            return centroid(v, u, n);\n\n    return u;\n}\n\nvoid dfs(int u, int p, bool t, int d = 1){\n    if(d > K)   return;\n\n    deepest = max(deepest, d);\n    if(t)       cnt[d]++;\n    else        ans += cnt[K-d];\n\n    for(int v : G[u])\n        if(v != p && !vis[v])\n            dfs(v, u, t, d+1);\n}\n\nvoid solve(int u = 1){\n    int c = centroid(u, -1, getSize(u));\n    vis[c] = true;\n    deepest = 0;\n\n    for(int v : G[c]){\n        if(!vis[v]){\n            dfs(v, c, false);\n            dfs(v, c, true);\n        }\n    }\n    fill(cnt+1, cnt+deepest+1, 0);\n\n    for(int v : G[c])\n        if(!vis[v])\n            solve(v);\n}\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 0, a, b; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    cnt[0] = 1;\n    solve();\n    printf("%lld\\n", ans);\n}',
  "2081":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, A, B, deepest, sz[maxN];\nbool vis[maxN];\nll ans, ds[maxN];\nvector<int> G[maxN];\n\nvoid update(int idx, ll val){\n    for(int i = idx+1; i <= N; i += -i&i) ds[i] += val;\n}\n\nll query(int idx){\n    ll res = 0;\n    for(int i = idx+1; i > 0; i -= -i&i)\n        res += ds[i];\n    return res;\n}\n\nint getSize(int u = 1, int p = -1){\n    sz[u] = 1;\n    for(int v : G[u])\n        if(v != p && !vis[v])\n            sz[u] += getSize(v, u);\n\n    return sz[u];\n}\n\nint centroid(int u, int p, int n){\n    for(int v : G[u])\n        if(v != p && !vis[v] && sz[v] > n/2)\n            return centroid(v, u, n);\n\n    return u;\n}\n\nvoid dfs(int u, int p, bool t, int d = 1){\n    if(d > B)   return;\n\n    deepest = max(deepest, d);\n    if(t)   update(d, 1);\n    else {\n        ans += query(B-d);\n        ans -= query(max(0, A-d)-1);\n    }\n\n    for(int v : G[u])\n        if(v != p && !vis[v])\n            dfs(v, u, t, d+1);\n}\n\nvoid solve(int u = 1){\n    int c = centroid(u, -1, getSize(u));\n    vis[c] = true;\n    deepest = 0;\n\n    for(int v : G[c]){\n        if(!vis[v]){\n            dfs(v, c, false);\n            dfs(v, c, true);\n        }\n    }\n    for(int i = 1; i <= deepest; i++)\n        update(i, -query(i)+query(i-1));\n\n    for(int v : G[c])\n        if(!vis[v])\n            solve(v);\n}\n\nint main(){\n    scanf("%d %d %d", &N, &A, &B);\n    for(int i = 0, a, b; i < N-1; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    update(0, 1);\n    solve();\n    printf("%lld\\n", ans);\n}',
  "2084":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\nconst int SIZE = 4e6;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nstruct Line {\n    ll m, b;\n    ll operator()(const ll x) const {\n        return m * x + b;\n    }\n} seg[SIZE];\n\nint N, lo[SIZE], hi[SIZE];\nll X, s[maxN], f[maxN];\n\nvoid build(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    seg[i] = {0, INF};\n    if(l == r)  return;\n    int m = (l+r)/2;\n    build(2*i, l, m);\n    build(2*i+1, m+1, r);\n}\n\nvoid insert(int i, Line L){\n    int l = lo[i], r = hi[i];\n    if(l == r){\n        if(L(l) < seg[i](l))\n            seg[i] = L;\n        return;\n    }\n\n    int m = (l+r)/2;\n    if(seg[i].m < L.m)  swap(seg[i], L);\n    if(seg[i](m) > L(m)){\n        swap(seg[i], L);\n        insert(2*i, L);\n    } else insert(2*i+1, L);\n}\n\nll query(int i, ll x){\n    int l = lo[i], r = hi[i];\n    if(l == r)  return seg[i](x);\n\n    int m = (l+r)/2;\n    if(x < m)   return min(seg[i](x), query(2*i, x));\n    else        return min(seg[i](x), query(2*i+1, x));\n}\n\nint main(){\n    scanf("%d %lld", &N, &X);\n    for(int i = 0; i < N; i++)  scanf("%lld", &s[i]);\n    for(int i = 0; i < N; i++)  scanf("%lld", &f[i]);\n\n    build(1, 1, 1e6);\n    insert(1, {X, 0});\n    for(int i = 0; i < N-1; i++){\n        ll best = query(1, s[i]);\n        insert(1, {f[i], best});\n    }\n    printf("%lld\\n", query(1, s[N-1]));\n}',
  "2085":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\nconst int SIZE = 4e6;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nstruct Line {\n    ll m, b;\n    ll operator()(const ll x) const {\n        return m * x + b;\n    }\n} seg[SIZE];\n\nint N, lo[SIZE], hi[SIZE];\nll X, s[maxN], f[maxN];\n\nvoid build(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    seg[i] = {0, INF};\n    if(l == r)  return;\n    int m = (l+r)/2;\n    build(2*i, l, m);\n    build(2*i+1, m+1, r);\n}\n\nvoid insert(int i, Line L){\n    int l = lo[i], r = hi[i];\n    if(l == r){\n        if(L(l) < seg[i](l))\n            seg[i] = L;\n        return;\n    }\n\n    int m = (l+r)/2;\n    if(seg[i].m < L.m)  swap(seg[i], L);\n    if(seg[i](m) > L(m)){\n        swap(seg[i], L);\n        insert(2*i, L);\n    } else insert(2*i+1, L);\n}\n\nll query(int i, ll x){\n    int l = lo[i], r = hi[i];\n    if(l == r)  return seg[i](x);\n\n    int m = (l+r)/2;\n    if(x < m)   return min(seg[i](x), query(2*i, x));\n    else        return min(seg[i](x), query(2*i+1, x));\n}\n\nint main(){\n    scanf("%d %lld", &N, &X);\n    for(int i = 0; i < N; i++)  scanf("%lld", &s[i]);\n    for(int i = 0; i < N; i++)  scanf("%lld", &f[i]);\n\n    build(1, 1, 1e6);\n    insert(1, {X, 0});\n    for(int i = 0; i < N-1; i++){\n        ll best = query(1, s[i]);\n        insert(1, {f[i], best});\n    }\n    printf("%lld\\n", query(1, s[N-1]));\n}',
  "2086":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst int maxN = 3005;\n\nstruct Line {\n    ll m, b, c;\n    ll operator()(ll x){\n        return m * x + b;\n    }\n};\n\nstruct CHT {\n    Line dq[2*maxN];\n    int fptr, bptr;\n\n    void clear(){\n        dq[0] = {0, 0, 0};\n        fptr = 0; bptr = 1;\n    }\n\n    bool pop_back(Line& L, Line& L1, Line& L2){\n        ll v1 = (L.b - L2.b) * (L2.m - L1.m);\n        ll v2 = (L2.m - L.m) * (L1.b - L2.b);\n        return (v1 == v2 ? L.c > L1.c : v1 < v2);\n    }\n\n    bool pop_front(Line& L1, Line& L2, ll x){\n        ll v1 = L1(x);\n        ll v2 = L2(x);\n        return (v1 == v2 ? L1.c < L2.c : v1 > v2);\n    }\n\n    void insert(Line L){\n        while(bptr-fptr >= 2 && pop_back(L, dq[bptr-1], dq[bptr-2]))    bptr--;\n        dq[bptr++] = L;\n    }\n\n    pll query(ll x){\n        while(bptr-fptr >= 2 && pop_front(dq[fptr], dq[fptr+1], x))     fptr++;\n        return {dq[fptr](x), dq[fptr].c};\n    }\n};\n\nCHT cht;\nint N, K, cnt[maxN];\nll pre[maxN], dp[maxN];\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &pre[i]);\n        pre[i] += pre[i-1];\n        dp[i] = pre[i]*pre[i];\n    }\n\n    for(int k = 1; k <= K-1; k++){\n        cht.clear();\n        for(int i = 1; i <= k; i++)\n            cht.insert({-2*pre[i], dp[i]+pre[i]*pre[i], cnt[i]});\n        for(int i = k+1; i <= N; i++){\n            pll P = cht.query(pre[i]);\n            cht.insert({-2*pre[i], dp[i]+pre[i]*pre[i], cnt[i]});\n            dp[i] = pre[i]*pre[i] + P.first;\n            cnt[i] = P.second + 1;\n        }\n    }\n\n    printf("%lld\\n", dp[N]);\n}',
  "2087":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 3001;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nint N, K;\nll best, p[3][maxN], dp[maxN][maxN];\n\nll travel(int d, int a, int b){\n    return (p[d][b] - p[d][a-1]) - (p[0][b] - p[0][a-1]) * (d == 1 ? a : N-b+1);\n}\n\nll C(int a, int b){\n    int m = (a+b)/2;\n    return travel(1, a, m) + travel(2, m+1, b);\n}\n\nvoid solve(int k, int a = 1, int b = N, int optl = 1, int optr = N){\n    if(a > b)   return;\n    int m = (a+b)/2;\n    int opt = -1;\n    dp[k][m] = INF;\n    for(int i = optl; i <= m; i++){\n        if(dp[k-1][i] + C(i, m) < dp[k][m]){\n            dp[k][m] = dp[k-1][i] + C(i, m);\n            opt = i;\n        }\n    }\n    solve(k, a, m-1, optl, opt);\n    solve(k, m+1, b, opt, optr);\n}\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 1; i <= N; i++){\n        ll x;\n        scanf("%lld", &x);\n        p[0][i] = p[0][i-1] + x;\n        p[1][i] = p[1][i-1] + i * x;\n        p[2][i] = p[2][i-1] + (N-i+1) * x;\n    }\n\n    for(int i = 1; i <= N; i++)\n        dp[1][i] = travel(2, 1, i);\n    for(int k = 2; k <= K; k++)\n        solve(k);\n\n    best = INF;\n    for(int i = 1; i <= N; i++)\n        best = min(best, dp[K][i] + travel(1, i, N));\n    printf("%lld\\n", best);\n}',
  "2088":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int maxN = 5005;\n\nint N, split[maxN][maxN];\nll pre[maxN], dp[maxN][maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++){\n        scanf("%lld", &pre[i]);\n        pre[i] += pre[i-1];\n    }\n\n    for(int len = 0; len <= N; len++){\n        for(int l = 0; l+len <= N; l++){\n            int r = l+len;\n            if(len < 2){\n                dp[l][r] = 0;\n                split[l][r] = l;\n                continue;\n            }\n\n            dp[l][r] = INF;\n            for(int m = split[l][r-1]; m <= split[l+1][r]; m++){\n                ll possible = dp[l][m] + dp[m][r] + pre[r] - pre[l];\n                if(possible < dp[l][r]){\n                    dp[l][r] = possible;\n                    split[l][r] = m;\n                }\n            }\n        }\n    }\n\n    printf("%lld\\n", dp[0][N]);\n}',
  "2101":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 4e5+1;\n\nint N, M, Q, x, y, root, idcounter;\n\nstruct Node {\n    bool rev = false;\n    Node *c[2] = {nullptr, nullptr}, *p = nullptr;\n    int val, mx, id = ++idcounter;\n\n    Node(int v){\n        val = mx = v;\n    }\n\n    void push(){\n        if(rev){\n            swap(c[0], c[1]);\n            if(c[0])    c[0]->rev ^= true;\n            if(c[1])    c[1]->rev ^= true;\n            rev = false;\n        }\n    }\n\n    void pull(){\n        mx = val;\n        for(int i = 0; i < 2; i++)\n            if(c[i])\n                mx = max(mx, c[i]->mx);\n    }\n} *LCT[maxN];\n\nbool notRoot(Node *t){\n    return t->p && (t->p->c[0] == t || t->p->c[1] == t);\n}\n\nvoid rotate(Node *t){\n    Node *p = t->p;\n    bool b = (p->c[0] == t);\n    if((t->p = p->p) && notRoot(p)) t->p->c[(t->p->c[1] == p)] = t;\n    if((p->c[!b]=t->c[b]))          p->c[!b]->p = p;\n    t->c[b] = p;\n    p->p = t;\n    p->pull();\n}\n\n\nvoid splay(Node *t){\n    while(notRoot(t)){\n        Node *p = t->p;\n        p->push();\n        t->push();\n        rotate(t);\n    }\n    t->push();\n    t->pull();\n}\n\nNode* access(Node *t){\n    Node *last = nullptr;\n    for(Node *u = t; u; u = u->p){\n        splay(u);\n        u->c[1] = last;\n        last = u;\n    }\n    splay(t);\n    return last;\n}\n\nvoid evert(Node *t){\n    access(t);\n    t->rev = true;\n}\n\nvoid link(Node *u, Node *v){\n    evert(u);\n    u->p = v;\n}\n\nvoid cut(Node *u, Node *v){\n    evert(u);\n    access(v);\n    if(v->c[0]) v->c[0]->p = 0;\n    v->c[0] = 0;\n    v->pull();\n}\n\nNode* path(Node *u, Node *v){\n    evert(u);\n    access(v);\n    return v;\n}\n\nNode* LCA(Node *u, Node *v){\n    evert(LCT[root]);\n    access(u);\n    return access(v);\n}\n\nbool connected(Node *u, Node *v){\n    path(u, v);\n    while(v->c[0])\n        v = v->c[0];\n    return u == v;\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &Q);\n    for(int i = 1; i <= N; i++)\n        LCT[i] = new Node(0);\n    for(int i = 1; i <= M; i++){\n        scanf("%d %d", &x, &y);\n        LCT[N+i] = new Node(i);\n        if(!connected(LCT[x], LCT[y])){\n            link(LCT[x], LCT[N+i]);\n            link(LCT[y], LCT[N+i]);\n        }\n    }\n\n    root = 1;\n    for(int q = 0; q < Q; q++){\n        scanf("%d %d", &x, &y);\n        if(connected(LCT[x], LCT[y])){\n            Node *p = path(LCT[x], LCT[y]);\n            printf("%d\\n", p->mx);\n        } else printf("-1\\n");\n    }\n}\n',
  "2102":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    int len, link, cnt, firstpos;\n    map<char,int> nxt;\n} node[2*maxN];\n\nchar S[maxN], T[5*maxN];\nint N, M, K, sz, last;\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nbool query(){\n    int u = 0;\n    for(int i = 0; i < M; i++){\n        char c = T[i];\n        if(!node[u].nxt.count(c))   return false;\n        else                        u = node[u].nxt[c];\n    }\n    return true;\n}\n\nint main(){\n    scanf(" %s %d", S, &K);\n    N = (int) strlen(S);\n    init();\n\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n\n    for(int i =  0; i < K; i++){\n        scanf(" %s", T);\n        M = (int) strlen(T);\n        printf("%s\\n", query() ? "YES" : "NO");\n    }\n}',
  "2103":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    int len, link, cnt;\n    map<char,int> nxt;\n} node[2*maxN];\n\nchar S[maxN], T[5*maxN];\nint N, M, K, sz, last;\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].cnt = 1;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nvoid update_cnts(){\n    vector<int> states_by_len[sz];\n    for(int i = 0; i < sz; i++)\n        states_by_len[node[i].len].push_back(i);\n    for(int i = sz-1; i >= 0; i--)\n        for(int u : states_by_len[i])\n            if(node[u].link != -1)\n                node[node[u].link].cnt += node[u].cnt;\n}\n\nint query(){\n    int u = 0;\n    for(int i = 0; i < M; i++){\n        char c = T[i];\n        if(!node[u].nxt.count(c))   return 0;\n        else                        u = node[u].nxt[c];\n    }\n    return node[u].cnt;\n}\n\nint main(){\n    scanf(" %s %d", S, &K);\n    N = (int) strlen(S);\n\n    init();\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n    update_cnts();\n\n    for(int i =  0; i < K; i++){\n        scanf(" %s", T);\n        M = (int) strlen(T);\n        printf("%d\\n", query());\n    }\n}',
  "2104":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    int len, link, cnt, firstpos;\n    map<char,int> nxt;\n} node[2*maxN];\n\nchar S[maxN], T[5*maxN];\nint N, M, K, sz, last;\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].cnt = 1;\n    node[cur].firstpos = node[last].len;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            node[clone].firstpos = node[q].firstpos;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nvoid update_cnts(){\n    vector<int> states_by_len[sz];\n    for(int i = 0; i < sz; i++)\n        states_by_len[node[i].len].push_back(i);\n    for(int i = sz-1; i >= 0; i--)\n        for(int u : states_by_len[i])\n            if(node[u].link != -1)\n                node[node[u].link].cnt += node[u].cnt;\n}\n\nint query_cnt(){\n    int u = 0;\n    for(int i = 0; i < M; i++){\n        char c = T[i];\n        if(!node[u].nxt.count(c))   return 0;\n        else                        u = node[u].nxt[c];\n    }\n    return node[u].cnt;\n}\n\nint query_idx(){\n    int u = 0;\n    for(int i = 0; i < M; i++){\n        char c = T[i];\n        if(!node[u].nxt.count(c))   return -1;\n        else                        u = node[u].nxt[c];\n    }\n    return node[u].firstpos-M+2;\n}\n\nint main(){\n    scanf(" %s %d", S, &K);\n    N = (int) strlen(S);\n\n    init();\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n    update_cnts();\n\n    for(int i =  0; i < K; i++){\n        scanf(" %s", T);\n        M = (int) strlen(T);\n        printf("%d\\n", query_idx());\n    }\n}',
  "2105":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    ll dp;\n    int len, link;\n    map<char,int> nxt;\n} node[2*maxN];\n\nchar S[maxN];\nint N, sz, last;\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid calc(int u = 0){\n    node[u].dp = 1;\n    for(const auto& [c, v] : node[u].nxt){\n        if(!node[v].dp) calc(v);\n        node[u].dp += node[v].dp;\n    }\n}\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n\n    init();\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n    calc();\n\n    printf("%lld\\n", node[0].dp-1);\n}',
  "2106":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    int len, link, cnt, firstpos;\n    map<char,int> nxt;\n} node[2*maxN];\n\nchar S[maxN];\nbool vis[2*maxN];\nint N, sz, last, bestidx, bestlen;\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].cnt = 1;\n    node[cur].firstpos = node[last].len;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            node[clone].firstpos = node[q].firstpos;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nvoid update_cnts(){\n    vector<int> states_by_len[sz];\n    for(int i = 0; i < sz; i++)\n        states_by_len[node[i].len].push_back(i);\n    for(int i = sz-1; i >= 0; i--)\n        for(int u : states_by_len[i])\n            if(node[u].link != -1)\n                node[node[u].link].cnt += node[u].cnt;\n}\n\nvoid dfs(int u = 0){\n    vis[u] = true;\n    if(node[u].len > bestlen && node[u].cnt > 1 && u != 0){\n        bestidx = node[u].firstpos - node[u].len + 1;\n        bestlen = node[u].len;\n    }\n    for(const auto& [c, v] : node[u].nxt)\n        if(!vis[v])\n            dfs(v);\n}\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n\n    init();\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n    update_cnts();\n\n    bestlen = -1;\n    dfs();\n\n    if(bestlen == -1)   printf("-1\\n");\n    else {\n        for(int i = 0; i < bestlen; i++)\n            printf("%c", S[bestidx+i]);\n    }\n}',
  "2107":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6+5;\n\nchar S[maxN];\nint N, z[maxN], pi[maxN];\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n\n    for(int i = 1, l = 0, r = 0; i < N; i++){\n        if(i <= r)  z[i] = min(r-i+1, z[i-l]);\n        while(i+z[i] < N && S[z[i]] == S[i+z[i]])   z[i]++;\n        if(i+z[i]-1 > r)    l = i, r = i+z[i]-1;\n    }\n    for(int i = 0; i < N; i++)\n        printf("%d%c", z[i], (" \\n")[i==N-1]);\n\n    for(int i = 1; i < N; i++){\n        int j = pi[i-1];\n        while(j > 0 && S[i] != S[j])    j = pi[j-1];\n        if(S[i] == S[j])    j++;\n        pi[i] = j;\n    }\n    for(int i = 0; i < N; i++)\n        printf("%d%c", pi[i], (" \\n")[i==N-1]);\n}',
  "2108":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    ll dp;\n    int len, link;\n    map<char,int> nxt;\n} node[2*maxN];\n\nvector<char> ans;\nchar S[maxN];\nint N, sz, last;\nll K;\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid calc(int u = 0){\n    node[u].dp = 1;\n    for(const auto& [c, v] : node[u].nxt){\n        if(!node[v].dp) calc(v);\n        node[u].dp += node[v].dp;\n    }\n}\n\nvoid dfs(int u, ll k){\n    if(k < 0)   return;\n    for(const auto& [c, v] : node[u].nxt){\n        if(node[v].dp <= k) k -= node[v].dp;\n        else {\n            ans.push_back(c);\n            dfs(v, k-1);\n            return;\n        }\n    }\n}\n\nint main(){\n    scanf(" %s %lld", S, &K);\n    N = (int) strlen(S);\n\n    init();\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n    calc();\n\n    dfs(0, K-1);\n    int M = (int) ans.size();\n    for(int i = 0; i < M; i++)\n        printf("%c", ans[i]);\n    printf("\\n");\n}',
  "2109":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    ll dp;\n    int len, cnt, link;\n    map<char,int> nxt;\n} node[2*maxN];\n\nvector<char> ans;\nchar S[maxN];\nint N, sz, last;\nll K;\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].cnt = 1;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid update_cnts(){\n    vector<int> states_by_len[sz];\n    for(int i = 0; i < sz; i++)\n        states_by_len[node[i].len].push_back(i);\n    for(int i = sz-1; i >= 0; i--)\n        for(int u : states_by_len[i])\n            if(node[u].link != -1)\n                node[node[u].link].cnt += node[u].cnt;\n}\n\nvoid calc(int u = 0){\n    node[u].dp = node[u].cnt;\n    for(const auto& [c, v] : node[u].nxt){\n        if(!node[v].dp) calc(v);\n        node[u].dp += node[v].dp;\n    }\n}\n\nvoid dfs(int u, ll k){\n    if(k < 0)   return;\n    for(const auto& [c, v] : node[u].nxt){\n        if(node[v].dp <= k) k -= node[v].dp;\n        else {\n            ans.push_back(c);\n            dfs(v, k-node[v].cnt);\n            return;\n        }\n    }\n}\n\nint main(){\n    scanf(" %s %lld", S, &K);\n    N = (int) strlen(S);\n\n    init();\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n    update_cnts();\n    calc();\n\n    dfs(0, K-1);\n    int M = (int) ans.size();\n    for(int i = 0; i < M; i++)\n        printf("%c", ans[i]);\n    printf("\\n");\n}',
  "2110":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+5;\n\nstruct Node {\n    int len, link;\n    map<char,int> nxt;\n} node[2*maxN];\n\nchar S[maxN];\nbool vis[2*maxN];\nint N, sz, last, dist[2*maxN];\nll ans[maxN];\n\nvoid extend(char c){\n    int cur = sz++;\n    node[cur].len = node[last].len + 1;\n    int p = last;\n    while(p != -1 && !node[p].nxt.count(c)){\n        node[p].nxt[c] = cur;\n        p = node[p].link;\n    }\n    if(p == -1){\n        node[cur].link = 0;\n    } else {\n        int q = node[p].nxt[c];\n        if(node[p].len + 1 == node[q].len){\n            node[cur].link = q;\n        } else {\n            int clone = sz++;\n            node[clone].len = node[p].len + 1;\n            node[clone].nxt = node[q].nxt;\n            node[clone].link = node[q].link;\n            while(p != -1 && node[p].nxt[c] == q){\n                node[p].nxt[c] = clone;\n                p = node[p].link;\n            }\n            node[q].link = node[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n\nvoid init(){\n    node[0].len = 0;\n    node[0].link = -1;\n    sz = 1;\n    last = 0;\n}\n\nvoid bfs(int s = 0){\n    queue<int> Q;\n    vis[s] = true;\n    dist[s] = 0;\n    Q.push(s);\n    while(!Q.empty()){\n        int u = Q.front();\n        Q.pop();\n        ans[dist[u]]++;\n        ans[node[u].len+1]--;\n        for(const auto& [c, v] : node[u].nxt){\n            if(!vis[v]){\n                dist[v] = dist[u]+1;\n                vis[v] = true;\n                Q.push(v);\n            }\n        }\n    }\n}\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n    init();\n\n    for(int i = 0; i < N; i++)\n        extend(S[i]);\n\n    bfs();\n    for(int i = 1; i <= N; i++){\n        ans[i] += ans[i-1];\n        printf("%lld%c", ans[i], (" \\n")[i==N]);\n    }\n}',
  "2111":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef double ld;\ntypedef complex<ld> cd;\nconst int SIZE = 1<<19;\nconst ld PI = acos(-1);\n\nint N, M, K;\nvector<cd> A(SIZE), B(SIZE);\n\nvoid fft(vector<cd> &a, bool inv){\n    int N = (int) a.size();\n\n    for(int i = 1, j = 0; i < N; i++){\n        int bit = N>>1;\n        for(; j&bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if(i < j)\n            swap(a[i], a[j]);\n    }\n\n    for(int len = 2; len <= N; len <<= 1){\n        ld theta = 2*PI / len * (inv ? -1 : 1);\n        cd wlen(cos(theta), sin(theta));\n        for(int i = 0; i < N; i += len){\n            cd w(1);\n            for(int j = 0; j < len / 2; j++){\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if(inv)\n        for(cd &z : a)\n            z /= N;\n}\n\nint main(){\n    scanf("%d %d %d", &K, &N, &M);\n    for(int i = 0, x; i < N; i++){\n        scanf("%d", &x);\n        A[x] += 1;\n    }\n    for(int i = 0, x; i < M; i++){\n        scanf("%d", &x);\n        B[x] += 1;\n    }\n\n    fft(A, false);\n    fft(B, false);\n    for(int i = 0; i < SIZE; i++)\n        A[i] *= B[i];\n    fft(A, true);\n\n    for(int i = 2; i <= 2*K; i++)\n        printf("%lld%c", llround(A[i].real()), (" \\n")[i==2*K]);\n}',
  "2112":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef double ld;\ntypedef complex<ld> cd;\nconst int maxN = 2e5+5;\nconst int SIZE = 1<<19;\nconst ld PI = acos(-1);\n\nchar S[maxN];\nvector<cd> A(SIZE), B(SIZE);\n\nvoid fft(vector<cd> &a, bool inv){\n    int N = (int) a.size();\n\n    for(int i = 1, j = 0; i < N; i++){\n        int bit = N>>1;\n        for(; j&bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if(i < j)\n            swap(a[i], a[j]);\n    }\n\n    for(int len = 2; len <= N; len <<= 1){\n        ld theta = 2*PI / len * (inv ? -1 : 1);\n        cd wlen(cos(theta), sin(theta));\n        for(int i = 0; i < N; i += len){\n            cd w(1);\n            for(int j = 0; j < len / 2; j++){\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if(inv)\n        for(cd &z : a)\n            z /= N;\n}\n\nint main(){\n    scanf(" %s", S);\n    int N = (int) strlen(S);\n    for(int i = 0; i < N; i++){\n        if(S[i] == \'1\'){\n            A[i] += 1;\n            B[N-i-1] += 1;\n        }\n    }\n\n    fft(A, false);\n    fft(B, false);\n    for(int i = 0; i < SIZE; i++)\n        A[i] *= B[i];\n    fft(A, true);\n\n    for(int i = N; i < 2*N-1; i++)\n        printf("%lld%c", llround(A[i].real()), (" \\n")[i==2*N-2]);\n}',
  "2113":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef double ld;\ntypedef complex<ld> cd;\nconst int maxN = 2e5+5;\nconst int SIZE = 1<<19;\nconst ld PI = acos(-1);\n\nint N, M;\nvector<cd> A(SIZE), B(SIZE);\n\nvoid fft(vector<cd> &a, bool inv){\n    int n = (int) a.size();\n\n    for(int i = 1, j = 0; i < n; i++){\n        int bit = n>>1;\n        for(; j&bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if(i < j)\n            swap(a[i], a[j]);\n    }\n\n    for(int len = 2; len <= n; len <<= 1){\n        ld theta = 2*PI / len * (inv ? -1 : 1);\n        cd wlen(cos(theta), sin(theta));\n        for(int i = 0; i < n; i += len){\n            cd w(1);\n            for(int j = 0; j < len / 2; j++){\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if(inv)\n        for(cd &z : a)\n            z /= n;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a; i < N; i++){\n        scanf("%d", &a);\n        A[i] = a;\n    }\n    for(int i = 0, b; i < M; i++){\n        scanf("%d", &b);\n        B[M-i-1] = b;\n    }\n\n    fft(A, false);\n    fft(B, false);\n    for(int i = 0; i < SIZE; i++)\n        A[i] *= B[i];\n    fft(A, true);\n\n    for(int i = 0; i < N+M-1; i++)\n        printf("%lld%c", llround(A[i].real()), (" \\n")[i==N+M-2]);\n}',
  "2115":
    "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef complex<ld> cd;\nconst int maxN = 2e5+5;\nconst ld PI = acos(-1);\n\nll ans[maxN];\nchar S[maxN];\n\nvoid fft(vector<cd> &a, bool inv){\n    int N = (int) a.size();\n\n    for(int i = 1, j = 0; i < N; i++){\n        int bit = N>>1;\n        for(; j&bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if(i < j)\n            swap(a[i], a[j]);\n    }\n\n    for(int len = 2; len <= N; len <<= 1){\n        ld theta = 2*PI / len * (inv ? -1 : 1);\n        cd wlen(cos(theta), sin(theta));\n        for(int i = 0; i < N; i += len){\n            cd w(1);\n            for(int j = 0; j < len / 2; j++){\n                cd u = a[i+j], v = a[i+j+len/2] * w;\n                a[i+j] = u + v;\n                a[i+j+len/2] = u - v;\n                w *= wlen;\n            }\n        }\n    }\n\n    if(inv)\n        for(cd &z : a)\n            z /= N;\n}\n\nint next_two_pow(int x){\n    return 1<<(32 - __builtin_clz(x));\n}\n\nvoid solve(int l, int r){\n    if(l+1 == r){\n        ans[(int) (S[l] - '0')]++;\n        return;\n    }\n\n    int m = (l+r)/2;\n    int sz = next_two_pow(r-l);\n    vector<cd> A(sz), B(sz);\n    for(int i = m-1, cnt = 0; i >= l; i--){\n        if(S[i] == '1') cnt++;\n        A[cnt] += 1;\n    }\n    for(int i = m, cnt = 0; i < r; i++){\n        if(S[i] == '1') cnt++;\n        B[cnt] += 1;\n    }\n\n    fft(A, false);\n    fft(B, false);\n    for(int i = 0; i < sz; i++)\n        A[i] *= B[i];\n    fft(A, true);\n\n    for(int i = 0; i < sz && i < maxN; i++)\n        ans[i] += llround(A[i].real());\n\n    solve(l, m);\n    solve(m, r);\n}\n\nint main(){\n    scanf(\" %s\", S);\n    int N = (int) strlen(S);\n    solve(0, N);\n    for(int i = 0; i <= N; i++)\n        printf(\"%lld%c\", ans[i], (\" \\n\")[i==N]);\n}",
  "2121":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 501, maxM = 1001;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nint N, M, K, p[maxN];\nll d[maxN], cap[maxN][maxN], cost[maxN][maxN];\nbool inq[maxN];\nvector<int> G[maxN];\n\nstruct Edge {\n    int u, v;\n    ll r, c;\n} edges[maxM], redges[maxM];\n\nvoid bellman_ford(){\n    fill(inq+1, inq+N+1, false);\n    fill(d+1, d+N+1, INF);\n    fill(p+1, p+N+1, 0);\n\n    queue<int> Q;\n    Q.push(1);\n    d[1] = 0;\n    inq[1] = true;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        inq[u] = false;\n\n        for(int i : G[u]){\n            Edge e = (i < 0 ? redges[-i] : edges[i]);\n            if(e.r > 0 && d[e.v] > d[u] + e.c){\n                d[e.v] = d[u] + e.c;\n                p[e.v] = i;\n                if(!inq[e.v]){\n                    inq[e.v] = true;\n                    Q.push(e.v);\n                }\n            }\n        }\n    }\n}\n\nll minimum_cost_flow(){\n    ll flow = 0, cost = 0;\n    while(flow < K){\n        bellman_ford();\n        if(d[N] == INF) break;\n\n        ll aug = K-flow;\n        int u = N;\n        while(u != 1){\n            Edge e = (p[u] < 0 ? redges[-p[u]] : edges[p[u]]);\n            aug = min(aug, e.r);\n            u = e.u;\n        }\n\n        flow += aug;\n        cost += aug * d[N];\n        u = N;\n        while(u != 1){\n            if(p[u] < 0){\n                redges[-p[u]].r -= aug;\n                edges[-p[u]].r += aug;\n            } else {\n                redges[p[u]].r += aug;\n                edges[p[u]].r -= aug;\n            }\n            u = (p[u] < 0 ? redges[-p[u]].u : edges[p[u]].u);\n        }\n    }\n    return (flow < K ? -1 : cost);\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n    for(int i = 1, u, v, r, c; i <= M; i++){\n        scanf("%d %d %d %d", &u, &v, &r, &c);\n        G[u].push_back(i);\n        G[v].push_back(-i);\n        edges[i] = {u, v, r, c};\n        redges[i] = {v, u, 0, -c};\n    }\n    printf("%lld\\n", minimum_cost_flow());\n}',
  "2129":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 402, maxM = 40401;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\n\nint N, p[maxN];\nll d[maxN], cap[maxN][maxN], cost[maxN][maxN];\nbool inq[maxN], vis[maxM];\nvector<int> path, G[maxN];\n\nstruct Edge {\n    int u, v;\n    ll r, c;\n} edges[maxM], redges[maxM];\n\nvoid bellman_ford(int start = 0){\n    fill(inq, inq+maxN, false);\n    fill(d, d+maxN, INF);\n    fill(p, p+maxN, 0);\n\n    queue<int> Q;\n    Q.push(start);\n    d[start] = 0;\n    inq[start] = true;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        inq[u] = false;\n\n        for(int i : G[u]){\n            Edge e = (i < 0 ? redges[-i] : edges[i]);\n            if(e.r > 0 && d[e.v] > d[u] + e.c){\n                d[e.v] = d[u] + e.c;\n                p[e.v] = i;\n                if(!inq[e.v]){\n                    inq[e.v] = true;\n                    Q.push(e.v);\n                }\n            }\n        }\n    }\n}\n\nll minimum_cost_flow(){\n    ll flow = 0, cost = 0;\n    while(flow < N){\n        bellman_ford();\n        if(d[2*N+1] == INF) break;\n\n        ll aug = N-flow;\n        int u = 2*N+1;\n        while(u != 0){\n            Edge e = (p[u] < 0 ? redges[-p[u]] : edges[p[u]]);\n            aug = min(aug, e.r);\n            u = e.u;\n        }\n\n        flow += aug;\n        cost += aug * d[2*N+1];\n        u = 2*N+1;\n        while(u != 0){\n            if(p[u] < 0){\n                redges[-p[u]].r -= aug;\n                edges[-p[u]].r += aug;\n            } else {\n                redges[p[u]].r += aug;\n                edges[p[u]].r -= aug;\n            }\n            u = (p[u] < 0 ? redges[-p[u]].u : edges[p[u]].u);\n        }\n    }\n    return (flow < N ? -1 : cost);\n}\n\nvoid dfs(int u = 0){\n    if(u == 2*N+1)  return;\n    if(u != 0)      path.push_back(u);\n    for(int i : G[u]){\n        if(i > 0 && edges[i].r == 0 && !vis[i]){\n            vis[i] = true;\n            dfs(edges[i].v);\n            return;\n        }\n    }\n}\n\nint main(){\n    scanf("%d", &N);\n    int edgeID = 1;\n    for(int u = 1; u <= N; u++){\n        for(int v = N+1, c; v <= 2*N; v++){\n            scanf("%d", &c);\n            G[u].push_back(edgeID);\n            G[v].push_back(-edgeID);\n            edges[edgeID] = {u, v, 1, c};\n            redges[edgeID] = {v, u, 0, -c};\n            edgeID++;\n        }\n    }\n    for(int v = 1; v <= N; v++){\n        G[0].push_back(edgeID);\n        G[v].push_back(-edgeID);\n        edges[edgeID] = {0, v, 1, 0};\n        redges[edgeID] = {v, 0, 0, 0};\n        edgeID++;\n    }\n    for(int u = N+1; u <= 2*N; u++){\n        G[u].push_back(edgeID);\n        G[2*N+1].push_back(-edgeID);\n        edges[edgeID] = {u, 2*N+1, 1, 0};\n        redges[edgeID] = {2*N+1, u, 0, 0};\n        edgeID++;\n    }\n\n    printf("%lld\\n", minimum_cost_flow());\n    for(int i = 0; i < N; i++){\n        path.clear();\n        dfs();\n        printf("%d %d\\n", path[0], path[1]-N);\n    }\n}',
  "2130":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 501, maxM = 1001;\nconst int INF = 0x3f3f3f3f;\n\nint N, M, K, p[maxN], d[maxN];\nbool inq[maxN], vis[maxM];\nvector<int> path, G[maxN];\n\nstruct Edge {\n    int u, v, r, c;\n} edges[maxM], redges[maxM];\n\nvoid bellman_ford(){\n    fill(inq+1, inq+N+1, false);\n    fill(d+1, d+N+1, INF);\n    fill(p+1, p+N+1, 0);\n\n    queue<int> Q;\n    Q.push(1);\n    d[1] = 0;\n    inq[1] = true;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        inq[u] = false;\n\n        for(int i : G[u]){\n            Edge e = (i < 0 ? redges[-i] : edges[i]);\n            if(e.r > 0 && d[e.v] > d[u] + e.c){\n                d[e.v] = d[u] + e.c;\n                p[e.v] = i;\n                if(!inq[e.v]){\n                    inq[e.v] = true;\n                    Q.push(e.v);\n                }\n            }\n        }\n    }\n}\n\nint minimum_cost_flow(){\n    int flow = 0, cost = 0;\n    while(flow < K){\n        bellman_ford();\n        if(d[N] == INF) break;\n\n        int aug = K-flow;\n        int u = N;\n        while(u != 1){\n            Edge e = (p[u] < 0 ? redges[-p[u]] : edges[p[u]]);\n            aug = min(aug, e.r);\n            u = e.u;\n        }\n\n        flow += aug;\n        cost += aug * d[N];\n        u = N;\n        while(u != 1){\n            if(p[u] < 0){\n                redges[-p[u]].r -= aug;\n                edges[-p[u]].r += aug;\n            } else {\n                redges[p[u]].r += aug;\n                edges[p[u]].r -= aug;\n            }\n            u = (p[u] < 0 ? redges[-p[u]].u : edges[p[u]].u);\n        }\n    }\n    return (flow < K ? -1 : cost);\n}\n\nvoid dfs(int u = 1){\n    path.push_back(u);\n    if(u == N)  return;\n    for(int i : G[u]){\n        if(i > 0 && edges[i].r == 0 && !vis[i]){\n            vis[i] = true;\n            dfs(edges[i].v);\n            return;\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n    for(int i = 1, u, v; i <= M; i++){\n        scanf("%d %d", &u, &v);\n        G[u].push_back(i);\n        G[v].push_back(-i);\n        edges[i] = {u, v, 1, 1};\n        redges[i] = {v, u, 0, -1};\n    }\n\n    int minCoins = minimum_cost_flow();\n    if(minCoins == -1){\n        printf("-1\\n");\n        return 0;\n    }\n\n    printf("%d\\n", minCoins);\n    for(int i = 0; i < K; i++){\n        path.clear();\n        dfs();\n\n        int sz = (int) path.size();\n        printf("%d\\n", sz);\n        for(int j = 0; j < sz; j++)\n            printf("%d%c", path[j], (" \\n")[j==sz-1]);\n    }\n}',
  "2131":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 105, maxM = 2605;\nconst int INF = 0x3f3f3f3f;\n\nint N, K, rowtot, coltot, edgecnt, p[maxN], d[maxN];\nbool inq[maxN], vis[maxM];\nvector<int> path, G[maxN];\n\nstruct Edge {\n    int u, v, r, c;\n} edges[maxM], redges[maxM];\n\nvoid read_input(){\n    scanf("%d", &N);\n    for(int v = 1, cap; v <= N; v++){\n        scanf("%d", &cap);\n        rowtot += cap;\n        edgecnt++;\n        G[0].push_back(edgecnt);\n        G[v].push_back(-edgecnt);\n        edges[edgecnt] = {0, v, cap, 0};\n        redges[edgecnt] = {v, 0, 0, 0};\n    }\n    for(int u = N+1, cap; u <= 2*N; u++){\n        scanf("%d", &cap);\n        coltot += cap;\n        edgecnt++;\n        G[u].push_back(edgecnt);\n        G[2*N+1].push_back(-edgecnt);\n        edges[edgecnt] = {u, 2*N+1, cap, 0};\n        redges[edgecnt] = {2*N+1, u, 0, 0};\n    }\n    for(int u = 1; u <= N; u++){\n        for(int v = N+1, cost; v <= 2*N; v++){\n            scanf("%d", &cost);\n            edgecnt++;\n            G[u].push_back(edgecnt);\n            G[v].push_back(-edgecnt);\n            edges[edgecnt] = {u, v, 1, -cost};\n            redges[edgecnt] = {v, u, 0, cost};\n        }\n    }\n}\n\nvoid bellman_ford(int s = 0){\n    fill(inq, inq+2*N+2, false);\n    fill(d, d+2*N+2, INF);\n    fill(p, p+2*N+2, 0);\n\n    queue<int> Q;\n    Q.push(s);\n    d[s] = 0;\n    inq[s] = true;\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        inq[u] = false;\n\n        for(int i : G[u]){\n            Edge e = (i < 0 ? redges[-i] : edges[i]);\n            if(e.r > 0 && d[e.v] > d[u] + e.c){\n                d[e.v] = d[u] + e.c;\n                p[e.v] = i;\n                if(!inq[e.v]){\n                    inq[e.v] = true;\n                    Q.push(e.v);\n                }\n            }\n        }\n    }\n}\n\nint minimum_cost_flow(int s = 0, int t = 2*N+1){\n    int flow = 0, cost = 0;\n    while(flow < K){\n        bellman_ford(s);\n        if(d[t] == INF) break;\n\n        int aug = K-flow;\n        int u = t;\n        while(u != s){\n            Edge e = (p[u] < 0 ? redges[-p[u]] : edges[p[u]]);\n            aug = min(aug, e.r);\n            u = e.u;\n        }\n\n        flow += aug;\n        cost += aug * d[t];\n        u = t;\n        while(u != s){\n            if(p[u] < 0){\n                redges[-p[u]].r -= aug;\n                edges[-p[u]].r += aug;\n            } else {\n                redges[p[u]].r += aug;\n                edges[p[u]].r -= aug;\n            }\n            u = (p[u] < 0 ? redges[-p[u]].u : edges[p[u]].u);\n        }\n    }\n    return (flow < K ? INF : cost);\n}\n\nint main(){\n    read_input();\n\n    K = rowtot;\n    int max_reward = -minimum_cost_flow();\n    if(rowtot != coltot || max_reward == -INF){\n        printf("-1\\n");\n        return 0;\n    }\n\n    printf("%d\\n", max_reward);\n    for(Edge e : edges){\n        if(e.u != 0 && e.v != 2*N+1){\n            printf("%c", (e.r == 0 ? \'X\' : \'.\'));\n            if(e.v == 2*N)  printf("\\n");\n        }\n    }\n}',
  "2132":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N, x;\npriority_queue<int> Q;\n\nint main(){\n    scanf("%d", &N);\n    ll ans = 0;\n    for(int i = 0; i < N; i++){\n        scanf("%d", &x);\n        Q.push(x);\n        ans += Q.top() - x;\n        Q.pop();\n        Q.push(x);\n    }\n    printf("%lld\\n", ans);\n}',
  "2133":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef array<int,3> triple;\nconst int maxN = 1e5+1;\nconst int SIZE = 3e5+1;\nconst int INF = 0x3f3f3f3f;\n\nint N, M, K, root, components, del_time[SIZE];\nbool used[SIZE];\npii edges[SIZE];\ntriple ops[maxN];\nmap<pii,deque<int>> edge_id_map;\n\nstruct Node {\n    bool rev = false;\n    Node *c[2] = {nullptr, nullptr}, *p = nullptr;\n    int mn, id;\n\n    Node(int i){\n        mn = id = i;\n    }\n\n    void push(){\n        if(rev){\n            swap(c[0], c[1]);\n            if(c[0])    c[0]->rev ^= true;\n            if(c[1])    c[1]->rev ^= true;\n            rev = false;\n        }\n    }\n\n    void pull(){\n        mn = id;\n        for(int i = 0; i < 2; i++)\n            if(c[i] && del_time[c[i]->mn] < del_time[mn])\n                mn = c[i]->mn;\n    }\n} *LCT[SIZE];\n\nbool notRoot(Node *t){\n    return t->p && (t->p->c[0] == t || t->p->c[1] == t);\n}\n\nvoid rotate(Node *t){\n    Node *p = t->p;\n    bool b = (p->c[0] == t);\n    if((t->p = p->p) && notRoot(p)) t->p->c[(t->p->c[1] == p)] = t;\n    if((p->c[!b]=t->c[b]))          p->c[!b]->p = p;\n    t->c[b] = p;\n    p->p = t;\n    p->pull();\n}\n\n\nvoid splay(Node *t){\n    while(notRoot(t)){\n        Node *p = t->p;\n        p->push();\n        t->push();\n        rotate(t);\n    }\n    t->push();\n    t->pull();\n}\n\nNode* access(Node *t){\n    Node *last = nullptr;\n    for(Node *u = t; u; u = u->p){\n        splay(u);\n        u->c[1] = last;\n        last = u;\n    }\n    splay(t);\n    return last;\n}\n\nvoid evert(Node *t){\n    access(t);\n    t->rev = true;\n}\n\nvoid link(Node *u, Node *v){\n    evert(u);\n    u->p = v;\n}\n\nvoid cut(Node *u, Node *v){\n    evert(u);\n    access(v);\n    if(v->c[0]) v->c[0]->p = 0;\n    v->c[0] = 0;\n    v->pull();\n}\n\nNode* path(Node *u, Node *v){\n    evert(u);\n    access(v);\n    return v;\n}\n\nbool connected(Node *u, Node *v){\n    path(u, v);\n    while(v->c[0])\n        v = v->c[0];\n    return u == v;\n}\n\nvoid create_edge(int u, int v){\n    int id = edge_id_map[{u, v}].front();\n    if(!connected(LCT[u], LCT[v])){\n        components--;\n        link(LCT[id], LCT[u]);\n        link(LCT[id], LCT[v]);\n        used[id] = true;\n    } else {\n        int mn = path(LCT[u], LCT[v])->mn;\n        if(del_time[mn] < del_time[id]){\n            int cu = edges[mn].first;\n            int cv = edges[mn].second;\n            cut(LCT[mn], LCT[cu]);\n            cut(LCT[mn], LCT[cv]);\n            used[mn] = false;\n            link(LCT[id], LCT[u]);\n            link(LCT[id], LCT[v]);\n            used[id] = true;\n        }\n    }\n}\n\nvoid destroy_edge(int u, int v){\n    int id = edge_id_map[{u, v}].front();\n    edge_id_map[{u, v}].pop_front();\n    if(!used[id])   return;\n    cut(LCT[id], LCT[u]);\n    cut(LCT[id], LCT[v]);\n    used[id] = false;\n    components++;\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &K);\n\n    root = 1;\n    for(int i = 1; i <= N; i++){\n        LCT[i] = new Node(i);\n        del_time[i] = INF;\n    }\n\n    for(int i = 1, a, b; i <= M; i++){\n        scanf("%d %d", &a, &b);\n        if(a > b)   swap(a, b);\n        edges[N+i] = {a, b};\n        del_time[N+i] = INF;\n        LCT[N+i] = new Node(N+i);\n        edge_id_map[{a, b}].push_back(N+i);\n    }\n\n    for(int i = 1, t, a, b; i <= K; i++){\n        scanf("%d %d %d", &t, &a, &b);\n        if(a > b)   swap(a, b);\n        ops[i] = {t, a, b};\n        edges[N+M+i] = {a, b};\n\n        if(t == 2){\n            int id = edge_id_map[{a, b}].back();\n            del_time[id] = i;\n        } else {\n            del_time[N+M+i] = INF;\n            LCT[N+M+i] = new Node(N+M+i);\n            edge_id_map[{a, b}].push_back(N+M+i);\n        }\n    }\n\n    components = N;\n    for(int i = N+1; i <= N+M; i++){\n        int u = edges[i].first;\n        int v = edges[i].second;\n        create_edge(u, v);\n    }\n    printf("%d ", components);\n\n    for(int i = 1; i <= K; i++){\n        int t = ops[i][0];\n        int u = ops[i][1];\n        int v = ops[i][2];\n        if(t == 1)  create_edge(u, v);\n        else        destroy_edge(u, v);\n        printf("%d%c", components, (" \\n")[i==K]);\n    }\n}',
  "2134":
    '#include <bits/stdc++.h>\n\n/**\n * Link Cut Tree\n */\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, Q, k, x, y, root, idcounter;\n\nstruct Lazy {\n    int a = 1, b = 0;\n    bool empty(){\n        return (a == 1 && b == 0);\n    }\n};\n\nstruct Node {\n    Lazy tag;\n    bool rev = false;\n    Node *c[2] = {nullptr, nullptr}, *p = nullptr;\n    int sz, val, sum, mn, mx, id = ++idcounter;\n\n    Node(int v){\n        sz = 1;\n        val = sum = mn = mx = v;\n    }\n\n    void apply(Lazy other){\n        mn = mn*other.a + other.b;\n        mx = mx*other.a + other.b;\n        val = val*other.a + other.b;\n        sum = sum*other.a + sz*other.b;\n        tag = {tag.a*other.a, tag.b*other.a+other.b};\n    }\n\n    void push(){\n        if(rev){\n            swap(c[0], c[1]);\n            if(c[0])    c[0]->rev ^= true;\n            if(c[1])    c[1]->rev ^= true;\n            rev = false;\n        }\n        if(!tag.empty()){\n            if(c[0])    c[0]->apply(tag);\n            if(c[1])    c[1]->apply(tag);\n            tag = Lazy();\n        }\n    }\n\n    void pull(){\n        sum = mn = mx = val;\n        sz = 1;\n        for(int i = 0; i < 2; i++){\n            if(c[i]){\n                mn = min(mn, c[i]->mn);\n                mx = max(mx, c[i]->mx);\n                sum += c[i]->sum;\n                sz += c[i]->sz;\n            }\n        }\n    }\n} *LCT[maxN];\n\nbool notRoot(Node *t){\n    return t->p && (t->p->c[0] == t || t->p->c[1] == t);\n}\n\nvoid rotate(Node *t){\n    Node *p = t->p;\n    bool b = (p->c[0] == t);\n    if((t->p = p->p) && notRoot(p)) t->p->c[(t->p->c[1] == p)] = t;\n    if((p->c[!b]=t->c[b]))          p->c[!b]->p = p;\n    t->c[b] = p;\n    p->p = t;\n    p->pull();\n}\n\n\nvoid splay(Node *t){\n    while(notRoot(t)){\n        Node *p = t->p;\n        p->push();\n        t->push();\n        rotate(t);\n    }\n    t->push();\n    t->pull();\n}\n\nNode* access(Node *t){\n    Node *last = nullptr;\n    for(Node *u = t; u; u = u->p){\n        splay(u);\n        u->c[1] = last;\n        last = u;\n    }\n    splay(t);\n    return last;\n}\n\nvoid evert(Node *t){\n    access(t);\n    t->rev = true;\n}\n\nvoid link(Node *u, Node *v){\n    evert(u);\n    u->p = v;\n}\n\nvoid cut(Node *u, Node *v){\n    evert(u);\n    access(v);\n    if(v->c[0]) v->c[0]->p = 0;\n    v->c[0] = 0;\n    v->pull();\n}\n\nNode* path(Node *u, Node *v){\n    evert(u);\n    access(v);\n    return v;\n}\n\nNode* LCA(Node *u, Node *v){\n    evert(LCT[root]);\n    access(u);\n    return access(v);\n}\n\nbool connected(Node *u, Node *v){\n    path(u, v);\n    while(v->c[0])\n        v = v->c[0];\n    return u == v;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &x);\n        LCT[i] = new Node(x);\n    }\n    for(int i = 0; i < N-1; i++){\n        scanf("%d %d", &x, &y);\n        link(LCT[x], LCT[y]);\n    }\n\n    root = 1;\n    for(int i = 0; i < Q; i++){\n        scanf("%d", &k);\n        if(k == 1){\n            scanf("%d %d", &x, &y);\n            Node *p = path(LCT[x], LCT[x]);\n            p->apply({0, y});\n        } else if(k == 2){\n            scanf("%d %d", &x, &y);\n            Node *p = path(LCT[x], LCT[y]);\n            printf("%d ", p->mx);\n        }\n    }\n}\n',
  "2136":
    "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e4;\n\nint N, ans, b[maxN];\n\nint scanBinary(){\n    char c;\n    int res = 0;\n    while((c = getchar()) != '\\n'){\n        res <<= 1;\n        res += (c-'0')&1;\n    }\n    return res;\n}\n\nint main(){\n    scanf(\"%d %d \", &N, &ans);\n    for(int i = 0; i < N; i++)\n        b[i] = scanBinary();\n\n    for(int i = 0; i < N; i++)\n        for(int j = i+1; j < N; j++)\n            ans = min(ans, __builtin_popcount(b[i]^b[j]));\n\n    printf(\"%d\\n\", ans);\n}\n",
  "2137":
    '#include <bits/stdc++.h>\n#pragma GCC target("popcnt")\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 3005;\n\nint N;\nll ans;\nbitset<maxN> B[maxN];\n\nint f(int X){\n    return X*(X-1);\n}\n\nint main(){\n    cin.sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> N;\n    for(int i = 0; i < N; i++)\n        cin >> B[i];\n\n    for(int i = 0; i < N; i++)\n        for(int j = i+1; j < N; j++)\n            ans += f((B[i]&B[j]).count());\n\n    cout << (ans>>1);\n}\n',
  "2138":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 5e4+1;\n\nint N, M, a, b, in[maxN];\nbitset<maxN> ans[maxN];\nvector<int> G[maxN];\nqueue<int> Q;\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[b].push_back(a);\n        in[a]++;\n    }\n\n    for(int i = 1; i <= N; i++){\n        if(in[i] == 0){\n            ans[i].set(i);\n            Q.push(i);\n        }\n    }\n\n    while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        for(int v : G[u]){\n            ans[v] |= ans[u];\n            in[v]--;\n            if(in[v] == 0){\n                ans[v].set(v);\n                Q.push(v);\n            }\n        }\n    }\n\n    for(int i = 1; i <= N; i++)\n        printf("%d%c", (int) ans[i].count(), (" \\n")[i==N]);\n}\n',
  "2143":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 5e4+5;\n\nbool vis[maxN];\nint N, M, Q, ds[maxN];\nvector<int> order, component;\nvector<int> G[maxN], H[maxN], SCC[maxN];\nbitset<maxN> reachable[maxN];\n\nint find(int u){\n    if(ds[u] < 0)   return u;\n    ds[u] = find(ds[u]);\n    return ds[u];\n}\n\nbool merge(int u, int v){\n    u = find(u); v = find(v);\n    if(u == v)  return false;\n    if(ds[u] < ds[v]){\n        ds[u] += ds[v];\n        ds[v] = u;\n    } else {\n        ds[v] += ds[u];\n        ds[u] = v;\n    }\n    return true;\n}\n\nvoid dfs1(int u){\n    vis[u] = true;\n    for(int v : G[u])\n        if(!vis[v])\n            dfs1(v);\n    order.push_back(u);\n}\n\nvoid dfs2(int u){\n    vis[u] = true;\n    component.push_back(u);\n    for(int v : H[u])\n        if(!vis[v])\n            dfs2(v);\n}\n\nvoid dfs3(int u){\n    vis[u] = true;\n    for(int v : SCC[u]){\n        if(!vis[v])\n            dfs3(v);\n        reachable[u] |= reachable[v];\n    }\n}\n\nint main(){\n    scanf("%d %d %d", &N, &M, &Q);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back(b);\n        H[b].push_back(a);\n    }\n\n    fill(vis+1, vis+N+1, false);\n    for(int i = 1; i <= N; i++)\n        if(!vis[i])\n            dfs1(i);\n\n    fill(ds+1, ds+N+1, -1);\n    fill(vis+1, vis+N+1, false);\n    for(int i = 1; i <= N; i++){\n        int u = order[N-i];\n        if(!vis[u]){\n            dfs2(u);\n            for(int j = 0; j+1 < (int) component.size(); j++)\n                merge(component[j], component[j+1]);\n            component.clear();\n        }\n    }\n\n    for(int i = 1; i <= N; i++){\n        int rep = find(i);\n        reachable[rep].set(i);\n        for(int v : G[i])\n            SCC[rep].push_back(find(v));\n    }\n\n    fill(vis+1, vis+N+1, false);\n    for(int i = 1; i <= N; i++)\n        if(!vis[i])\n            dfs3(i);\n\n    for(int i = 0, a, b; i < Q; i++){\n        scanf("%d %d", &a, &b);\n        a = find(a); b = find(b);\n        printf(reachable[a][b] ? "YES\\n" : "NO\\n");\n    }\n}\n',
  "2162":
    '#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nint N, idx;\ntree<int, null_type, less<int>, rb_tree_tag,\ntree_order_statistics_node_update> T;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++)\n        T.insert(i);\n\n    idx = 1;\n    while(T.size()){\n        idx %= T.size();\n        int x = *T.find_by_order(idx);\n        T.erase(x);\n        printf("%d%c", x, (" \\n")[T.size() == 0]);\n        idx++;\n    }\n}\n',
  "2163":
    '#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nint N, K, idx;\ntree<int, null_type, less<int>, rb_tree_tag,\ntree_order_statistics_node_update> T;\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 1; i <= N; i++)\n        T.insert(i);\n\n    idx = K;\n    while(T.size()){\n        idx %= T.size();\n        int x = *T.find_by_order(idx);\n        T.erase(x);\n        printf("%d%c", x, (" \\n")[T.size() == 0]);\n        idx += K;\n    }\n}\n',
  "2164":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint Q;\nmap<pii,int> f;\n\nint solve(int N, int K){\n    if(f[{N, K}])   return f[{N, K}];\n\n    if(N == 1)      return f[{N, K}] = 1;\n    if(2*K <= N)    return f[{N, K}] = 2*K;\n\n    int newN = (N/2)+(N&1);\n    int newK = K-N/2;\n\n    if(N&1){\n        int ans = solve(newN, newK);\n        return f[{N, K}] = ((2*ans-3)+(N+1)) % (N+1);\n    } else {\n        return f[{N, K}] = 2*solve(newN, newK)-1;\n    }\n}\n\nint main(){\n    scanf("%d", &Q);\n    for(int q = 0, N, K; q < Q; q++){\n        scanf("%d %d", &N, &K);\n        printf("%d\\n", solve(N, K));\n    }\n}',
  "2165":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\n\nvoid move(int from, int to, int depth){\n    if(depth == 1){\n        printf("%d %d\\n", from, to);\n        return;\n    }\n\n    int other = 6 - from - to;\n    move(from, other, depth-1);\n    printf("%d %d\\n", from, to);\n    move(other, to, depth-1);\n}\n\nint main(){\n    scanf("%d", &N);\n    printf("%d\\n", (1<<N)-1);\n    move(1, 3, N);\n}\n',
  "2166":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst int maxN = 2e5+1;\nconst int SIZE = 4*maxN;\n\nint N, Q, lo[SIZE], hi[SIZE], mp[maxN];\nll sum[SIZE], pre[SIZE];\n\nvoid pull(int i){\n    pre[i] = max(pre[2*i], sum[2*i]+pre[2*i+1]);\n    sum[i] = sum[2*i] + sum[2*i+1];\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        scanf("%lld", &sum[i]);\n        pre[i] = max(0LL, sum[i]);\n        mp[l] = i;\n        return;\n    }\n    int m = (l+r)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid update(int idx, int val){\n    int i = mp[idx];\n    sum[i] = val;\n    pre[i] = max(0LL, sum[i]);\n\n    i >>= 1;\n    while(i){\n        pull(i);\n        i >>= 1;\n    }\n}\n\npll query(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])      return {0, 0};\n    if(l <= lo[i] && hi[i] <= r)    return {pre[i], sum[i]};\n\n    pll left = query(2*i, l, r);\n    pll right = query(2*i+1, l, r);\n    return {max(left.first, left.second+right.first), left.second+right.second};\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    init(1, 1, N);\n    for(int q = 0, t, a, b; q < Q; q++){\n        scanf("%d %d %d", &t, &a, &b);\n        if(t == 1)\n            update(a, b);\n        else if(t == 2)\n            printf("%lld\\n", query(1, a, b).first);\n    }\n}\n',
  "2168":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef array<int,3> triple;\nconst int maxN = 2e5+1;\nconst int SIZE = 2*maxN;\n\nint N, ans[2][maxN], ds[SIZE];\ntriple intervals[maxN];\nset<int> unique_vals;\nmap<int,int> mp;\n\nvoid update(int idx, int val){\n    for(int i = idx; i < SIZE; i += -i&i)   ds[i] += val;\n}\n\nint query(int idx){\n    int cnt = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        cnt += ds[i];\n    return cnt;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0, x, y; i < N; i++){\n        scanf("%d %d", &x, &y);\n        intervals[i] = {x, y, i};\n        unique_vals.insert(x);\n        unique_vals.insert(y);\n    }\n    sort(intervals, intervals+N, [](triple A, triple B){\n        return (A[0] == B[0] ? A[1] > B[1] : A[0] < B[0]);\n    });\n\n    int val_id = 1;\n    for(int x : unique_vals)\n        mp[x] = val_id++;\n\n    for(int i = N-1; i >= 0; i--){\n        int y = mp[intervals[i][1]];\n        int id = intervals[i][2];\n\n        ans[0][id] = query(y);\n        update(y, 1);\n    }\n\n    fill(ds, ds+SIZE, 0);\n    for(int i = 0; i < N; i++){\n        int y = mp[intervals[i][1]];\n        int id = intervals[i][2];\n\n        ans[1][id] = i-query(y-1);\n        update(y, 1);\n    }\n\n    for(int i = 0; i < 2; i++)\n        for(int j = 0; j < N; j++)\n            printf("%d%c", (ans[i][j] ? 1 : 0), (" \\n")[j==N-1]);\n}',
  "2169":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef array<int,3> triple;\nconst int maxN = 2e5+1;\nconst int SIZE = 2*maxN;\n\nint N, ans[2][maxN], ds[SIZE];\ntriple intervals[maxN];\nset<int> unique_vals;\nmap<int,int> mp;\n\nvoid update(int idx, int val){\n    for(int i = idx; i < SIZE; i += -i&i)   ds[i] += val;\n}\n\nint query(int idx){\n    int cnt = 0;\n    for(int i = idx; i > 0; i -= -i&i)\n        cnt += ds[i];\n    return cnt;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0, x, y; i < N; i++){\n        scanf("%d %d", &x, &y);\n        intervals[i] = {x, y, i};\n        unique_vals.insert(x);\n        unique_vals.insert(y);\n    }\n    sort(intervals, intervals+N, [](triple A, triple B){\n        return (A[0] == B[0] ? A[1] > B[1] : A[0] < B[0]);\n    });\n\n    int val_id = 1;\n    for(int x : unique_vals)\n        mp[x] = val_id++;\n\n    for(int i = N-1; i >= 0; i--){\n        int y = mp[intervals[i][1]];\n        int id = intervals[i][2];\n\n        ans[0][id] = query(y);\n        update(y, 1);\n    }\n\n    fill(ds, ds+SIZE, 0);\n    for(int i = 0; i < N; i++){\n        int y = mp[intervals[i][1]];\n        int id = intervals[i][2];\n\n        ans[1][id] = i-query(y-1);\n        update(y, 1);\n    }\n\n    for(int i = 0; i < 2; i++)\n        for(int j = 0; j < N; j++)\n            printf("%d%c", ans[i][j], (" \\n")[j==N-1]);\n}',
  "2176":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 501;\nconst ll MOD = 1e9+7;\n\nint N, K;\nll fac[maxN], inv[maxN];\nll T[maxN], B[2*maxN], W[2*maxN];\n\nll fastpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n        if(b&1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll choose(int n, int k){\n    if(k < 0 || n < k)  return 0;\n    return fac[n] * inv[k] % MOD * inv[n-k] % MOD;\n}\n\nll stirling2(int n, int k){\n    ll sum = 0;\n    for(int i = 0; i <= k; i++){\n        ll a = (i&1 ? -1 : 1);\n        ll b = choose(k, i);\n        ll c = fastpow(k-i, n);\n        ll term = a * b % MOD * c % MOD;\n        sum = (sum + term + MOD) % MOD;\n    }\n    return sum * inv[k] % MOD;\n}\n\nvoid compute_T(int n){\n    for(int k = 0; k <= n; k++)\n        T[k] = stirling2(n+1, n+1-k);\n}\n\nvoid init_choose(){\n    fac[0] = inv[0] = 1;\n    for(int i = 1; i < maxN; i++){\n        fac[i] = (fac[i-1] * i) % MOD;\n        inv[i] = fastpow(fac[i], MOD-2);\n    }\n}\n\nll calculate(int n, int k){\n    if(n == 1)      return 1;\n    if(k >= 2*n)    return 0;\n    memset(B, 0, sizeof(B));\n    memset(W, 0, sizeof(W));\n\n    int m = n/2, odd = n&1;\n    for(int k = 0; k <= m+odd; k++){\n        compute_T(2*m-1-k+odd);\n        ll a = choose(m+odd, k);\n        ll b = choose(m, k);\n        for(int i = 0; i+k < n; i++){\n            B[i+k] += (a * T[i]) % MOD;\n            B[i+k] %= MOD;\n            W[i+k] += (b * T[i]) % MOD;\n            W[i+k] %= MOD;\n        }\n    }\n\n    ll sum = 0;\n    for(int b = 0; b <= min(N-1, K); b++){\n        int w = K-b;\n        sum += (B[b] * W[w]) % MOD;\n        sum %= MOD;\n    }\n    return sum;\n}\n\nint main(){\n    init_choose();\n    scanf("%d %d", &N, &K);\n    printf("%lld\\n", calculate(N, K));\n}',
  "2177":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 1e5+1;\nconst int maxM = 2e5+1;\n\nint N, M, timer, tin[maxN], low[maxN];\nbool bridge_exists, vis[maxN], used[maxM];\nvector<pii> G[maxN];\npii edges[maxM];\n\nvoid dfs(int u = 1, int p = 0){\n    vis[u] = true;\n    tin[u] = low[u] = ++timer;\n    for(pii P : G[u]){\n        int v = P.first;\n        int id = P.second;\n        if(used[id])    continue;\n\n        used[id] = true;\n        edges[id] = {u, v};\n\n        if(vis[v]){\n            low[u] = min(low[u], tin[v]);\n        } else {\n            dfs(v, u);\n            low[u] = min(low[u], low[v]);\n            if(low[v] > tin[u])\n                bridge_exists = true;\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back({b, i});\n        G[b].push_back({a, i});\n    }\n\n    dfs();\n    if(timer == N && !bridge_exists){\n        for(int i  = 0; i < M; i++)\n            printf("%d %d\\n", edges[i].first, edges[i].second);\n    } else printf("IMPOSSIBLE\\n");\n}\n',
  "2179":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 1e5+5, maxM = 2e5+5;\n\nint N, M, timer, in[maxN];\nbool even[maxN];\nvector<pii> G[maxN];\npii ans[maxM];\n\nvoid dfs(int u, int p = -1){\n    in[u] = ++timer;\n    for(pii e : G[u]){\n        int v = e.first, id = e.second;\n        if(v != p){\n            if(!in[v]){\n                dfs(v, u);\n                if(even[v]){\n                    ans[id] = {u, v};\n                    even[u] ^= true;\n                } else {\n                    ans[id] = {v, u};\n                    even[v] ^= true;\n                }\n            } else if(in[v] < in[u]){\n                even[u] ^= true;\n                ans[id] = {u, v};\n            }\n        }\n    }\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        G[a].push_back({b, i});\n        G[b].push_back({a, i});\n    }\n\n    fill(even+1, even+N+1, true);\n    for(int i = 1; i <= N; i++)\n        if(!in[i])\n            dfs(i);\n\n    bool good = true;\n    for(int i = 1; i <= N; i++)\n        good &= even[i];\n\n    if(good){\n        for(int i = 0; i < M; i++)\n            printf("%d %d\\n", ans[i].first, ans[i].second);\n    } else printf("IMPOSSIBLE\\n");\n}',
  "2180":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5;\n\nint N, a[2][maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int r = 0; r < 2; r++){\n        for(int i = 0; i < N; i++){\n            scanf("%d", &a[r][i]);\n            a[r][i]--;\n        }\n    }\n\n    ll ans = 0;\n    int top = 0, bot = 0;\n    for(int i = 0; i < N; i++){\n        top += a[0][i];\n        bot += a[1][i];\n\n        if((top < 0 && bot > 0) || (top > 0 && bot < 0)){\n            if(abs(top) < abs(bot)){\n                ans += abs(top);\n                bot += top;\n                top = 0;\n            } else {\n                ans += abs(bot);\n                top += bot;\n                bot = 0;\n            }\n        }\n\n        ans += abs(top + bot);\n    }\n    printf("%lld\\n", ans);\n}',
  "2181":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 11;\nconst int maxM = 1001;\nconst ll MOD = 1e9+7;\n\nint N, M;\nll dp[maxN][maxM][1<<maxN];\n\nint main(){\n    scanf("%d %d", &N, &M);\n    dp[N][0][0] = 1;\n    for(int i = 1; i <= M; i++){\n        for(int j = 0; j < (1<<N); j++)\n            dp[0][i][j<<1] = dp[N][i-1][j];\n\n        for(int j = 1; j <= N; j++){\n            int x = 1<<(j-1);\n            int y = 1<<j;\n            for(int mask = 0; mask < (1<<(N+1)); mask++){\n                dp[j-1][i][mask] %= MOD;\n                if((mask&x) && (mask&y))    continue;\n                if(mask&x)                  dp[j][i][mask^x] += dp[j-1][i][mask];\n                else if(mask&y)             dp[j][i][mask^y] += dp[j-1][i][mask];\n                else {\n                    dp[j][i][mask^x] += dp[j-1][i][mask];\n                    dp[j][i][mask^y] += dp[j-1][i][mask];\n                }\n            }\n        }\n    }\n    printf("%lld\\n", dp[N][M][0] % MOD);\n}\n',
  "2182":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5;\nconst ll MOD = 1e9+7;\n\nint N;\nll x[maxN], k[maxN];\nll tau, sigma, pi, mu;\n\nll fastpow(ll a, ll b){\n    ll res = 1;\n    while(b > 0){\n        if(b&1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        scanf("%lld %lld", &x[i], &k[i]);\n\n    tau = 1;\n    for(int i = 0; i < N; i++)\n        tau = (tau * (k[i]+1)) % MOD;\n\n    sigma = 1;\n    for(int i = 0; i < N; i++){\n        ll numerator = (fastpow(x[i], k[i]+1)-1+MOD) % MOD;\n        ll denominator = fastpow(x[i]-1, MOD-2);\n        ll geoSum = numerator * denominator % MOD;\n        sigma = (sigma * geoSum) % MOD;\n    }\n\n    pi = 1;\n    mu = 1;\n    for(int i = 0; i < N; i++){\n        ll p = fastpow(x[i], k[i]*(k[i]+1)/2);\n        mu = fastpow(mu, k[i]+1) * fastpow(p, pi) % MOD;\n        pi = (pi * (k[i]+1)) % (MOD-1);\n    }\n\n    printf("%lld %lld %lld\\n", tau, sigma, mu);\n}\n',
  "2183":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5;\n\nint N, x[maxN];\nll res;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        scanf("%d", &x[i]);\n    sort(x, x+N);\n\n    res = 1;\n    for(int i = 0; i < N && x[i] <= res; i++)\n        res += x[i];\n    printf("%lld\\n", res);\n}\n',
  "2184":
    "#include <bits/stdc++.h>\n\n/* Fast Input and Output Template */\nchar _i[1<<24], _o[1<<10], __[20], _, _c; int _i0, _o0, _n;\n#define readio()    { fread(_i, 1, 1<<24, stdin); }\n#define writeio()   { fwrite(_o, 1, _o0, stdout); }\n#define scanu(x)    { for (x = _i[_i0++] & 15; 47 < (_ = _i[_i0++]); x = x * 10 + (_ & 15)); }\n#define putnumu(x)  { _ = 0; do __[_++] = x % 10 | '0'; while (x /= 10); while (_--) _o[_o0++] = __[_]; }\n#define putnl()     { _o[_o0++] = '\\n'; }\n/* End of Template */\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+2;\nconst int logC = 32, logN = 18;\nconst int INF = 0x3f3f3f3f;\n\nint N, Q, mn[logC][logN][maxN];\nll pre[logC][maxN];\n\nint layer(int x){\n    return 31 - __builtin_clz(x);\n}\n\nll sum(int l, int a, int b){\n    return pre[l][b] - pre[l][a-1];\n}\n\nint minimum(int l, int a, int b){\n    a--; b--;\n    int len = b-a+1;\n    int k = (int) floor(log2(len));\n    return min(mn[l][k][a], mn[l][k][b-(1<<k)+1]);\n}\n\nvoid init(){\n    scanu(N); scanu(Q);\n    for(int i = 1, x; i <= N; i++){\n        scanu(x);\n        int l = layer(x);\n        pre[l][i] = x;\n        for(int j = 0; j < logC; j++)\n            mn[j][0][i-1] = (j == l ? x : INF);\n    }\n\n    for(int l = 0; l < logC; l++){\n        for(int j = 1; j <= N; j++)\n            pre[l][j] += pre[l][j-1];\n\n        for(int i = 1; i < logN; i++)\n            for(int j = 0; j <= N-(1<<i); j++)\n                mn[l][i][j] = min(mn[l][i-1][j], mn[l][i-1][j+(1<<(i-1))]);\n    }\n}\n\nll query(int a, int b){\n    ll ans = 1;\n    for(int l = 0; l < logC && ans >= (1<<l); l++)\n        if(minimum(l, a, b) <= ans)\n            ans += sum(l, a, b);\n    return ans;\n}\n\nint main(){\n    readio();\n    init();\n    for(int q = 0, a, b; q < Q; q++){\n        scanu(a); scanu(b);\n        ll ans = query(a, b);\n        putnumu(ans);\n        putnl();\n    }\n    writeio();\n}",
  "2185":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 0.001;\nconst int maxK = 20;\n\nint K;\nll N, cnt, a[maxK];\n\nint main(){\n    scanf("%lld %d", &N, &K);\n    for(int i = 0; i < K; i++)\n        scanf("%lld", &a[i]);\n\n    cnt = N;\n    double RHS = log(N) + EPS;\n    for(int mask = 0; mask < (1<<K); mask++){\n        bool odd = (__builtin_popcount(mask)&1);\n\n        ll prod = 1;\n        double LHS = 0.0;\n        for(int i = 0; i < K; i++){\n            if(mask&(1<<i)){\n                LHS += log(a[i]);\n                prod *= a[i];\n            }\n        }\n\n        if(LHS < RHS)\n            cnt += (odd ? 1 : -1) * (N/prod);\n    }\n\n    printf("%lld\\n", cnt);\n}',
  "2186":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+1;\n\nint N, M;\nchar S[maxN];\nbool exists[26];\nmap<char,int> ch;\nmap<vector<int>,ll> dp;\n\nbool containsEach(vector<int> V){\n    for(int i = 0; i < (int) V.size(); i++)\n        if(V[i] <= 0)\n            return false;\n    return true;\n}\n\nint main(){\n    scanf(" %s", S);\n    N = (int) strlen(S);\n    for(int i = 0; i < N; i++){\n        int c = (int) (S[i] - \'a\');\n        if(!exists[c]){\n            ch[S[i]] = M++;\n            exists[c] = true;\n        }\n    }\n\n    ll ans = 0;\n    vector<int> freq(M);\n    dp[freq]++;\n    for(int i = 0; i < N; i++){\n        int c = ch[S[i]];\n        freq[c]++;\n        if(containsEach(freq))\n            for(int j = 0; j < M; j++)\n                freq[j]--;\n        ans += dp[freq];\n        dp[freq]++;\n    }\n    printf("%lld\\n", ans);\n}',
  "2187":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e6+5;\nconst ll MOD = 1e9+7;\n\nchar S[maxN];\nint N, M, K;\nll tot, bad, fact[maxN], inv[maxN];\n\nll inverse(ll x){\n    ll res = 1;\n    ll b = MOD-2;\n    while(b){\n        if(b&1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll choose(int x, int y){\n    return (fact[x] * inv[y] % MOD) * inv[x-y] % MOD;\n}\n\nvoid init(){\n    fact[0] = inv[0] = 1;\n    for(int i = 1; i <= N; i++){\n        fact[i] = (fact[i-1] * i) % MOD;\n        inv[i] = (inv[i-1] * inverse(i)) % MOD;\n    }\n}\n\nint main(){\n    scanf("%d %s", &N, S);\n    M = (int) strlen(S);\n    init();\n\n    int open = 0, closed = 0;\n    for(int i = 0; i < M; i++){\n        if(S[i] == \'(\')         open++;\n        else if(S[i] == \')\')    closed++;\n\n        if(closed > open){\n            printf("0\\n");\n            return 0;\n        }\n    }\n\n    if(N&1 || open > N/2){\n        printf("0\\n");\n        return 0;\n    }\n\n    tot = choose(N-open-closed, N/2-open);\n    bad = choose(N-open-closed, N/2-open-1);\n    printf("%lld\\n", ((tot-bad)%MOD+MOD)%MOD);\n}',
  "2189":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct Point {\n    int x, y;\n    void read(){ scanf("%d %d", &x, &y); }\n    Point operator +(const Point& b) const { return Point{x+b.x, y+b.y}; }\n    Point operator -(const Point& b) const { return Point{x-b.x, y-b.y}; }\n    ll operator *(const Point& b) const { return (ll) x * b.y - (ll) y * b.x; }\n    void operator +=(const Point& b) { x += b.x; y += b.y; }\n    void operator -=(const Point &b) { x -= b.x; y -= b.y; }\n    void operator *=(const int k) { x *= k; y *= k; }\n\n    ll cross(const Point& b, const Point& c) const {\n        return (b - *this) * (c - *this);\n    }\n};\n\nint T;\nPoint P[3];\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        for(int i = 0; i < 3; i++)\n            P[i].read();\n\n        ll cross = P[0].cross(P[1], P[2]);\n        if(cross < 0)       printf("RIGHT\\n");\n        else if(cross > 0)  printf("LEFT\\n");\n        else                printf("TOUCH\\n");\n    }\n}\n',
  "2190":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct Point {\n    int x, y;\n    void read(){ scanf("%d %d", &x, &y); }\n    Point operator +(const Point& b) const { return Point{x+b.x, y+b.y}; }\n    Point operator -(const Point& b) const { return Point{x-b.x, y-b.y}; }\n    ll operator *(const Point& b) const { return (ll) x * b.y - (ll) y * b.x; }\n    void operator +=(const Point& b) { x += b.x; y += b.y; }\n    void operator -=(const Point &b) { x -= b.x; y -= b.y; }\n    void operator *=(const int k) { x *= k; y *= k; }\n\n    ll cross(const Point& b, const Point& c) const {\n        return (b - *this) * (c - *this);\n    }\n};\n\nint T;\nPoint P[4];\n\nvoid lineintersect(Point P1, Point P2, Point P3, Point P4){\n    // Parallel case\n    if((P2-P1) * (P4-P3) == 0){\n        // Collinear case, check bounding boxes\n        if(P1.cross(P2, P3) == 0){\n            for(int i = 0; i < 2; i++){\n                if(max(P1.x, P2.x) < min(P3.x, P4.x) || max(P1.y, P2.y) < min(P3.y, P4.y)){\n                    printf("NO\\n");\n                    return;\n                }\n                swap(P1, P3);\n                swap(P2, P4);\n            }\n            printf("YES\\n");\n            return;\n        }\n\n        // Non-collinear parallel lines never intersect\n        printf("NO\\n");\n        return;\n    }\n\n    // Non-parallel case\n    for(int i = 0; i < 2; i++){\n        ll s1 = P1.cross(P2, P3);\n        ll s2 = P1.cross(P2, P4);\n        if((s1 < 0 && s2 < 0) || (s1 > 0 && s2 > 0)){\n            printf("NO\\n");\n            return;\n        }\n        swap(P1, P3);\n        swap(P2, P4);\n    }\n\n    printf("YES\\n");\n}\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        for(int i = 0; i < 4; i++)\n            P[i].read();\n        lineintersect(P[0], P[1], P[2], P[3]);\n    }\n}\n',
  "2191":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1001;\n\nint N;\nll x[maxN], y[maxN], ans;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        scanf("%lld %lld", &x[i], &y[i]);\n    x[N] = x[0]; y[N] = y[0];\n\n    for(int i = 0; i < N; i++){\n        ans += x[i] * y[i+1];\n        ans -= y[i] * x[i+1];\n    }\n    printf("%lld\\n", abs(ans));\n}\n',
  "2192":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1001;\n\nstruct Point {\n    int x, y;\n    void read(){ scanf("%d %d", &x, &y); }\n    Point operator +(const Point& b) const { return Point{x+b.x, y+b.y}; }\n    Point operator -(const Point& b) const { return Point{x-b.x, y-b.y}; }\n    ll operator *(const Point& b) const { return (ll) x * b.y - (ll) y * b.x; }\n    void operator +=(const Point& b) { x += b.x; y += b.y; }\n    void operator -=(const Point& b) { x -= b.x; y -= b.y; }\n    void operator *=(const int k) { x *= k; y *= k; }\n\n    ll cross(const Point& b, const Point& c) const {\n        return (b - *this) * (c - *this);\n    }\n};\n\nint N, M;\nPoint P[maxN];\n\nbool pointlineintersect(Point P1, Point P2, Point P3){\n    if(P2.cross(P1, P3) != 0)   return false;\n    return (min(P2.x, P3.x) <= P1.x && P1.x <= max(P2.x, P3.x))\n        && (min(P2.y, P3.y) <= P1.y && P1.y <= max(P2.y, P3.y));\n}\n\nvoid pointinpolygon(){\n    int cnt = 0;\n    bool boundary = false;\n    for(int i = 1; i <= N; i++){\n        int j = (i == N ? 1 : i+1);\n        if(pointlineintersect(P[0], P[i], P[j]))\n            boundary = true;\n\n        if(P[i].x <= P[0].x && P[0].x < P[j].x && P[0].cross(P[i], P[j]) < 0)       cnt++;\n        else if(P[j].x <= P[0].x && P[0].x < P[i].x && P[0].cross(P[j], P[i]) < 0)  cnt++;\n    }\n\n    if(boundary)    printf("BOUNDARY\\n");\n    else if(cnt&1)  printf("INSIDE\\n");\n    else            printf("OUTSIDE\\n");\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 1; i <= N; i++)\n        P[i].read();\n    for(int i = 0; i < M; i++){\n        P[0].read();\n        pointinpolygon();\n    }\n}\n',
  "2193":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5+5;\n\nint N;\nll area, boundary, inside, x[maxN], y[maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        scanf("%lld %lld", &x[i], &y[i]);\n    x[N] = x[0]; y[N] = y[0];\n\n    for(int i = 0; i < N; i++){\n        area += x[i] * y[i+1];\n        area -= y[i] * x[i+1];\n    }\n    area = abs(area);\n\n    for(int i = 0; i < N; i++){\n        if(x[i+1] == x[i])      boundary += abs(y[i+1]-y[i]);\n        else if(y[i+1] == y[i]) boundary += abs(x[i+1]-x[i]);\n        else boundary += __gcd(abs(x[i+1]-x[i]), abs(y[i+1]-y[i]));\n    }\n\n    printf("%lld %lld\\n", (area+2-boundary)/2, boundary);\n}\n',
  "2194":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst int maxN = 2e5+1;\n\nint N;\nll best;\nbool isLeft[maxN];\npll P[maxN];\n\nll square(ll x){\n    return x*x;\n}\n\nll dist(pll A, pll B){\n    ll dx = A.first-B.first;\n    ll dy = A.second-B.second;\n    return square(dx) + square(dy);\n}\n\nvoid solve(vector<int> PX, vector<int> PY){\n    int len = PX.size();\n    if(len == 1)  return;\n\n    vector<int> LX, LY, RX, RY;\n    for(int i = 0; i < len; i++){\n        if(i < len/2){\n            LX.push_back(PX[i]);\n            isLeft[PX[i]] = true;\n        } else {\n            RX.push_back(PX[i]);\n            isLeft[PX[i]] = false;\n        }\n    }\n\n    for(int id : PY){\n        if(isLeft[id])  LY.push_back(id);\n        else            RY.push_back(id);\n    }\n\n    solve(LX, LY);\n    solve(RX, RY);\n\n    ll midX = P[LX.back()].first;\n    vector<int> stripe;\n    for(int id : PY)\n        if(square(P[id].first-midX) < best)\n            stripe.push_back(id);\n\n    for(int i = 0; i < (int) stripe.size(); i++)\n        for(int j = i+1; j < (int) stripe.size() && square(P[stripe[i]].second-P[stripe[j]].second) < best; j++)\n            best = min(best, dist(P[stripe[i]], P[stripe[j]]));\n}\n\nint main(){\n    scanf("%d", &N);\n    vector<int> sortedX, sortedY;\n    for(int i = 0, x, y; i < N; i++){\n        scanf("%d %d", &x, &y);\n        P[i] = {x, y};\n        sortedX.push_back(i);\n        sortedY.push_back(i);\n    }\n    sort(sortedX.begin(), sortedX.end(), [](int A, int B){\n        return P[A].first < P[B].first;\n    });\n    sort(sortedY.begin(), sortedY.end(), [](int A, int B){\n        return P[A].second < P[B].second;\n    });\n\n    best = LLONG_MAX;\n    solve(sortedX, sortedY);\n    printf("%lld\\n", best);\n}',
  "2195":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+5;\n\nstruct Point {\n    int x, y;\n    void read(){ scanf("%d %d", &x, &y); }\n    Point operator +(const Point& b) const { return Point{x+b.x, y+b.y}; }\n    Point operator -(const Point& b) const { return Point{x-b.x, y-b.y}; }\n    ll operator *(const Point& b) const { return (ll) x * b.y - (ll) y * b.x; }\n    bool operator <(const Point& b) const { return x == b.x ? y < b.y : x < b.x; }\n    void operator +=(const Point& b) { x += b.x; y += b.y; }\n    void operator -=(const Point &b) { x -= b.x; y -= b.y; }\n    void operator *=(const int k) { x *= k; y *= k; }\n\n    ll cross(const Point& b, const Point& c) const {\n        return (b - *this) * (c - *this);\n    }\n};\n\nint N, S;\nPoint P[maxN];\nvector<Point> hull;\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 0; i < N; i++)\n        P[i].read();\n    sort(P, P+N);\n\n    for(int t = 0; t < 2; t++){\n        for(int i = 0; i < N; i++){\n            while((int) hull.size()-S >= 2){\n                Point P1 = hull[hull.size()-2];\n                Point P2 = hull[hull.size()-1];\n                if(P1.cross(P2, P[i]) <= 0) break;\n                hull.pop_back();\n            }\n            hull.push_back(P[i]);\n        }\n        hull.pop_back();\n        S = hull.size();\n        reverse(P, P+N);\n    }\n\n    printf("%d\\n", S);\n    for(Point h : hull)\n        printf("%d %d\\n", h.x, h.y);\n}\n',
  "2205":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 16;\n\nint N;\nbool b[maxN+1];\n\nvoid print(){\n    for(int i = N; i > 0; i--)\n        printf("%d", b[i]);\n    printf("\\n");\n}\n\nint main(){\n    scanf("%d", &N);\n\n    print();\n    for(int i = 1; i < (1<<N); i++){\n        int LSB = __builtin_ffs(i);\n        b[LSB] ^= 1;\n        print();\n    }\n}\n',
  "2206":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1, SIZE = 4*maxN;\nconst int INF = 0x3f3f3f3f;\n\nint N, Q, p[maxN], mp[maxN], lo[SIZE], hi[SIZE], mn[2][SIZE];\n\nvoid pull(int i){\n    mn[0][i] = min(mn[0][2*i], mn[0][2*i+1]);\n    mn[1][i] = min(mn[1][2*i], mn[1][2*i+1]);\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        scanf("%d", &p[l]);\n        mn[0][i] = l+p[l];\n        mn[1][i] = (N-l+1)+p[l];\n        mp[l] = i;\n        return;\n    }\n    int m = (l+r)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid update(int idx, int val){\n    int i = mp[idx];\n    mn[0][i] = idx+val;\n    mn[1][i] = (N-idx+1)+val;\n    i >>= 1;\n    while(i){\n        pull(i);\n        i >>= 1;\n    }\n}\n\nint query(int i, int t, int l, int r){\n    if(l > hi[i] || r < lo[i])      return INF;\n    if(l <= lo[i] && hi[i] <= r)    return mn[t][i];\n\n    int left = query(2*i, t, l, r);\n    int right = query(2*i+1, t, l, r);\n    return min(left, right);\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    init(1, 1, N);\n    for(int q = 0, t, k, x; q < Q; q++){\n        scanf("%d %d", &t, &k);\n        if(t == 1){\n            scanf("%d", &x);\n            update(k, x);\n        } else if(t == 2){\n            int left = query(1, 1, 1, k);\n            int right = query(1, 0, k, N);\n            printf("%d\\n", min(left-(N-k+1), right-k));\n        }\n    }\n}\n',
  "2207":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 1e6+1;\n\n/**\n * A036685\n * Retrivied from https://oeis.org/A036685\n */\n\nint T, lose[42] = { 0, 1, 2, 4, 7, 10, 20, 23, 26, 50, 53, 270, 273, 276, 282, 285, 288, 316, 334, 337, 340, 346, 359, 362, 365, 386, 389, 392, 566, 630, 633, 636, 639, 673, 676, 682, 685, 923, 926, 929, 932, 1222 };\nbool b[maxN];\n\nvoid init(){\n    for(int x : lose)\n        b[x] = true;\n}\n\nint main(){\n    init();\n    scanf("%d", &T);\n    for(int t = 0, N; t < T; t++){\n        scanf("%d", &N);\n        printf("%s\\n", b[N] ? "second" : "first");\n    }\n}',
  "2208":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T, N, x;\nbool even;\n\nint main(){\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        scanf("%d", &N);\n        even = true;\n        for(int i = 0; i < N; i++){\n            scanf("%d", &x);\n            even &= !(x&1);\n        }\n        printf("%s\\n", even ? "second" : "first");\n    }\n}',
  "2209":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nint N, M;\nll ans;\n\nll fastpow(ll a, ll b){\n    ll res = 1;\n    while(b > 0){\n        if(b&1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int k = 0; k < N; k++)\n        ans = (ans + fastpow(M, __gcd(k, N))) % MOD;\n    ans = (ans * fastpow(N, MOD-2)) % MOD;\n    printf("%lld\\n", ans);\n}',
  "2210":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\n\nll N, A, B, C;\n\nll fastpow(ll a, ll b){\n    ll res = 1;\n    while(b > 0){\n        if(b&1)\n            res = (res * a) % MOD;\n        a = (a * a) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    scanf("%lld", &N);\n    A = N * N;\n    B = (A+3*(N&1))/4;\n    C = (A+(N&1))/2;\n    printf("%lld\\n", ((fastpow(2, A)+2*fastpow(2, B)+fastpow(2, C))*fastpow(4,MOD-2))%MOD);\n}\n',
  "2214":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e6+1;\n\nint N, idx, ans[maxN];\nll K;\ndeque<int> DQ;\n\nint main(){\n    scanf("%d %lld", &N, &K);\n    for(int i = 1; i <= N; i++)\n        DQ.push_back(i);\n\n    for(int k = N-1; k >= 0; k--){\n        if(k <= K){\n            ans[++idx] = DQ.back();\n            DQ.pop_back();\n            K -= k;\n        } else {\n            ans[++idx] = DQ.front();\n            DQ.pop_front();\n        }\n    }\n\n    for(int i = 1; i <= idx; i++)\n        printf("%d%c", ans[i], (" \\n")[i==idx]);\n}',
  "2215":
    '#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, K;\n\nvoid solve(){\n    scanf("%d %d", &N, &K);\n    if(K*K < N){\n        printf("IMPOSSIBLE\\n");\n        return;\n    }\n\n    vector<int> ans;\n    int l = 1, r = K;\n    while(true){\n        for(int i = r; i >= l; i--)\n            ans.push_back(i);\n        if(r == N)  break;\n        l = r+1;\n        r = min(r+K, N);\n    }\n\n    for(int i = 0; i < N; i++)\n        printf("%d%c", ans[i], (" \\n")[i==N-1]);\n}\n\nint main(){\n    int T;\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        solve();\n    }\n}',
  "2216":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1;\n\nint N, x, cnt, pos[maxN];\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &x);\n        pos[x] = i;\n    }\n\n    cnt = 1;\n    for(int i = 2; i <= N; i++)\n        if(pos[i-1] > pos[i])\n            cnt++;\n    printf("%d\\n", cnt);\n}\n',
  "2217":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\n\nint N, M, cnt, x[maxN], pos[maxN];\n\nvoid update(int a, int b){\n    if(pos[x[a]-1] <= pos[x[a]] && b < pos[x[a]-1]) cnt++;\n    if(pos[x[a]-1] > pos[x[a]] && b >= pos[x[a]-1]) cnt--;\n    if(pos[x[a]+1] >= pos[x[a]] && b > pos[x[a]+1]) cnt++;\n    if(pos[x[a]+1] < pos[x[a]] && b <= pos[x[a]+1]) cnt--;\n    pos[x[a]] = b;\n\n    if(pos[x[b]-1] <= pos[x[b]] && a < pos[x[b]-1]) cnt++;\n    if(pos[x[b]-1] > pos[x[b]] && a >= pos[x[b]-1]) cnt--;\n    if(pos[x[b]+1] >= pos[x[b]] && a > pos[x[b]+1]) cnt++;\n    if(pos[x[b]+1] < pos[x[b]] && a <= pos[x[b]+1]) cnt--;\n    pos[x[b]] = a;\n\n    swap(x[a], x[b]);\n}\n\nint main(){\n    scanf("%d %d", &N, &M);\n    for(int i = 1; i <= N; i++){\n        scanf("%d", &x[i]);\n        pos[x[i]] = i;\n    }\n    pos[N+1] = N+1;\n\n    cnt = 1;\n    for(int i = 1, ptr = 0; i <= N; i++){\n        if(ptr > pos[i])\n            cnt++;\n        ptr = pos[i];\n    }\n\n    for(int i = 0, a, b; i < M; i++){\n        scanf("%d %d", &a, &b);\n        update(a, b);\n        printf("%d\\n", cnt);\n    }\n}\n',
  "2220":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 20;\n\nbool tight[maxN];\nll dp[10][maxN];\n\nll solve(ll x){\n    if(x <= 10) return x;\n\n    vector<int> D;\n    memset(dp, 0, sizeof(dp));\n    memset(tight, 0, sizeof(tight));\n    for(int i = 0; x; i++){\n        D.push_back(x%10);\n        x /= 10;\n    }\n    reverse(D.begin(), D.end());\n    int N = (int) D.size();\n\n    tight[0] = true;\n    for(int i = 1; i < N; i++)\n        tight[i] = tight[i-1] && (D[i] != D[i-1]);\n    for(int d = 1; d < D[0]; d++)\n        dp[d][0] = 1;\n\n    for(int i = 1; i < N; i++){\n        // Prefix [0..i-1] is same as X\n        if(tight[i-1])\n            for(int d = 0; d < D[i]; d++)\n                if(d != D[i-1])\n                    dp[d][i]++;\n\n        // Prefix [0..i-1] is all leading zeros\n        for(int d = 1; d <= 9; d++)\n            dp[d][i]++;\n\n        //  All other cases\n        for(int d1 = 0; d1 <= 9; d1++)\n            for(int d2 = 0; d2 <= 9; d2++)\n                if(d1 != d2)\n                    dp[d2][i] += dp[d1][i-1];\n    }\n\n    ll cnt = tight[N-1];\n    for(int d = 0; d <= 9; d++)\n        cnt += dp[d][N-1];\n    return cnt;\n}\n\nint main(){\n    ll a, b;\n    scanf("%lld %lld", &a, &b);\n    printf("%lld\\n", solve(b) - solve(a-1));\n}',
  "2228":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e6+1;\nconst ll MOD = 1e9+7;\n\nint N, K;\nll fac[maxN], inv[maxN];\n\nll fastpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n        if(b&1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid init_choose(){\n    fac[0] = inv[0] = 1;\n    for(int i = 1; i < maxN; i++){\n        fac[i] = (fac[i-1] * i) % MOD;\n        inv[i] = fastpow(fac[i], MOD-2);\n    }\n}\n\nll choose(int n, int k){\n    if(k < 0 || k > n)  return 0;\n    return fac[n] * inv[k] % MOD * inv[n-k] % MOD;\n}\n\nll T(int n, int k){\n    ll sum = 0;\n    for(int j = 0; j <= k; j++){\n        ll a = (j&1 ? -1 : 1);\n        ll b = choose(k, j);\n        ll c = fastpow(k-j, n);\n        ll term = (a * b % MOD * c % MOD + MOD) % MOD;\n        sum = (sum + term) % MOD;\n    }\n    return sum;\n}\n\nint main(){\n    init_choose();\n    scanf("%d %d", &N, &K);\n    printf("%lld\\n", T(N, K));\n}',
  "2229":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 501;\nconst int maxK = maxN*(maxN-1)/2;\nconst ll MOD = 1e9+7;\n\nint N, K;\nll dp[maxN][maxK];\n\nvoid init(){\n    for(int i = 1; i < maxN; i++){\n        int r = i*(i-1)/2;\n        dp[i][0] = dp[i][r] = 1;\n        for(int j = 1; j <= r/2; j++){\n            dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD;\n            if(j-i >= 0)\n                dp[i][j] = (dp[i][j] - dp[i-1][j-i] + MOD) % MOD;\n        }\n        for(int j = r/2+1; j < r; j++)\n            dp[i][j] = dp[i][r-j];\n    }\n}\n\nint main(){\n    init();\n    scanf("%d %d", &N, &K);\n    printf("%lld\\n", dp[N][K]);\n}',
  "2413":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e6;\nconst ll MOD = 1e9+7;\n\nint T, N;\nll dp[maxN+1];\n\nint main(){\n    dp[1] = 2;\n    dp[2] = 8;\n    for(int i = 3; i <= maxN; i++)\n        dp[i] = ((6*dp[i-1] - 7*dp[i-2]) % MOD + MOD) % MOD;\n\n    scanf("%d", &T);\n    for(int t = 0; t < T; t++){\n        scanf("%d", &N);\n        printf("%lld\\n", dp[N]);\n    }\n}\n',
  "2414":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 101, maxM = 4951;\n\nint N, M;\nmultiset<ll> Bvals;\nll A[maxN], B[maxM];\n\nbool check(ll a0){\n    A[0] = a0;\n    Bvals.clear();\n    for(int i = 0; i < M; i++)\n        Bvals.insert(B[i]);\n\n    for(int i = 1; i < N; i++){\n        for(int j = 0; j < i-1; j++){\n            if(Bvals.find(A[j]+A[i-1]) == Bvals.end())\n                return false;\n            Bvals.erase(Bvals.lower_bound(A[j]+A[i-1]));\n        }\n        A[i] = *Bvals.begin() - A[0];\n    }\n\n    // Confirm that the last element, A[N-1], works. We desire\n    // the sum with the other A[i] to produce the remaining Bvals\n    for(int j = 0; j < N-1; j++){\n        if(Bvals.find(A[j]+A[N-1]) == Bvals.end())\n            return false;\n        Bvals.erase(Bvals.lower_bound(A[j]+A[N-1]));\n    }\n\n    return true;\n}\n\nint main(){\n    scanf("%d", &N);\n    M = N*(N-1)/2;\n    for(int i = 0; i < M; i++)\n        scanf("%lld", &B[i]);\n    sort(B, B+M);\n\n    for(int i = 1; i < M; i++){\n        ll a0 = (B[0] + B[1] - B[i])/2;\n        if(1 <= a0 && a0 <= B[0]/2 && check(a0)){\n            for(int j = 0; j < N; j++)\n                printf("%lld%c", A[j], (" \\n")[j==N-1]);\n            return 0;\n        }\n    }\n\n    printf("IMPOSSIBLE\\n");\n}',
  "2415":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 5001;\nconst ll MOD = 1e9+7;\n\nint N;\nll pown[maxN], fac[maxN], inv[maxN], S[maxN][maxN];\n\nll inverse(ll x){\n    ll res = 1;\n    ll b = MOD-2;\n    while(b){\n        if(b&1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid init_powers(){\n    pown[0] = 1;\n    for(int i = 1; i < maxN; i++)\n        pown[i] = (pown[i-1] * N) % MOD;\n}\n\nvoid init_choose(){\n    fac[0] = inv[0] = 1;\n    for(int i = 1; i < maxN; i++){\n        fac[i] = (fac[i-1] * i) % MOD;\n        inv[i] = inverse(fac[i]);\n    }\n}\n\nvoid init_stirling(){\n    S[1][1] = 1;\n    for(int n = 2; n < maxN; n++)\n        for(int k = 1; k <= n; k++)\n            S[n][k] = (S[n-1][k-1] - (n-1) * S[n-1][k]) % MOD;\n}\n\nll choose(int n, int k){\n    if(k < 0 || k > n)  return 0;\n    return fac[n] * inv[k] % MOD * inv[n-k] % MOD;\n}\n\nll stirling1(int n, int k){\n    return abs(S[n][k]);\n}\n\nll T(int n, int k){\n    ll sum = 0;\n    for(int j = 0; j <= n-1; j++){\n        ll a = choose(n-1, j);\n        ll b = pown[n-1-j];\n        ll c = stirling1(j+1, k);\n        sum += a * b % MOD * c % MOD;\n        sum %= MOD;\n    }\n    return sum;\n}\n\nint main(){\n    scanf("%d", &N);\n    init_powers();\n    init_choose();\n    init_stirling();\n    for(int k = 1; k <= N; k++)\n        printf("%lld\\n", T(N, k));\n}',
  "2416":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5+1;\nconst int SIZE = 4*maxN;\n\nint N, Q, lo[SIZE], hi[SIZE];\nll a[maxN], ass[SIZE], mx[SIZE], sm[SIZE], ans[maxN];\nvector<pii> queries[maxN];\n\nint len(int i){\n    return hi[i]-lo[i]+1;\n}\n\nvoid assign(int i, ll val){\n    ass[i] = mx[i] = val;\n    sm[i] = val * len(i);\n}\n\nvoid push(int i){\n    if(ass[i]){\n        assign(2*i, ass[i]);\n        assign(2*i+1, ass[i]);\n        ass[i] = 0;\n    }\n}\n\nvoid pull(int i){\n    sm[i] = sm[2*i] + sm[2*i+1];\n    mx[i] = max(mx[2*i], mx[2*i+1]);\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r){\n        sm[i] = a[l];\n        return;\n    }\n    int m = (l+r)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid update(int i, int l, int r, ll val){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        assign(i, val);\n        return;\n    }\n\n    push(i);\n    update(2*i, l, r, val);\n    update(2*i+1, l, r, val);\n    pull(i);\n}\n\nint orderOf(int i, int l, int val){\n    if(lo[i] == hi[i])                  return lo[i];\n    push(i);\n    int idx = -1;\n    if(hi[2*i] <= l || mx[2*i] < val)   idx = orderOf(2*i+1, l, val);\n    else                                idx = orderOf(2*i, l, val);\n    pull(i);\n    return idx;\n}\n\nll sum(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])      return 0;\n    if(l <= lo[i] && hi[i] <= r)    return sm[i];\n\n    push(i);\n    ll left = sum(2*i, l, r);\n    ll right = sum(2*i+1, l, r);\n    pull(i);\n\n    return left+right;\n}\n\nint main(){\n    scanf("%d %d", &N, &Q);\n    for(int i = 1; i <= N; i++)\n        scanf("%lld", &a[i]);\n\n    init(1, 1, N);\n    for(int q = 0, l, r; q < Q; q++){\n        scanf("%d %d", &l, &r);\n        queries[l].push_back({r, q});\n    }\n\n    for(int i = 2; i <= N; i++) a[i] += a[i-1];\n    for(int l = N; l >= 1; l--){\n        int val = a[l]-a[l-1];\n        int modifyR = (mx[1] < val ? N+1 : orderOf(1, l, val));\n        update(1, l, modifyR-1, val);\n        for(pii q : queries[l]){\n            int r = q.first;\n            int id = q.second;\n            ans[id] = sum(1, l, r) - (a[r]-a[l-1]);\n        }\n    }\n\n    for(int i = 0; i < Q; i++)\n        printf("%lld\\n", ans[i]);\n}\n',
  "2417":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxX = 1e6+1;\n\nll ans;\nint N, dp[maxX];\nbool b[maxX];\nvector<int> primes;\n\nvoid init(){\n    fill(b+2, b+maxX, true);\n    for(int i = 2; i*i < maxX; i++)\n        if(b[i])\n            for(int j = i*i; j < maxX; j += i)\n                b[j] = false;\n    for(int i = 2; i < maxX; i++)\n        if(b[i])\n            primes.push_back(i);\n}\n\nvoid compute(int x){\n    vector<int> pf;\n    for(int p : primes){\n        if(x == 1)  break;\n        else if(b[x]){\n            pf.push_back(x);\n            break;\n        }\n\n        if(x % p)   continue;\n        pf.push_back(p);\n        while(x % p == 0)\n            x /= p;\n    }\n\n    int K = (int) pf.size();\n    for(int mask = 0; mask < (1<<K); mask++){\n        int mu = 1;\n        for(int i = 0; i < K; i++)\n            if(mask&(1<<i))\n                mu *= pf[i];\n\n        int k = __builtin_popcount(mask);\n        ans += (k&1 ? -dp[mu] : dp[mu]);\n        dp[mu]++;\n    }\n}\n\nint main(){\n    init();\n    scanf("%d", &N);\n    for(int i = 0, x; i < N; i++){\n        scanf("%d", &x);\n        compute(x);\n    }\n    printf("%lld\\n", ans);\n}',
  "2419":
    '#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+5;\n\nint N, D, a, xum;\n\nint two_divisibility(int x){\n    int res = 0;\n    while(x){\n        x >>= 1;\n        res += x;\n    }\n    return res;\n}\n\nint main(){\n    scanf("%d", &N);\n    D = two_divisibility(N-1);\n    for(int i = 0; i < N; i++){\n        scanf("%d", &a);\n        int d1 = two_divisibility(i);\n        int d2 = two_divisibility(N-i-1);\n        if(D - d1 - d2 == 0)\n            xum ^= a;\n    }\n    printf("%d\\n", xum);\n}\n',
  "2420":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\nconst ll p[2] = {31, 37};\nconst int maxN = 2e5+5;\n\nchar S[maxN];\nint N, K;\nll pows[2][maxN], invs[2][maxN], F[2], B[2], ds[2][2][maxN];\n\nll inverse(ll x){\n    ll res = 1;\n    ll b = MOD-2;\n    while(b){\n        if(b&1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid update(int pt, int t, int idx, ll val){\n    val %= MOD; val += MOD; val %= MOD;\n    for(int i = idx+1; i < maxN; i += -i&i)\n        ds[pt][t][i] = (ds[pt][t][i] + val) % MOD;\n}\n\nll query(int pt, int t, int idx){\n    if(idx < 0) return 0;\n    ll sum = 0;\n    for(int i = idx+1; i > 0; i -= -i&i)\n        sum = (sum + ds[pt][t][i]) % MOD;\n    return sum;\n}\n\nvoid init(){\n    for(int t = 0; t < 2; t++){\n        pows[t][0] = invs[t][0] = 1;\n        for(int i = 1; i < maxN; i++){\n            pows[t][i] = (pows[t][i-1] * p[t]) % MOD;\n            invs[t][i] = inverse(pows[t][i]);\n        }\n        update(t, 0, 0, (int) (S[0]-\'a\'+1) * pows[t][N-1]);\n        update(t, 1, 0, (int) (S[0]-\'a\'+1));\n        for(int i = 1; i < N; i++){\n            int c = (int) (S[i]-\'a\'+1);\n            update(t, 0, i, c * pows[t][N-i-1]);\n            update(t, 1, i, c * pows[t][i]);\n        }\n    }\n}\n\nvoid modify(int a, char c){\n    int newchar = (int) (c - \'a\' + 1);\n    int oldchar = (int) (S[a] - \'a\' + 1);\n    for(int t = 0; t < 2; t++){\n        update(t, 0, a, -oldchar * pows[t][N-a-1]);\n        update(t, 0, a, newchar * pows[t][N-a-1]);\n        update(t, 1, a, -oldchar * pows[t][a]);\n        update(t, 1, a, newchar * pows[t][a]);\n    }\n    S[a] = c;\n}\n\nbool palindrome(int a, int b){\n    for(int t = 0; t < 2; t++){\n        F[t] = (query(t, 0, b) - query(t, 0, a-1) + MOD) % MOD;\n        F[t] = (F[t] * invs[t][N-b-1]) % MOD;\n        B[t] = (query(t, 1, b) - query(t, 1, a-1) + MOD) % MOD;\n        B[t] = (B[t] * invs[t][a]) % MOD;\n    }\n    return F[0] == B[0] && F[1] == B[1];\n}\n\nint main(){\n    scanf("%d %d %s", &N, &K, S);\n\n    init();\n    for(int i = 0, t, a, b; i < K; i++){\n        char c;\n        scanf("%d", &t);\n        if(t == 1){\n            scanf("%d %c", &a, &c);\n            modify(a-1, c);\n        } else if(t == 2){\n            scanf("%d %d", &a, &b);\n            printf("%s\\n", palindrome(a-1, b-1) ? "YES" : "NO");\n        }\n    }\n}',
  "2422":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nll N;\n\nll f(ll x){\n    ll cnt = 0;\n    for(ll i = 1; i <= N; i++)\n        cnt += min(N, x/i);\n    return cnt;\n}\n\nint main(){\n    scanf("%lld", &N);\n    ll lo = 0, hi = N*N;\n    while(hi-lo > 1){\n        ll mid = lo + (hi-lo)/2;\n        if(f(mid) < (N*N+1)/2)  lo = mid;\n        else                    hi = mid;\n    }\n    printf("%lld\\n", lo+1);\n}\n',
  "2425":
    "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxN = 2e5+1, SIZE = 4*maxN;\nconst int INF = 0x3f3f3f3f;\n\nint N, lo[SIZE], hi[SIZE], delta[SIZE], mx[SIZE], mn[SIZE];\n\nvoid push(int i){\n    if(delta[i] != 0){\n        delta[2*i] += delta[i];\n        delta[2*i+1] += delta[i];\n        delta[i] = 0;\n    }\n}\n\nvoid pull(int i){\n    mn[i] = min(mn[2*i]+delta[2*i], mn[2*i+1]+delta[2*i+1]);\n    mx[i] = max(mx[2*i]+delta[2*i], mx[2*i+1]+delta[2*i+1]);\n}\n\nvoid init(int i, int l, int r){\n    lo[i] = l; hi[i] = r;\n    if(l == r)  return;\n    int m = l+(r-l)/2;\n    init(2*i, l, m);\n    init(2*i+1, m+1, r);\n    pull(i);\n}\n\nvoid increment(int i, int l, int r, int v){\n    if(l > hi[i] || r < lo[i])  return;\n    if(l <= lo[i] && hi[i] <= r){\n        delta[i] += v; return;\n    }\n\n    push(i);\n    increment(2*i, l, r, v);\n    increment(2*i+1, l, r, v);\n    pull(i);\n}\n\nint minimum(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])      return INF;\n    if(l <= lo[i] && hi[i] <= r)    return mn[i]+delta[i];\n\n    push(i);\n    int lmin = minimum(2*i, l, r);\n    int rmin = minimum(2*i+1, l, r);\n    pull(i);\n\n    return min(lmin, rmin);\n}\n\nint maximum(int i, int l, int r){\n    if(l > hi[i] || r < lo[i])      return -INF;\n    if(l <= lo[i] && hi[i] <= r)    return mx[i]+delta[i];\n\n    push(i);\n    int lmax = maximum(2*i, l, r);\n    int rmax = maximum(2*i+1, l, r);\n    pull(i);\n\n    return max(lmax, rmax);\n}\n\nvoid place_coin(int c, int s){\n    int v = (s == 1 ? -1 : 1);\n    increment(1, 1, c, v);\n}\n\nchar query_stacks(){\n    int totmin = minimum(1, 1, N);\n    int totmax = maximum(1, 1, N);\n    if(totmin >= 0 && totmax <= 0)  return '?';\n    else if(totmin >= 0)            return '<';\n    else if(totmax <= 0)            return '>';\n    else                            return '?';\n}\n\nint main(){\n    scanf(\"%d\", &N);\n    init(1, 1, N);\n    for(int i = 0, c, s; i < N; i++){\n        scanf(\"%d %d\", &c, &s);\n        place_coin(c, s);\n        printf(\"%c\\n\", query_stacks());\n    }\n}",
  "2426":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxN = 2e5+5;\n\nint N, A, B;\npii cand[maxN];\n\nmultiset<int> initial_artist_set(){\n    vector<int> all;\n    for(int i = A; i < N; i++)\n        all.push_back(cand[i].second);\n    sort(all.begin(), all.end());\n\n    reverse(all.begin(), all.end());\n    multiset<int> best;\n    for(int i = 0; i < B; i++)\n        best.insert(all[i]);\n    return best;\n}\n\nint main(){\n    scanf("%d %d %d", &A, &B, &N);\n    for(int i = 0, x, y; i < N; i++){\n        scanf("%d %d", &x, &y);\n        cand[i] = {x, y};\n    }\n    sort(cand, cand+N, [](const pii a, const pii b){\n        return a.first == b.first ? a.second < b.second : a.first > b.first;\n    });\n\n    ll pref = 0;\n    priority_queue<int> prefix_deltas;\n    for(int i = 0; i < A; i++){\n        pref += cand[i].first;\n        prefix_deltas.push(cand[i].second - cand[i].first);\n    }\n\n    multiset<int> remaining_art = initial_artist_set();\n    ll suf = accumulate(remaining_art.begin(), remaining_art.end(), 0LL);\n\n    ll ans = pref + suf;\n    for(int i = A; i < A+B; i++){\n        const int x = cand[i].first;\n        const int y = cand[i].second;\n        pref += x;\n\n        prefix_deltas.push(y - x);\n        pref += prefix_deltas.top();\n        prefix_deltas.pop();\n\n        auto worst_artist = remaining_art.lower_bound(y);\n        int art_value = *worst_artist;\n        remaining_art.erase(worst_artist);\n        suf -= art_value;\n\n        ans = max(ans, pref + suf);\n    }\n    printf("%lld\\n", ans);\n}\n',
  "2428":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 2e5+5;\n\nint N, K, x[maxN];\nmap<int,int> freq;\nll ans;\n\nint main(){\n    scanf("%d %d", &N, &K);\n    for(int i = 1; i <= N; i++)\n        scanf("%d", &x[i]);\n\n    int unique = 0;\n    int r = 0;\n    for(int l = 1; l <= N; l++){\n        while(r < N && (freq[x[r+1]] >= 1 || unique < K)){\n            r++;\n            freq[x[r]]++;\n            if(freq[x[r]] == 1)\n                unique++;\n        }\n\n        ans += (r-l+1);\n\n        freq[x[l]]--;\n        if(!freq[x[l]])\n            unique--;\n    }\n\n    printf("%lld\\n", ans);\n}\n',
  "2429":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9+7;\nconst int maxN = 505;\n\nint N, p[maxN], q[maxN], C[6];\nbool inp[maxN], inq[maxN];\nchar S[maxN];\nll fact[maxN], inv[maxN];\n\nll inverse(ll x){\n    ll res = 1;\n    ll b = MOD-2;\n    while(b){\n        if(b&1) res = (res * x) % MOD;\n        x = (x * x) % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll choose(int x, int y){\n    return (fact[x] * inv[y] % MOD) * inv[x-y] % MOD;\n}\n\nvoid init(){\n    fact[0] = inv[0] = 1;\n    for(int i = 1; i <= N; i++){\n        fact[i] = (fact[i-1] * i) % MOD;\n        inv[i] = (inv[i-1] * inverse(i)) % MOD;\n    }\n}\n\nll f(int i, int j, int k){\n    ll res = (choose(C[0], i)\n            * choose(C[1], j) % MOD\n            * choose(C[2], k) % MOD\n            * choose(C[3], i) % MOD);\n\n    res = (res * fact[i] % MOD\n               * fact[C[4]-i-j] % MOD\n               * fact[C[5]-i-k] % MOD);\n\n    if((i+j+k) % 2 == 1)\n        res = (MOD - res);\n\n    return res;\n}\n\nint main(){\n    scanf("%d", &N);\n    init();\n    for(int i = 0; i < N; i++){\n        scanf(" %s", S);\n        p[i] = q[i] = -1;\n        for(int j = 0; j < N; j++){\n            if(S[j] == \'A\') { p[i] = j; inp[j] = true; }\n            if(S[j] == \'B\') { q[i] = j; inq[j] = true; }\n        }\n    }\n\n    for(int i = 0; i < N; i++){\n        if(p[i] == -1 && q[i] == -1)                C[0]++;\n        if(p[i] == -1 && q[i] != -1 && !inp[q[i]])  C[1]++;\n        if(p[i] != -1 && q[i] == -1 && !inq[p[i]])  C[2]++;\n    }\n\n    for(int i = 0; i < N; i++){\n        if(!inp[i] && !inq[i])  C[3]++;\n        if(!inp[i])             C[4]++;\n        if(!inq[i])             C[5]++;\n    }\n\n    ll ans = 0;\n    for(int i = 0; i <= min(C[0], C[3]); i++)\n        for(int j = 0; j <= C[1]; j++)\n            for(int k = 0; k <= C[2]; k++)\n                ans = (ans + f(i, j, k)) % MOD;\n    printf("%lld\\n", ans);\n}',
  "2431":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint Q;\nll K;\n\nll pow10(int x){\n    ll res = 1;\n    for(int i = 0; i < x; i++)\n        res *= 10;\n    return res;\n}\n\nint solve(ll N){\n    if(N < 9)   return (int) N+1;\n\n    int len = 1;\n    while(9 * pow10(len-1) * len < N){\n        N -= 9 * pow10(len-1) * len;\n        len++;\n    }\n\n    string S = to_string(pow10(len-1) + N/len);\n    return (int) (S[N%len] - \'0\');\n}\n\nint main(){\n    scanf("%d", &Q);\n    for(int q = 0; q < Q; q++){\n        scanf("%lld", &K);\n        printf("%d\\n", solve(K-1));\n    }\n}',
  "2432":
    '#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int maxN = 105, maxM = 2605;\nconst int INF = 0x3f3f3f3f;\n\nint N, rowTot, colTot, edgeID, p[maxN], cap[maxN][maxN];\nbool vis[maxM];\nvector<int> path, F[maxN];\nvector<pii> G[maxN];\n\nint bfs(int s = 0, int t = 2*N+1){\n    fill(p, p+2*N+2, -1);\n    p[s] = -2;\n\n    queue<pii> Q;\n    Q.push({s, INF});\n    while(!Q.empty()){\n        int u = Q.front().first;\n        int f = Q.front().second;\n        Q.pop();\n\n        for(int v : F[u]){\n            if(p[v] == -1 && cap[u][v]){\n                p[v] = u;\n                int aug = min(f, cap[u][v]);\n                if(v == t)  return aug;\n                Q.push({v, aug});\n            }\n        }\n    }\n\n    return 0;\n}\n\nvoid dfs(int u = 0){\n    path.push_back(u);\n    if(u == N)  return;\n    for(pii e : G[u]){\n        int v = e.first;\n        int id = e.second;\n        if(cap[u][v] == 0 && !vis[id]){\n            vis[id] = true;\n            dfs(v);\n            return;\n        }\n    }\n}\n\nint maxflow(int s = 0, int t = 2*N+1){\n    int flow = 0, aug = 0;\n    while(aug = bfs()){\n        flow += aug;\n        int u = t;\n        while(u != s){\n            int v = p[u];\n            cap[v][u] -= aug;\n            cap[u][v] += aug;\n            u = v;\n        }\n    }\n    return flow;\n}\n\nint main(){\n    scanf("%d", &N);\n    for(int i = 1, c; i <= N; i++){\n        scanf("%d", &c);\n        G[0].push_back({i, ++edgeID});\n        F[0].push_back(i);\n        F[i].push_back(0);\n        cap[0][i] += c;\n        rowTot += c;\n    }\n    for(int i = N+1, c; i <= 2*N; i++){\n        scanf("%d", &c);\n        G[i].push_back({2*N+1, ++edgeID});\n        F[i].push_back(2*N+1);\n        F[2*N+1].push_back(i);\n        cap[i][2*N+1] += c;\n        colTot += c;\n    }\n    for(int i = 1; i <= N; i++){\n        for(int j = N+1; j <= 2*N; j++){\n            G[i].push_back({j, ++edgeID});\n            F[i].push_back(j);\n            F[j].push_back(i);\n            cap[i][j]++;\n        }\n    }\n\n    int K = maxflow();\n    if(rowTot != colTot || K != rowTot){\n        printf("-1\\n");\n        return 0;\n    }\n\n    for(int i = 1; i <= N; i++){\n        for(int j = 1; j <= N; j++)\n            printf("%c", (cap[i][j+N] ? \'.\' : \'X\'));\n        printf("\\n");\n    }\n}',
};

interface Problem {
  id: number; // Unique identifier for the problem
  name: string; // Problem name
  question: string; // Problem description or question
  tags: string; // Tags or categories associated with the problem
  solution: string;
}
export const csesData: Problem[] = problems.map((problem) => ({
  ...problem,
  solution: solutions[String(problem.id)] || "Solution not available yet.",
}));
